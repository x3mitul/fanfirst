
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model EventReminder
 * 
 */
export type EventReminder = $Result.DefaultSelection<Prisma.$EventReminderPayload>
/**
 * Model TicketTier
 * 
 */
export type TicketTier = $Result.DefaultSelection<Prisma.$TicketTierPayload>
/**
 * Model Ticket
 * 
 */
export type Ticket = $Result.DefaultSelection<Prisma.$TicketPayload>
/**
 * Model Community
 * 
 */
export type Community = $Result.DefaultSelection<Prisma.$CommunityPayload>
/**
 * Model CommunityPost
 * 
 */
export type CommunityPost = $Result.DefaultSelection<Prisma.$CommunityPostPayload>
/**
 * Model PostVote
 * 
 */
export type PostVote = $Result.DefaultSelection<Prisma.$PostVotePayload>
/**
 * Model CommunityMember
 * 
 */
export type CommunityMember = $Result.DefaultSelection<Prisma.$CommunityMemberPayload>
/**
 * Model GovernanceProposal
 * 
 */
export type GovernanceProposal = $Result.DefaultSelection<Prisma.$GovernanceProposalPayload>
/**
 * Model ProposalOption
 * 
 */
export type ProposalOption = $Result.DefaultSelection<Prisma.$ProposalOptionPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model CommentVote
 * 
 */
export type CommentVote = $Result.DefaultSelection<Prisma.$CommentVotePayload>
/**
 * Model Quiz
 * 
 */
export type Quiz = $Result.DefaultSelection<Prisma.$QuizPayload>
/**
 * Model QuizQuestion
 * 
 */
export type QuizQuestion = $Result.DefaultSelection<Prisma.$QuizQuestionPayload>
/**
 * Model QuizAttempt
 * 
 */
export type QuizAttempt = $Result.DefaultSelection<Prisma.$QuizAttemptPayload>
/**
 * Model QuizResponse
 * 
 */
export type QuizResponse = $Result.DefaultSelection<Prisma.$QuizResponsePayload>
/**
 * Model FanIQBadge
 * 
 */
export type FanIQBadge = $Result.DefaultSelection<Prisma.$FanIQBadgePayload>
/**
 * Model QuizUserStats
 * 
 */
export type QuizUserStats = $Result.DefaultSelection<Prisma.$QuizUserStatsPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eventReminder`: Exposes CRUD operations for the **EventReminder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventReminders
    * const eventReminders = await prisma.eventReminder.findMany()
    * ```
    */
  get eventReminder(): Prisma.EventReminderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketTier`: Exposes CRUD operations for the **TicketTier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketTiers
    * const ticketTiers = await prisma.ticketTier.findMany()
    * ```
    */
  get ticketTier(): Prisma.TicketTierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticket`: Exposes CRUD operations for the **Ticket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.ticket.findMany()
    * ```
    */
  get ticket(): Prisma.TicketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.community`: Exposes CRUD operations for the **Community** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Communities
    * const communities = await prisma.community.findMany()
    * ```
    */
  get community(): Prisma.CommunityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.communityPost`: Exposes CRUD operations for the **CommunityPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityPosts
    * const communityPosts = await prisma.communityPost.findMany()
    * ```
    */
  get communityPost(): Prisma.CommunityPostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postVote`: Exposes CRUD operations for the **PostVote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostVotes
    * const postVotes = await prisma.postVote.findMany()
    * ```
    */
  get postVote(): Prisma.PostVoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.communityMember`: Exposes CRUD operations for the **CommunityMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommunityMembers
    * const communityMembers = await prisma.communityMember.findMany()
    * ```
    */
  get communityMember(): Prisma.CommunityMemberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.governanceProposal`: Exposes CRUD operations for the **GovernanceProposal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GovernanceProposals
    * const governanceProposals = await prisma.governanceProposal.findMany()
    * ```
    */
  get governanceProposal(): Prisma.GovernanceProposalDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proposalOption`: Exposes CRUD operations for the **ProposalOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProposalOptions
    * const proposalOptions = await prisma.proposalOption.findMany()
    * ```
    */
  get proposalOption(): Prisma.ProposalOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.commentVote`: Exposes CRUD operations for the **CommentVote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommentVotes
    * const commentVotes = await prisma.commentVote.findMany()
    * ```
    */
  get commentVote(): Prisma.CommentVoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quiz`: Exposes CRUD operations for the **Quiz** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Quizzes
    * const quizzes = await prisma.quiz.findMany()
    * ```
    */
  get quiz(): Prisma.QuizDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizQuestion`: Exposes CRUD operations for the **QuizQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizQuestions
    * const quizQuestions = await prisma.quizQuestion.findMany()
    * ```
    */
  get quizQuestion(): Prisma.QuizQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizAttempt`: Exposes CRUD operations for the **QuizAttempt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizAttempts
    * const quizAttempts = await prisma.quizAttempt.findMany()
    * ```
    */
  get quizAttempt(): Prisma.QuizAttemptDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizResponse`: Exposes CRUD operations for the **QuizResponse** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizResponses
    * const quizResponses = await prisma.quizResponse.findMany()
    * ```
    */
  get quizResponse(): Prisma.QuizResponseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fanIQBadge`: Exposes CRUD operations for the **FanIQBadge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FanIQBadges
    * const fanIQBadges = await prisma.fanIQBadge.findMany()
    * ```
    */
  get fanIQBadge(): Prisma.FanIQBadgeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.quizUserStats`: Exposes CRUD operations for the **QuizUserStats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuizUserStats
    * const quizUserStats = await prisma.quizUserStats.findMany()
    * ```
    */
  get quizUserStats(): Prisma.QuizUserStatsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Event: 'Event',
    EventReminder: 'EventReminder',
    TicketTier: 'TicketTier',
    Ticket: 'Ticket',
    Community: 'Community',
    CommunityPost: 'CommunityPost',
    PostVote: 'PostVote',
    CommunityMember: 'CommunityMember',
    GovernanceProposal: 'GovernanceProposal',
    ProposalOption: 'ProposalOption',
    Comment: 'Comment',
    CommentVote: 'CommentVote',
    Quiz: 'Quiz',
    QuizQuestion: 'QuizQuestion',
    QuizAttempt: 'QuizAttempt',
    QuizResponse: 'QuizResponse',
    FanIQBadge: 'FanIQBadge',
    QuizUserStats: 'QuizUserStats'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "event" | "eventReminder" | "ticketTier" | "ticket" | "community" | "communityPost" | "postVote" | "communityMember" | "governanceProposal" | "proposalOption" | "comment" | "commentVote" | "quiz" | "quizQuestion" | "quizAttempt" | "quizResponse" | "fanIQBadge" | "quizUserStats"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      EventReminder: {
        payload: Prisma.$EventReminderPayload<ExtArgs>
        fields: Prisma.EventReminderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventReminderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventReminderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventReminderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventReminderPayload>
          }
          findFirst: {
            args: Prisma.EventReminderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventReminderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventReminderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventReminderPayload>
          }
          findMany: {
            args: Prisma.EventReminderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventReminderPayload>[]
          }
          create: {
            args: Prisma.EventReminderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventReminderPayload>
          }
          createMany: {
            args: Prisma.EventReminderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventReminderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventReminderPayload>[]
          }
          delete: {
            args: Prisma.EventReminderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventReminderPayload>
          }
          update: {
            args: Prisma.EventReminderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventReminderPayload>
          }
          deleteMany: {
            args: Prisma.EventReminderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventReminderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventReminderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventReminderPayload>[]
          }
          upsert: {
            args: Prisma.EventReminderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventReminderPayload>
          }
          aggregate: {
            args: Prisma.EventReminderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventReminder>
          }
          groupBy: {
            args: Prisma.EventReminderGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventReminderGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventReminderCountArgs<ExtArgs>
            result: $Utils.Optional<EventReminderCountAggregateOutputType> | number
          }
        }
      }
      TicketTier: {
        payload: Prisma.$TicketTierPayload<ExtArgs>
        fields: Prisma.TicketTierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketTierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketTierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTierPayload>
          }
          findFirst: {
            args: Prisma.TicketTierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketTierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTierPayload>
          }
          findMany: {
            args: Prisma.TicketTierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTierPayload>[]
          }
          create: {
            args: Prisma.TicketTierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTierPayload>
          }
          createMany: {
            args: Prisma.TicketTierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketTierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTierPayload>[]
          }
          delete: {
            args: Prisma.TicketTierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTierPayload>
          }
          update: {
            args: Prisma.TicketTierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTierPayload>
          }
          deleteMany: {
            args: Prisma.TicketTierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketTierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketTierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTierPayload>[]
          }
          upsert: {
            args: Prisma.TicketTierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketTierPayload>
          }
          aggregate: {
            args: Prisma.TicketTierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketTier>
          }
          groupBy: {
            args: Prisma.TicketTierGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketTierGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketTierCountArgs<ExtArgs>
            result: $Utils.Optional<TicketTierCountAggregateOutputType> | number
          }
        }
      }
      Ticket: {
        payload: Prisma.$TicketPayload<ExtArgs>
        fields: Prisma.TicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findFirst: {
            args: Prisma.TicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findMany: {
            args: Prisma.TicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          create: {
            args: Prisma.TicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          createMany: {
            args: Prisma.TicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          delete: {
            args: Prisma.TicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          update: {
            args: Prisma.TicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          deleteMany: {
            args: Prisma.TicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          upsert: {
            args: Prisma.TicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          aggregate: {
            args: Prisma.TicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicket>
          }
          groupBy: {
            args: Prisma.TicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCountAggregateOutputType> | number
          }
        }
      }
      Community: {
        payload: Prisma.$CommunityPayload<ExtArgs>
        fields: Prisma.CommunityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          findFirst: {
            args: Prisma.CommunityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          findMany: {
            args: Prisma.CommunityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>[]
          }
          create: {
            args: Prisma.CommunityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          createMany: {
            args: Prisma.CommunityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommunityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>[]
          }
          delete: {
            args: Prisma.CommunityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          update: {
            args: Prisma.CommunityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          deleteMany: {
            args: Prisma.CommunityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommunityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>[]
          }
          upsert: {
            args: Prisma.CommunityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPayload>
          }
          aggregate: {
            args: Prisma.CommunityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunity>
          }
          groupBy: {
            args: Prisma.CommunityGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunityGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityCountArgs<ExtArgs>
            result: $Utils.Optional<CommunityCountAggregateOutputType> | number
          }
        }
      }
      CommunityPost: {
        payload: Prisma.$CommunityPostPayload<ExtArgs>
        fields: Prisma.CommunityPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload>
          }
          findFirst: {
            args: Prisma.CommunityPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload>
          }
          findMany: {
            args: Prisma.CommunityPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload>[]
          }
          create: {
            args: Prisma.CommunityPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload>
          }
          createMany: {
            args: Prisma.CommunityPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommunityPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload>[]
          }
          delete: {
            args: Prisma.CommunityPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload>
          }
          update: {
            args: Prisma.CommunityPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload>
          }
          deleteMany: {
            args: Prisma.CommunityPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommunityPostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload>[]
          }
          upsert: {
            args: Prisma.CommunityPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityPostPayload>
          }
          aggregate: {
            args: Prisma.CommunityPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunityPost>
          }
          groupBy: {
            args: Prisma.CommunityPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunityPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityPostCountArgs<ExtArgs>
            result: $Utils.Optional<CommunityPostCountAggregateOutputType> | number
          }
        }
      }
      PostVote: {
        payload: Prisma.$PostVotePayload<ExtArgs>
        fields: Prisma.PostVoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostVoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostVoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVotePayload>
          }
          findFirst: {
            args: Prisma.PostVoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostVoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVotePayload>
          }
          findMany: {
            args: Prisma.PostVoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVotePayload>[]
          }
          create: {
            args: Prisma.PostVoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVotePayload>
          }
          createMany: {
            args: Prisma.PostVoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostVoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVotePayload>[]
          }
          delete: {
            args: Prisma.PostVoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVotePayload>
          }
          update: {
            args: Prisma.PostVoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVotePayload>
          }
          deleteMany: {
            args: Prisma.PostVoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostVoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostVoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVotePayload>[]
          }
          upsert: {
            args: Prisma.PostVoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostVotePayload>
          }
          aggregate: {
            args: Prisma.PostVoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostVote>
          }
          groupBy: {
            args: Prisma.PostVoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostVoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostVoteCountArgs<ExtArgs>
            result: $Utils.Optional<PostVoteCountAggregateOutputType> | number
          }
        }
      }
      CommunityMember: {
        payload: Prisma.$CommunityMemberPayload<ExtArgs>
        fields: Prisma.CommunityMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommunityMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommunityMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMemberPayload>
          }
          findFirst: {
            args: Prisma.CommunityMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommunityMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMemberPayload>
          }
          findMany: {
            args: Prisma.CommunityMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMemberPayload>[]
          }
          create: {
            args: Prisma.CommunityMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMemberPayload>
          }
          createMany: {
            args: Prisma.CommunityMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommunityMemberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMemberPayload>[]
          }
          delete: {
            args: Prisma.CommunityMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMemberPayload>
          }
          update: {
            args: Prisma.CommunityMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMemberPayload>
          }
          deleteMany: {
            args: Prisma.CommunityMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommunityMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommunityMemberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMemberPayload>[]
          }
          upsert: {
            args: Prisma.CommunityMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommunityMemberPayload>
          }
          aggregate: {
            args: Prisma.CommunityMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommunityMember>
          }
          groupBy: {
            args: Prisma.CommunityMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommunityMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommunityMemberCountArgs<ExtArgs>
            result: $Utils.Optional<CommunityMemberCountAggregateOutputType> | number
          }
        }
      }
      GovernanceProposal: {
        payload: Prisma.$GovernanceProposalPayload<ExtArgs>
        fields: Prisma.GovernanceProposalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GovernanceProposalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceProposalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GovernanceProposalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceProposalPayload>
          }
          findFirst: {
            args: Prisma.GovernanceProposalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceProposalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GovernanceProposalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceProposalPayload>
          }
          findMany: {
            args: Prisma.GovernanceProposalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceProposalPayload>[]
          }
          create: {
            args: Prisma.GovernanceProposalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceProposalPayload>
          }
          createMany: {
            args: Prisma.GovernanceProposalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GovernanceProposalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceProposalPayload>[]
          }
          delete: {
            args: Prisma.GovernanceProposalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceProposalPayload>
          }
          update: {
            args: Prisma.GovernanceProposalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceProposalPayload>
          }
          deleteMany: {
            args: Prisma.GovernanceProposalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GovernanceProposalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GovernanceProposalUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceProposalPayload>[]
          }
          upsert: {
            args: Prisma.GovernanceProposalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernanceProposalPayload>
          }
          aggregate: {
            args: Prisma.GovernanceProposalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGovernanceProposal>
          }
          groupBy: {
            args: Prisma.GovernanceProposalGroupByArgs<ExtArgs>
            result: $Utils.Optional<GovernanceProposalGroupByOutputType>[]
          }
          count: {
            args: Prisma.GovernanceProposalCountArgs<ExtArgs>
            result: $Utils.Optional<GovernanceProposalCountAggregateOutputType> | number
          }
        }
      }
      ProposalOption: {
        payload: Prisma.$ProposalOptionPayload<ExtArgs>
        fields: Prisma.ProposalOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProposalOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProposalOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalOptionPayload>
          }
          findFirst: {
            args: Prisma.ProposalOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProposalOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalOptionPayload>
          }
          findMany: {
            args: Prisma.ProposalOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalOptionPayload>[]
          }
          create: {
            args: Prisma.ProposalOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalOptionPayload>
          }
          createMany: {
            args: Prisma.ProposalOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProposalOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalOptionPayload>[]
          }
          delete: {
            args: Prisma.ProposalOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalOptionPayload>
          }
          update: {
            args: Prisma.ProposalOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalOptionPayload>
          }
          deleteMany: {
            args: Prisma.ProposalOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProposalOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProposalOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalOptionPayload>[]
          }
          upsert: {
            args: Prisma.ProposalOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProposalOptionPayload>
          }
          aggregate: {
            args: Prisma.ProposalOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProposalOption>
          }
          groupBy: {
            args: Prisma.ProposalOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProposalOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProposalOptionCountArgs<ExtArgs>
            result: $Utils.Optional<ProposalOptionCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      CommentVote: {
        payload: Prisma.$CommentVotePayload<ExtArgs>
        fields: Prisma.CommentVoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentVoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentVotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentVoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentVotePayload>
          }
          findFirst: {
            args: Prisma.CommentVoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentVotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentVoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentVotePayload>
          }
          findMany: {
            args: Prisma.CommentVoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentVotePayload>[]
          }
          create: {
            args: Prisma.CommentVoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentVotePayload>
          }
          createMany: {
            args: Prisma.CommentVoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentVoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentVotePayload>[]
          }
          delete: {
            args: Prisma.CommentVoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentVotePayload>
          }
          update: {
            args: Prisma.CommentVoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentVotePayload>
          }
          deleteMany: {
            args: Prisma.CommentVoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentVoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentVoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentVotePayload>[]
          }
          upsert: {
            args: Prisma.CommentVoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentVotePayload>
          }
          aggregate: {
            args: Prisma.CommentVoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommentVote>
          }
          groupBy: {
            args: Prisma.CommentVoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentVoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentVoteCountArgs<ExtArgs>
            result: $Utils.Optional<CommentVoteCountAggregateOutputType> | number
          }
        }
      }
      Quiz: {
        payload: Prisma.$QuizPayload<ExtArgs>
        fields: Prisma.QuizFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          findFirst: {
            args: Prisma.QuizFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          findMany: {
            args: Prisma.QuizFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          create: {
            args: Prisma.QuizCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          createMany: {
            args: Prisma.QuizCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          delete: {
            args: Prisma.QuizDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          update: {
            args: Prisma.QuizUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          deleteMany: {
            args: Prisma.QuizDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>[]
          }
          upsert: {
            args: Prisma.QuizUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizPayload>
          }
          aggregate: {
            args: Prisma.QuizAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuiz>
          }
          groupBy: {
            args: Prisma.QuizGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizCountArgs<ExtArgs>
            result: $Utils.Optional<QuizCountAggregateOutputType> | number
          }
        }
      }
      QuizQuestion: {
        payload: Prisma.$QuizQuestionPayload<ExtArgs>
        fields: Prisma.QuizQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          findFirst: {
            args: Prisma.QuizQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          findMany: {
            args: Prisma.QuizQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          create: {
            args: Prisma.QuizQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          createMany: {
            args: Prisma.QuizQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          delete: {
            args: Prisma.QuizQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          update: {
            args: Prisma.QuizQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuizQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>[]
          }
          upsert: {
            args: Prisma.QuizQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizQuestionPayload>
          }
          aggregate: {
            args: Prisma.QuizQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizQuestion>
          }
          groupBy: {
            args: Prisma.QuizQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuizQuestionCountAggregateOutputType> | number
          }
        }
      }
      QuizAttempt: {
        payload: Prisma.$QuizAttemptPayload<ExtArgs>
        fields: Prisma.QuizAttemptFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizAttemptFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizAttemptFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          findFirst: {
            args: Prisma.QuizAttemptFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizAttemptFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          findMany: {
            args: Prisma.QuizAttemptFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>[]
          }
          create: {
            args: Prisma.QuizAttemptCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          createMany: {
            args: Prisma.QuizAttemptCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizAttemptCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>[]
          }
          delete: {
            args: Prisma.QuizAttemptDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          update: {
            args: Prisma.QuizAttemptUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          deleteMany: {
            args: Prisma.QuizAttemptDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizAttemptUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizAttemptUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>[]
          }
          upsert: {
            args: Prisma.QuizAttemptUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizAttemptPayload>
          }
          aggregate: {
            args: Prisma.QuizAttemptAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizAttempt>
          }
          groupBy: {
            args: Prisma.QuizAttemptGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizAttemptGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizAttemptCountArgs<ExtArgs>
            result: $Utils.Optional<QuizAttemptCountAggregateOutputType> | number
          }
        }
      }
      QuizResponse: {
        payload: Prisma.$QuizResponsePayload<ExtArgs>
        fields: Prisma.QuizResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizResponseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizResponseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResponsePayload>
          }
          findFirst: {
            args: Prisma.QuizResponseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizResponseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResponsePayload>
          }
          findMany: {
            args: Prisma.QuizResponseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResponsePayload>[]
          }
          create: {
            args: Prisma.QuizResponseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResponsePayload>
          }
          createMany: {
            args: Prisma.QuizResponseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizResponseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResponsePayload>[]
          }
          delete: {
            args: Prisma.QuizResponseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResponsePayload>
          }
          update: {
            args: Prisma.QuizResponseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResponsePayload>
          }
          deleteMany: {
            args: Prisma.QuizResponseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizResponseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizResponseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResponsePayload>[]
          }
          upsert: {
            args: Prisma.QuizResponseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizResponsePayload>
          }
          aggregate: {
            args: Prisma.QuizResponseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizResponse>
          }
          groupBy: {
            args: Prisma.QuizResponseGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizResponseCountArgs<ExtArgs>
            result: $Utils.Optional<QuizResponseCountAggregateOutputType> | number
          }
        }
      }
      FanIQBadge: {
        payload: Prisma.$FanIQBadgePayload<ExtArgs>
        fields: Prisma.FanIQBadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FanIQBadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanIQBadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FanIQBadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanIQBadgePayload>
          }
          findFirst: {
            args: Prisma.FanIQBadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanIQBadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FanIQBadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanIQBadgePayload>
          }
          findMany: {
            args: Prisma.FanIQBadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanIQBadgePayload>[]
          }
          create: {
            args: Prisma.FanIQBadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanIQBadgePayload>
          }
          createMany: {
            args: Prisma.FanIQBadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FanIQBadgeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanIQBadgePayload>[]
          }
          delete: {
            args: Prisma.FanIQBadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanIQBadgePayload>
          }
          update: {
            args: Prisma.FanIQBadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanIQBadgePayload>
          }
          deleteMany: {
            args: Prisma.FanIQBadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FanIQBadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FanIQBadgeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanIQBadgePayload>[]
          }
          upsert: {
            args: Prisma.FanIQBadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FanIQBadgePayload>
          }
          aggregate: {
            args: Prisma.FanIQBadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFanIQBadge>
          }
          groupBy: {
            args: Prisma.FanIQBadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<FanIQBadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.FanIQBadgeCountArgs<ExtArgs>
            result: $Utils.Optional<FanIQBadgeCountAggregateOutputType> | number
          }
        }
      }
      QuizUserStats: {
        payload: Prisma.$QuizUserStatsPayload<ExtArgs>
        fields: Prisma.QuizUserStatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuizUserStatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizUserStatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuizUserStatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizUserStatsPayload>
          }
          findFirst: {
            args: Prisma.QuizUserStatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizUserStatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuizUserStatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizUserStatsPayload>
          }
          findMany: {
            args: Prisma.QuizUserStatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizUserStatsPayload>[]
          }
          create: {
            args: Prisma.QuizUserStatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizUserStatsPayload>
          }
          createMany: {
            args: Prisma.QuizUserStatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuizUserStatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizUserStatsPayload>[]
          }
          delete: {
            args: Prisma.QuizUserStatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizUserStatsPayload>
          }
          update: {
            args: Prisma.QuizUserStatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizUserStatsPayload>
          }
          deleteMany: {
            args: Prisma.QuizUserStatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuizUserStatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuizUserStatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizUserStatsPayload>[]
          }
          upsert: {
            args: Prisma.QuizUserStatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuizUserStatsPayload>
          }
          aggregate: {
            args: Prisma.QuizUserStatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuizUserStats>
          }
          groupBy: {
            args: Prisma.QuizUserStatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuizUserStatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuizUserStatsCountArgs<ExtArgs>
            result: $Utils.Optional<QuizUserStatsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    event?: EventOmit
    eventReminder?: EventReminderOmit
    ticketTier?: TicketTierOmit
    ticket?: TicketOmit
    community?: CommunityOmit
    communityPost?: CommunityPostOmit
    postVote?: PostVoteOmit
    communityMember?: CommunityMemberOmit
    governanceProposal?: GovernanceProposalOmit
    proposalOption?: ProposalOptionOmit
    comment?: CommentOmit
    commentVote?: CommentVoteOmit
    quiz?: QuizOmit
    quizQuestion?: QuizQuestionOmit
    quizAttempt?: QuizAttemptOmit
    quizResponse?: QuizResponseOmit
    fanIQBadge?: FanIQBadgeOmit
    quizUserStats?: QuizUserStatsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    tickets: number
    posts: number
    memberships: number
    postVotes: number
    comments: number
    commentVotes: number
    reminders: number
    quizAttempts: number
    fanIQBadges: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | UserCountOutputTypeCountTicketsArgs
    posts?: boolean | UserCountOutputTypeCountPostsArgs
    memberships?: boolean | UserCountOutputTypeCountMembershipsArgs
    postVotes?: boolean | UserCountOutputTypeCountPostVotesArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    commentVotes?: boolean | UserCountOutputTypeCountCommentVotesArgs
    reminders?: boolean | UserCountOutputTypeCountRemindersArgs
    quizAttempts?: boolean | UserCountOutputTypeCountQuizAttemptsArgs
    fanIQBadges?: boolean | UserCountOutputTypeCountFanIQBadgesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityPostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostVoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentVoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRemindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventReminderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountQuizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAttemptWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFanIQBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FanIQBadgeWhereInput
  }


  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    ticketTiers: number
    tickets: number
    reminders: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticketTiers?: boolean | EventCountOutputTypeCountTicketTiersArgs
    tickets?: boolean | EventCountOutputTypeCountTicketsArgs
    reminders?: boolean | EventCountOutputTypeCountRemindersArgs
  }

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountTicketTiersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketTierWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountRemindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventReminderWhereInput
  }


  /**
   * Count Type TicketTierCountOutputType
   */

  export type TicketTierCountOutputType = {
    tickets: number
  }

  export type TicketTierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | TicketTierCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * TicketTierCountOutputType without action
   */
  export type TicketTierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTierCountOutputType
     */
    select?: TicketTierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TicketTierCountOutputType without action
   */
  export type TicketTierCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }


  /**
   * Count Type CommunityCountOutputType
   */

  export type CommunityCountOutputType = {
    posts: number
    members: number
    proposals: number
  }

  export type CommunityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | CommunityCountOutputTypeCountPostsArgs
    members?: boolean | CommunityCountOutputTypeCountMembersArgs
    proposals?: boolean | CommunityCountOutputTypeCountProposalsArgs
  }

  // Custom InputTypes
  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityCountOutputType
     */
    select?: CommunityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityPostWhereInput
  }

  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityMemberWhereInput
  }

  /**
   * CommunityCountOutputType without action
   */
  export type CommunityCountOutputTypeCountProposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GovernanceProposalWhereInput
  }


  /**
   * Count Type CommunityPostCountOutputType
   */

  export type CommunityPostCountOutputType = {
    votes: number
    comments: number
  }

  export type CommunityPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    votes?: boolean | CommunityPostCountOutputTypeCountVotesArgs
    comments?: boolean | CommunityPostCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * CommunityPostCountOutputType without action
   */
  export type CommunityPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPostCountOutputType
     */
    select?: CommunityPostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommunityPostCountOutputType without action
   */
  export type CommunityPostCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostVoteWhereInput
  }

  /**
   * CommunityPostCountOutputType without action
   */
  export type CommunityPostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }


  /**
   * Count Type GovernanceProposalCountOutputType
   */

  export type GovernanceProposalCountOutputType = {
    options: number
  }

  export type GovernanceProposalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    options?: boolean | GovernanceProposalCountOutputTypeCountOptionsArgs
  }

  // Custom InputTypes
  /**
   * GovernanceProposalCountOutputType without action
   */
  export type GovernanceProposalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposalCountOutputType
     */
    select?: GovernanceProposalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GovernanceProposalCountOutputType without action
   */
  export type GovernanceProposalCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalOptionWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    children: number
    votes: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | CommentCountOutputTypeCountChildrenArgs
    votes?: boolean | CommentCountOutputTypeCountVotesArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentVoteWhereInput
  }


  /**
   * Count Type QuizCountOutputType
   */

  export type QuizCountOutputType = {
    questions: number
    attempts: number
  }

  export type QuizCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | QuizCountOutputTypeCountQuestionsArgs
    attempts?: boolean | QuizCountOutputTypeCountAttemptsArgs
  }

  // Custom InputTypes
  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizCountOutputType
     */
    select?: QuizCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionWhereInput
  }

  /**
   * QuizCountOutputType without action
   */
  export type QuizCountOutputTypeCountAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAttemptWhereInput
  }


  /**
   * Count Type QuizAttemptCountOutputType
   */

  export type QuizAttemptCountOutputType = {
    responses: number
  }

  export type QuizAttemptCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | QuizAttemptCountOutputTypeCountResponsesArgs
  }

  // Custom InputTypes
  /**
   * QuizAttemptCountOutputType without action
   */
  export type QuizAttemptCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttemptCountOutputType
     */
    select?: QuizAttemptCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuizAttemptCountOutputType without action
   */
  export type QuizAttemptCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizResponseWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    fandomScore: number | null
    eventsAttended: number | null
    vouchesGiven: number | null
    vouchesReceived: number | null
  }

  export type UserSumAggregateOutputType = {
    fandomScore: number | null
    eventsAttended: number | null
    vouchesGiven: number | null
    vouchesReceived: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    auth0Id: string | null
    email: string | null
    name: string | null
    avatar: string | null
    fandomScore: number | null
    walletAddress: string | null
    solanaWalletAddress: string | null
    spotifyConnected: boolean | null
    eventsAttended: number | null
    vouchesGiven: number | null
    vouchesReceived: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    auth0Id: string | null
    email: string | null
    name: string | null
    avatar: string | null
    fandomScore: number | null
    walletAddress: string | null
    solanaWalletAddress: string | null
    spotifyConnected: boolean | null
    eventsAttended: number | null
    vouchesGiven: number | null
    vouchesReceived: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    auth0Id: number
    email: number
    name: number
    avatar: number
    fandomScore: number
    walletAddress: number
    solanaWalletAddress: number
    spotifyConnected: number
    eventsAttended: number
    vouchesGiven: number
    vouchesReceived: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    fandomScore?: true
    eventsAttended?: true
    vouchesGiven?: true
    vouchesReceived?: true
  }

  export type UserSumAggregateInputType = {
    fandomScore?: true
    eventsAttended?: true
    vouchesGiven?: true
    vouchesReceived?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    auth0Id?: true
    email?: true
    name?: true
    avatar?: true
    fandomScore?: true
    walletAddress?: true
    solanaWalletAddress?: true
    spotifyConnected?: true
    eventsAttended?: true
    vouchesGiven?: true
    vouchesReceived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    auth0Id?: true
    email?: true
    name?: true
    avatar?: true
    fandomScore?: true
    walletAddress?: true
    solanaWalletAddress?: true
    spotifyConnected?: true
    eventsAttended?: true
    vouchesGiven?: true
    vouchesReceived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    auth0Id?: true
    email?: true
    name?: true
    avatar?: true
    fandomScore?: true
    walletAddress?: true
    solanaWalletAddress?: true
    spotifyConnected?: true
    eventsAttended?: true
    vouchesGiven?: true
    vouchesReceived?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    auth0Id: string
    email: string
    name: string
    avatar: string | null
    fandomScore: number
    walletAddress: string | null
    solanaWalletAddress: string | null
    spotifyConnected: boolean
    eventsAttended: number
    vouchesGiven: number
    vouchesReceived: number
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auth0Id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    fandomScore?: boolean
    walletAddress?: boolean
    solanaWalletAddress?: boolean
    spotifyConnected?: boolean
    eventsAttended?: boolean
    vouchesGiven?: boolean
    vouchesReceived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tickets?: boolean | User$ticketsArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    memberships?: boolean | User$membershipsArgs<ExtArgs>
    postVotes?: boolean | User$postVotesArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    commentVotes?: boolean | User$commentVotesArgs<ExtArgs>
    reminders?: boolean | User$remindersArgs<ExtArgs>
    quizAttempts?: boolean | User$quizAttemptsArgs<ExtArgs>
    fanIQBadges?: boolean | User$fanIQBadgesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auth0Id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    fandomScore?: boolean
    walletAddress?: boolean
    solanaWalletAddress?: boolean
    spotifyConnected?: boolean
    eventsAttended?: boolean
    vouchesGiven?: boolean
    vouchesReceived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    auth0Id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    fandomScore?: boolean
    walletAddress?: boolean
    solanaWalletAddress?: boolean
    spotifyConnected?: boolean
    eventsAttended?: boolean
    vouchesGiven?: boolean
    vouchesReceived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    auth0Id?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    fandomScore?: boolean
    walletAddress?: boolean
    solanaWalletAddress?: boolean
    spotifyConnected?: boolean
    eventsAttended?: boolean
    vouchesGiven?: boolean
    vouchesReceived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "auth0Id" | "email" | "name" | "avatar" | "fandomScore" | "walletAddress" | "solanaWalletAddress" | "spotifyConnected" | "eventsAttended" | "vouchesGiven" | "vouchesReceived" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | User$ticketsArgs<ExtArgs>
    posts?: boolean | User$postsArgs<ExtArgs>
    memberships?: boolean | User$membershipsArgs<ExtArgs>
    postVotes?: boolean | User$postVotesArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    commentVotes?: boolean | User$commentVotesArgs<ExtArgs>
    reminders?: boolean | User$remindersArgs<ExtArgs>
    quizAttempts?: boolean | User$quizAttemptsArgs<ExtArgs>
    fanIQBadges?: boolean | User$fanIQBadgesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      posts: Prisma.$CommunityPostPayload<ExtArgs>[]
      memberships: Prisma.$CommunityMemberPayload<ExtArgs>[]
      postVotes: Prisma.$PostVotePayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      commentVotes: Prisma.$CommentVotePayload<ExtArgs>[]
      reminders: Prisma.$EventReminderPayload<ExtArgs>[]
      quizAttempts: Prisma.$QuizAttemptPayload<ExtArgs>[]
      fanIQBadges: Prisma.$FanIQBadgePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      auth0Id: string
      email: string
      name: string
      avatar: string | null
      fandomScore: number
      walletAddress: string | null
      solanaWalletAddress: string | null
      spotifyConnected: boolean
      eventsAttended: number
      vouchesGiven: number
      vouchesReceived: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tickets<T extends User$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends User$postsArgs<ExtArgs> = {}>(args?: Subset<T, User$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    memberships<T extends User$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    postVotes<T extends User$postVotesArgs<ExtArgs> = {}>(args?: Subset<T, User$postVotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commentVotes<T extends User$commentVotesArgs<ExtArgs> = {}>(args?: Subset<T, User$commentVotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reminders<T extends User$remindersArgs<ExtArgs> = {}>(args?: Subset<T, User$remindersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventReminderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    quizAttempts<T extends User$quizAttemptsArgs<ExtArgs> = {}>(args?: Subset<T, User$quizAttemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fanIQBadges<T extends User$fanIQBadgesArgs<ExtArgs> = {}>(args?: Subset<T, User$fanIQBadgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FanIQBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly auth0Id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly fandomScore: FieldRef<"User", 'Int'>
    readonly walletAddress: FieldRef<"User", 'String'>
    readonly solanaWalletAddress: FieldRef<"User", 'String'>
    readonly spotifyConnected: FieldRef<"User", 'Boolean'>
    readonly eventsAttended: FieldRef<"User", 'Int'>
    readonly vouchesGiven: FieldRef<"User", 'Int'>
    readonly vouchesReceived: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.tickets
   */
  export type User$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * User.posts
   */
  export type User$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityPost
     */
    omit?: CommunityPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityPostInclude<ExtArgs> | null
    where?: CommunityPostWhereInput
    orderBy?: CommunityPostOrderByWithRelationInput | CommunityPostOrderByWithRelationInput[]
    cursor?: CommunityPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityPostScalarFieldEnum | CommunityPostScalarFieldEnum[]
  }

  /**
   * User.memberships
   */
  export type User$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberInclude<ExtArgs> | null
    where?: CommunityMemberWhereInput
    orderBy?: CommunityMemberOrderByWithRelationInput | CommunityMemberOrderByWithRelationInput[]
    cursor?: CommunityMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityMemberScalarFieldEnum | CommunityMemberScalarFieldEnum[]
  }

  /**
   * User.postVotes
   */
  export type User$postVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVote
     */
    select?: PostVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVote
     */
    omit?: PostVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVoteInclude<ExtArgs> | null
    where?: PostVoteWhereInput
    orderBy?: PostVoteOrderByWithRelationInput | PostVoteOrderByWithRelationInput[]
    cursor?: PostVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostVoteScalarFieldEnum | PostVoteScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.commentVotes
   */
  export type User$commentVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentVote
     */
    select?: CommentVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentVote
     */
    omit?: CommentVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentVoteInclude<ExtArgs> | null
    where?: CommentVoteWhereInput
    orderBy?: CommentVoteOrderByWithRelationInput | CommentVoteOrderByWithRelationInput[]
    cursor?: CommentVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentVoteScalarFieldEnum | CommentVoteScalarFieldEnum[]
  }

  /**
   * User.reminders
   */
  export type User$remindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventReminder
     */
    select?: EventReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventReminder
     */
    omit?: EventReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventReminderInclude<ExtArgs> | null
    where?: EventReminderWhereInput
    orderBy?: EventReminderOrderByWithRelationInput | EventReminderOrderByWithRelationInput[]
    cursor?: EventReminderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventReminderScalarFieldEnum | EventReminderScalarFieldEnum[]
  }

  /**
   * User.quizAttempts
   */
  export type User$quizAttemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    where?: QuizAttemptWhereInput
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    cursor?: QuizAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * User.fanIQBadges
   */
  export type User$fanIQBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FanIQBadge
     */
    select?: FanIQBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FanIQBadge
     */
    omit?: FanIQBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanIQBadgeInclude<ExtArgs> | null
    where?: FanIQBadgeWhereInput
    orderBy?: FanIQBadgeOrderByWithRelationInput | FanIQBadgeOrderByWithRelationInput[]
    cursor?: FanIQBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FanIQBadgeScalarFieldEnum | FanIQBadgeScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventAvgAggregateOutputType = {
    totalTickets: number | null
    soldTickets: number | null
    resaleCap: number | null
    artistRoyalty: number | null
    minFandomScore: number | null
  }

  export type EventSumAggregateOutputType = {
    totalTickets: number | null
    soldTickets: number | null
    resaleCap: number | null
    artistRoyalty: number | null
    minFandomScore: number | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    title: string | null
    artist: string | null
    artistImage: string | null
    venue: string | null
    location: string | null
    date: Date | null
    time: string | null
    image: string | null
    description: string | null
    category: string | null
    status: string | null
    totalTickets: number | null
    soldTickets: number | null
    resaleEnabled: boolean | null
    resaleCap: number | null
    artistRoyalty: number | null
    minFandomScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    title: string | null
    artist: string | null
    artistImage: string | null
    venue: string | null
    location: string | null
    date: Date | null
    time: string | null
    image: string | null
    description: string | null
    category: string | null
    status: string | null
    totalTickets: number | null
    soldTickets: number | null
    resaleEnabled: boolean | null
    resaleCap: number | null
    artistRoyalty: number | null
    minFandomScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    title: number
    artist: number
    artistImage: number
    venue: number
    location: number
    date: number
    time: number
    image: number
    description: number
    category: number
    status: number
    totalTickets: number
    soldTickets: number
    resaleEnabled: number
    resaleCap: number
    artistRoyalty: number
    minFandomScore: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventAvgAggregateInputType = {
    totalTickets?: true
    soldTickets?: true
    resaleCap?: true
    artistRoyalty?: true
    minFandomScore?: true
  }

  export type EventSumAggregateInputType = {
    totalTickets?: true
    soldTickets?: true
    resaleCap?: true
    artistRoyalty?: true
    minFandomScore?: true
  }

  export type EventMinAggregateInputType = {
    id?: true
    title?: true
    artist?: true
    artistImage?: true
    venue?: true
    location?: true
    date?: true
    time?: true
    image?: true
    description?: true
    category?: true
    status?: true
    totalTickets?: true
    soldTickets?: true
    resaleEnabled?: true
    resaleCap?: true
    artistRoyalty?: true
    minFandomScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    title?: true
    artist?: true
    artistImage?: true
    venue?: true
    location?: true
    date?: true
    time?: true
    image?: true
    description?: true
    category?: true
    status?: true
    totalTickets?: true
    soldTickets?: true
    resaleEnabled?: true
    resaleCap?: true
    artistRoyalty?: true
    minFandomScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    title?: true
    artist?: true
    artistImage?: true
    venue?: true
    location?: true
    date?: true
    time?: true
    image?: true
    description?: true
    category?: true
    status?: true
    totalTickets?: true
    soldTickets?: true
    resaleEnabled?: true
    resaleCap?: true
    artistRoyalty?: true
    minFandomScore?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _avg?: EventAvgAggregateInputType
    _sum?: EventSumAggregateInputType
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    title: string
    artist: string
    artistImage: string
    venue: string
    location: string
    date: Date
    time: string
    image: string
    description: string
    category: string
    status: string
    totalTickets: number
    soldTickets: number
    resaleEnabled: boolean
    resaleCap: number | null
    artistRoyalty: number
    minFandomScore: number | null
    createdAt: Date
    updatedAt: Date
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    artist?: boolean
    artistImage?: boolean
    venue?: boolean
    location?: boolean
    date?: boolean
    time?: boolean
    image?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    totalTickets?: boolean
    soldTickets?: boolean
    resaleEnabled?: boolean
    resaleCap?: boolean
    artistRoyalty?: boolean
    minFandomScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ticketTiers?: boolean | Event$ticketTiersArgs<ExtArgs>
    tickets?: boolean | Event$ticketsArgs<ExtArgs>
    reminders?: boolean | Event$remindersArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    artist?: boolean
    artistImage?: boolean
    venue?: boolean
    location?: boolean
    date?: boolean
    time?: boolean
    image?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    totalTickets?: boolean
    soldTickets?: boolean
    resaleEnabled?: boolean
    resaleCap?: boolean
    artistRoyalty?: boolean
    minFandomScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["event"]>

  export type EventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    artist?: boolean
    artistImage?: boolean
    venue?: boolean
    location?: boolean
    date?: boolean
    time?: boolean
    image?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    totalTickets?: boolean
    soldTickets?: boolean
    resaleEnabled?: boolean
    resaleCap?: boolean
    artistRoyalty?: boolean
    minFandomScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    title?: boolean
    artist?: boolean
    artistImage?: boolean
    venue?: boolean
    location?: boolean
    date?: boolean
    time?: boolean
    image?: boolean
    description?: boolean
    category?: boolean
    status?: boolean
    totalTickets?: boolean
    soldTickets?: boolean
    resaleEnabled?: boolean
    resaleCap?: boolean
    artistRoyalty?: boolean
    minFandomScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "artist" | "artistImage" | "venue" | "location" | "date" | "time" | "image" | "description" | "category" | "status" | "totalTickets" | "soldTickets" | "resaleEnabled" | "resaleCap" | "artistRoyalty" | "minFandomScore" | "createdAt" | "updatedAt", ExtArgs["result"]["event"]>
  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticketTiers?: boolean | Event$ticketTiersArgs<ExtArgs>
    tickets?: boolean | Event$ticketsArgs<ExtArgs>
    reminders?: boolean | Event$remindersArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      ticketTiers: Prisma.$TicketTierPayload<ExtArgs>[]
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      reminders: Prisma.$EventReminderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      artist: string
      artistImage: string
      venue: string
      location: string
      date: Date
      time: string
      image: string
      description: string
      category: string
      status: string
      totalTickets: number
      soldTickets: number
      resaleEnabled: boolean
      resaleCap: number | null
      artistRoyalty: number
      minFandomScore: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {EventUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventUpdateManyAndReturnArgs>(args: SelectSubset<T, EventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticketTiers<T extends Event$ticketTiersArgs<ExtArgs> = {}>(args?: Subset<T, Event$ticketTiersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketTierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tickets<T extends Event$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Event$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reminders<T extends Event$remindersArgs<ExtArgs> = {}>(args?: Subset<T, Event$remindersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventReminderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly title: FieldRef<"Event", 'String'>
    readonly artist: FieldRef<"Event", 'String'>
    readonly artistImage: FieldRef<"Event", 'String'>
    readonly venue: FieldRef<"Event", 'String'>
    readonly location: FieldRef<"Event", 'String'>
    readonly date: FieldRef<"Event", 'DateTime'>
    readonly time: FieldRef<"Event", 'String'>
    readonly image: FieldRef<"Event", 'String'>
    readonly description: FieldRef<"Event", 'String'>
    readonly category: FieldRef<"Event", 'String'>
    readonly status: FieldRef<"Event", 'String'>
    readonly totalTickets: FieldRef<"Event", 'Int'>
    readonly soldTickets: FieldRef<"Event", 'Int'>
    readonly resaleEnabled: FieldRef<"Event", 'Boolean'>
    readonly resaleCap: FieldRef<"Event", 'Int'>
    readonly artistRoyalty: FieldRef<"Event", 'Int'>
    readonly minFandomScore: FieldRef<"Event", 'Int'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
    readonly updatedAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event updateManyAndReturn
   */
  export type EventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Event.ticketTiers
   */
  export type Event$ticketTiersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTier
     */
    select?: TicketTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTier
     */
    omit?: TicketTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTierInclude<ExtArgs> | null
    where?: TicketTierWhereInput
    orderBy?: TicketTierOrderByWithRelationInput | TicketTierOrderByWithRelationInput[]
    cursor?: TicketTierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketTierScalarFieldEnum | TicketTierScalarFieldEnum[]
  }

  /**
   * Event.tickets
   */
  export type Event$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Event.reminders
   */
  export type Event$remindersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventReminder
     */
    select?: EventReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventReminder
     */
    omit?: EventReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventReminderInclude<ExtArgs> | null
    where?: EventReminderWhereInput
    orderBy?: EventReminderOrderByWithRelationInput | EventReminderOrderByWithRelationInput[]
    cursor?: EventReminderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventReminderScalarFieldEnum | EventReminderScalarFieldEnum[]
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model EventReminder
   */

  export type AggregateEventReminder = {
    _count: EventReminderCountAggregateOutputType | null
    _min: EventReminderMinAggregateOutputType | null
    _max: EventReminderMaxAggregateOutputType | null
  }

  export type EventReminderMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type EventReminderMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type EventReminderCountAggregateOutputType = {
    id: number
    eventId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type EventReminderMinAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    createdAt?: true
  }

  export type EventReminderMaxAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    createdAt?: true
  }

  export type EventReminderCountAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type EventReminderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventReminder to aggregate.
     */
    where?: EventReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventReminders to fetch.
     */
    orderBy?: EventReminderOrderByWithRelationInput | EventReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventReminders
    **/
    _count?: true | EventReminderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventReminderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventReminderMaxAggregateInputType
  }

  export type GetEventReminderAggregateType<T extends EventReminderAggregateArgs> = {
        [P in keyof T & keyof AggregateEventReminder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventReminder[P]>
      : GetScalarType<T[P], AggregateEventReminder[P]>
  }




  export type EventReminderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventReminderWhereInput
    orderBy?: EventReminderOrderByWithAggregationInput | EventReminderOrderByWithAggregationInput[]
    by: EventReminderScalarFieldEnum[] | EventReminderScalarFieldEnum
    having?: EventReminderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventReminderCountAggregateInputType | true
    _min?: EventReminderMinAggregateInputType
    _max?: EventReminderMaxAggregateInputType
  }

  export type EventReminderGroupByOutputType = {
    id: string
    eventId: string
    userId: string
    createdAt: Date
    _count: EventReminderCountAggregateOutputType | null
    _min: EventReminderMinAggregateOutputType | null
    _max: EventReminderMaxAggregateOutputType | null
  }

  type GetEventReminderGroupByPayload<T extends EventReminderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventReminderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventReminderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventReminderGroupByOutputType[P]>
            : GetScalarType<T[P], EventReminderGroupByOutputType[P]>
        }
      >
    >


  export type EventReminderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    createdAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventReminder"]>

  export type EventReminderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    createdAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventReminder"]>

  export type EventReminderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    createdAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventReminder"]>

  export type EventReminderSelectScalar = {
    id?: boolean
    eventId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type EventReminderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "userId" | "createdAt", ExtArgs["result"]["eventReminder"]>
  export type EventReminderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EventReminderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EventReminderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EventReminderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventReminder"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["eventReminder"]>
    composites: {}
  }

  type EventReminderGetPayload<S extends boolean | null | undefined | EventReminderDefaultArgs> = $Result.GetResult<Prisma.$EventReminderPayload, S>

  type EventReminderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventReminderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventReminderCountAggregateInputType | true
    }

  export interface EventReminderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventReminder'], meta: { name: 'EventReminder' } }
    /**
     * Find zero or one EventReminder that matches the filter.
     * @param {EventReminderFindUniqueArgs} args - Arguments to find a EventReminder
     * @example
     * // Get one EventReminder
     * const eventReminder = await prisma.eventReminder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventReminderFindUniqueArgs>(args: SelectSubset<T, EventReminderFindUniqueArgs<ExtArgs>>): Prisma__EventReminderClient<$Result.GetResult<Prisma.$EventReminderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EventReminder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventReminderFindUniqueOrThrowArgs} args - Arguments to find a EventReminder
     * @example
     * // Get one EventReminder
     * const eventReminder = await prisma.eventReminder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventReminderFindUniqueOrThrowArgs>(args: SelectSubset<T, EventReminderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventReminderClient<$Result.GetResult<Prisma.$EventReminderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventReminder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventReminderFindFirstArgs} args - Arguments to find a EventReminder
     * @example
     * // Get one EventReminder
     * const eventReminder = await prisma.eventReminder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventReminderFindFirstArgs>(args?: SelectSubset<T, EventReminderFindFirstArgs<ExtArgs>>): Prisma__EventReminderClient<$Result.GetResult<Prisma.$EventReminderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventReminder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventReminderFindFirstOrThrowArgs} args - Arguments to find a EventReminder
     * @example
     * // Get one EventReminder
     * const eventReminder = await prisma.eventReminder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventReminderFindFirstOrThrowArgs>(args?: SelectSubset<T, EventReminderFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventReminderClient<$Result.GetResult<Prisma.$EventReminderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EventReminders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventReminderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventReminders
     * const eventReminders = await prisma.eventReminder.findMany()
     * 
     * // Get first 10 EventReminders
     * const eventReminders = await prisma.eventReminder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventReminderWithIdOnly = await prisma.eventReminder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventReminderFindManyArgs>(args?: SelectSubset<T, EventReminderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventReminderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EventReminder.
     * @param {EventReminderCreateArgs} args - Arguments to create a EventReminder.
     * @example
     * // Create one EventReminder
     * const EventReminder = await prisma.eventReminder.create({
     *   data: {
     *     // ... data to create a EventReminder
     *   }
     * })
     * 
     */
    create<T extends EventReminderCreateArgs>(args: SelectSubset<T, EventReminderCreateArgs<ExtArgs>>): Prisma__EventReminderClient<$Result.GetResult<Prisma.$EventReminderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EventReminders.
     * @param {EventReminderCreateManyArgs} args - Arguments to create many EventReminders.
     * @example
     * // Create many EventReminders
     * const eventReminder = await prisma.eventReminder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventReminderCreateManyArgs>(args?: SelectSubset<T, EventReminderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventReminders and returns the data saved in the database.
     * @param {EventReminderCreateManyAndReturnArgs} args - Arguments to create many EventReminders.
     * @example
     * // Create many EventReminders
     * const eventReminder = await prisma.eventReminder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventReminders and only return the `id`
     * const eventReminderWithIdOnly = await prisma.eventReminder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventReminderCreateManyAndReturnArgs>(args?: SelectSubset<T, EventReminderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventReminderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EventReminder.
     * @param {EventReminderDeleteArgs} args - Arguments to delete one EventReminder.
     * @example
     * // Delete one EventReminder
     * const EventReminder = await prisma.eventReminder.delete({
     *   where: {
     *     // ... filter to delete one EventReminder
     *   }
     * })
     * 
     */
    delete<T extends EventReminderDeleteArgs>(args: SelectSubset<T, EventReminderDeleteArgs<ExtArgs>>): Prisma__EventReminderClient<$Result.GetResult<Prisma.$EventReminderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EventReminder.
     * @param {EventReminderUpdateArgs} args - Arguments to update one EventReminder.
     * @example
     * // Update one EventReminder
     * const eventReminder = await prisma.eventReminder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventReminderUpdateArgs>(args: SelectSubset<T, EventReminderUpdateArgs<ExtArgs>>): Prisma__EventReminderClient<$Result.GetResult<Prisma.$EventReminderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EventReminders.
     * @param {EventReminderDeleteManyArgs} args - Arguments to filter EventReminders to delete.
     * @example
     * // Delete a few EventReminders
     * const { count } = await prisma.eventReminder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventReminderDeleteManyArgs>(args?: SelectSubset<T, EventReminderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventReminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventReminderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventReminders
     * const eventReminder = await prisma.eventReminder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventReminderUpdateManyArgs>(args: SelectSubset<T, EventReminderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventReminders and returns the data updated in the database.
     * @param {EventReminderUpdateManyAndReturnArgs} args - Arguments to update many EventReminders.
     * @example
     * // Update many EventReminders
     * const eventReminder = await prisma.eventReminder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EventReminders and only return the `id`
     * const eventReminderWithIdOnly = await prisma.eventReminder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventReminderUpdateManyAndReturnArgs>(args: SelectSubset<T, EventReminderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventReminderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EventReminder.
     * @param {EventReminderUpsertArgs} args - Arguments to update or create a EventReminder.
     * @example
     * // Update or create a EventReminder
     * const eventReminder = await prisma.eventReminder.upsert({
     *   create: {
     *     // ... data to create a EventReminder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventReminder we want to update
     *   }
     * })
     */
    upsert<T extends EventReminderUpsertArgs>(args: SelectSubset<T, EventReminderUpsertArgs<ExtArgs>>): Prisma__EventReminderClient<$Result.GetResult<Prisma.$EventReminderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EventReminders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventReminderCountArgs} args - Arguments to filter EventReminders to count.
     * @example
     * // Count the number of EventReminders
     * const count = await prisma.eventReminder.count({
     *   where: {
     *     // ... the filter for the EventReminders we want to count
     *   }
     * })
    **/
    count<T extends EventReminderCountArgs>(
      args?: Subset<T, EventReminderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventReminderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventReminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventReminderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventReminderAggregateArgs>(args: Subset<T, EventReminderAggregateArgs>): Prisma.PrismaPromise<GetEventReminderAggregateType<T>>

    /**
     * Group by EventReminder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventReminderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventReminderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventReminderGroupByArgs['orderBy'] }
        : { orderBy?: EventReminderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventReminderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventReminderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventReminder model
   */
  readonly fields: EventReminderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventReminder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventReminderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventReminder model
   */
  interface EventReminderFieldRefs {
    readonly id: FieldRef<"EventReminder", 'String'>
    readonly eventId: FieldRef<"EventReminder", 'String'>
    readonly userId: FieldRef<"EventReminder", 'String'>
    readonly createdAt: FieldRef<"EventReminder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventReminder findUnique
   */
  export type EventReminderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventReminder
     */
    select?: EventReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventReminder
     */
    omit?: EventReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventReminderInclude<ExtArgs> | null
    /**
     * Filter, which EventReminder to fetch.
     */
    where: EventReminderWhereUniqueInput
  }

  /**
   * EventReminder findUniqueOrThrow
   */
  export type EventReminderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventReminder
     */
    select?: EventReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventReminder
     */
    omit?: EventReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventReminderInclude<ExtArgs> | null
    /**
     * Filter, which EventReminder to fetch.
     */
    where: EventReminderWhereUniqueInput
  }

  /**
   * EventReminder findFirst
   */
  export type EventReminderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventReminder
     */
    select?: EventReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventReminder
     */
    omit?: EventReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventReminderInclude<ExtArgs> | null
    /**
     * Filter, which EventReminder to fetch.
     */
    where?: EventReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventReminders to fetch.
     */
    orderBy?: EventReminderOrderByWithRelationInput | EventReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventReminders.
     */
    cursor?: EventReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventReminders.
     */
    distinct?: EventReminderScalarFieldEnum | EventReminderScalarFieldEnum[]
  }

  /**
   * EventReminder findFirstOrThrow
   */
  export type EventReminderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventReminder
     */
    select?: EventReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventReminder
     */
    omit?: EventReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventReminderInclude<ExtArgs> | null
    /**
     * Filter, which EventReminder to fetch.
     */
    where?: EventReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventReminders to fetch.
     */
    orderBy?: EventReminderOrderByWithRelationInput | EventReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventReminders.
     */
    cursor?: EventReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventReminders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventReminders.
     */
    distinct?: EventReminderScalarFieldEnum | EventReminderScalarFieldEnum[]
  }

  /**
   * EventReminder findMany
   */
  export type EventReminderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventReminder
     */
    select?: EventReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventReminder
     */
    omit?: EventReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventReminderInclude<ExtArgs> | null
    /**
     * Filter, which EventReminders to fetch.
     */
    where?: EventReminderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventReminders to fetch.
     */
    orderBy?: EventReminderOrderByWithRelationInput | EventReminderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventReminders.
     */
    cursor?: EventReminderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventReminders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventReminders.
     */
    skip?: number
    distinct?: EventReminderScalarFieldEnum | EventReminderScalarFieldEnum[]
  }

  /**
   * EventReminder create
   */
  export type EventReminderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventReminder
     */
    select?: EventReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventReminder
     */
    omit?: EventReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventReminderInclude<ExtArgs> | null
    /**
     * The data needed to create a EventReminder.
     */
    data: XOR<EventReminderCreateInput, EventReminderUncheckedCreateInput>
  }

  /**
   * EventReminder createMany
   */
  export type EventReminderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventReminders.
     */
    data: EventReminderCreateManyInput | EventReminderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventReminder createManyAndReturn
   */
  export type EventReminderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventReminder
     */
    select?: EventReminderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventReminder
     */
    omit?: EventReminderOmit<ExtArgs> | null
    /**
     * The data used to create many EventReminders.
     */
    data: EventReminderCreateManyInput | EventReminderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventReminderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventReminder update
   */
  export type EventReminderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventReminder
     */
    select?: EventReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventReminder
     */
    omit?: EventReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventReminderInclude<ExtArgs> | null
    /**
     * The data needed to update a EventReminder.
     */
    data: XOR<EventReminderUpdateInput, EventReminderUncheckedUpdateInput>
    /**
     * Choose, which EventReminder to update.
     */
    where: EventReminderWhereUniqueInput
  }

  /**
   * EventReminder updateMany
   */
  export type EventReminderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventReminders.
     */
    data: XOR<EventReminderUpdateManyMutationInput, EventReminderUncheckedUpdateManyInput>
    /**
     * Filter which EventReminders to update
     */
    where?: EventReminderWhereInput
    /**
     * Limit how many EventReminders to update.
     */
    limit?: number
  }

  /**
   * EventReminder updateManyAndReturn
   */
  export type EventReminderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventReminder
     */
    select?: EventReminderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventReminder
     */
    omit?: EventReminderOmit<ExtArgs> | null
    /**
     * The data used to update EventReminders.
     */
    data: XOR<EventReminderUpdateManyMutationInput, EventReminderUncheckedUpdateManyInput>
    /**
     * Filter which EventReminders to update
     */
    where?: EventReminderWhereInput
    /**
     * Limit how many EventReminders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventReminderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventReminder upsert
   */
  export type EventReminderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventReminder
     */
    select?: EventReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventReminder
     */
    omit?: EventReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventReminderInclude<ExtArgs> | null
    /**
     * The filter to search for the EventReminder to update in case it exists.
     */
    where: EventReminderWhereUniqueInput
    /**
     * In case the EventReminder found by the `where` argument doesn't exist, create a new EventReminder with this data.
     */
    create: XOR<EventReminderCreateInput, EventReminderUncheckedCreateInput>
    /**
     * In case the EventReminder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventReminderUpdateInput, EventReminderUncheckedUpdateInput>
  }

  /**
   * EventReminder delete
   */
  export type EventReminderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventReminder
     */
    select?: EventReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventReminder
     */
    omit?: EventReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventReminderInclude<ExtArgs> | null
    /**
     * Filter which EventReminder to delete.
     */
    where: EventReminderWhereUniqueInput
  }

  /**
   * EventReminder deleteMany
   */
  export type EventReminderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventReminders to delete
     */
    where?: EventReminderWhereInput
    /**
     * Limit how many EventReminders to delete.
     */
    limit?: number
  }

  /**
   * EventReminder without action
   */
  export type EventReminderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventReminder
     */
    select?: EventReminderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventReminder
     */
    omit?: EventReminderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventReminderInclude<ExtArgs> | null
  }


  /**
   * Model TicketTier
   */

  export type AggregateTicketTier = {
    _count: TicketTierCountAggregateOutputType | null
    _avg: TicketTierAvgAggregateOutputType | null
    _sum: TicketTierSumAggregateOutputType | null
    _min: TicketTierMinAggregateOutputType | null
    _max: TicketTierMaxAggregateOutputType | null
  }

  export type TicketTierAvgAggregateOutputType = {
    price: number | null
    available: number | null
    total: number | null
  }

  export type TicketTierSumAggregateOutputType = {
    price: number | null
    available: number | null
    total: number | null
  }

  export type TicketTierMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    name: string | null
    price: number | null
    currency: string | null
    description: string | null
    available: number | null
    total: number | null
  }

  export type TicketTierMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    name: string | null
    price: number | null
    currency: string | null
    description: string | null
    available: number | null
    total: number | null
  }

  export type TicketTierCountAggregateOutputType = {
    id: number
    eventId: number
    name: number
    price: number
    currency: number
    description: number
    available: number
    total: number
    benefits: number
    _all: number
  }


  export type TicketTierAvgAggregateInputType = {
    price?: true
    available?: true
    total?: true
  }

  export type TicketTierSumAggregateInputType = {
    price?: true
    available?: true
    total?: true
  }

  export type TicketTierMinAggregateInputType = {
    id?: true
    eventId?: true
    name?: true
    price?: true
    currency?: true
    description?: true
    available?: true
    total?: true
  }

  export type TicketTierMaxAggregateInputType = {
    id?: true
    eventId?: true
    name?: true
    price?: true
    currency?: true
    description?: true
    available?: true
    total?: true
  }

  export type TicketTierCountAggregateInputType = {
    id?: true
    eventId?: true
    name?: true
    price?: true
    currency?: true
    description?: true
    available?: true
    total?: true
    benefits?: true
    _all?: true
  }

  export type TicketTierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketTier to aggregate.
     */
    where?: TicketTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketTiers to fetch.
     */
    orderBy?: TicketTierOrderByWithRelationInput | TicketTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketTiers
    **/
    _count?: true | TicketTierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketTierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketTierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketTierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketTierMaxAggregateInputType
  }

  export type GetTicketTierAggregateType<T extends TicketTierAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketTier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketTier[P]>
      : GetScalarType<T[P], AggregateTicketTier[P]>
  }




  export type TicketTierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketTierWhereInput
    orderBy?: TicketTierOrderByWithAggregationInput | TicketTierOrderByWithAggregationInput[]
    by: TicketTierScalarFieldEnum[] | TicketTierScalarFieldEnum
    having?: TicketTierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketTierCountAggregateInputType | true
    _avg?: TicketTierAvgAggregateInputType
    _sum?: TicketTierSumAggregateInputType
    _min?: TicketTierMinAggregateInputType
    _max?: TicketTierMaxAggregateInputType
  }

  export type TicketTierGroupByOutputType = {
    id: string
    eventId: string
    name: string
    price: number
    currency: string
    description: string
    available: number
    total: number
    benefits: string[]
    _count: TicketTierCountAggregateOutputType | null
    _avg: TicketTierAvgAggregateOutputType | null
    _sum: TicketTierSumAggregateOutputType | null
    _min: TicketTierMinAggregateOutputType | null
    _max: TicketTierMaxAggregateOutputType | null
  }

  type GetTicketTierGroupByPayload<T extends TicketTierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketTierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketTierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketTierGroupByOutputType[P]>
            : GetScalarType<T[P], TicketTierGroupByOutputType[P]>
        }
      >
    >


  export type TicketTierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    name?: boolean
    price?: boolean
    currency?: boolean
    description?: boolean
    available?: boolean
    total?: boolean
    benefits?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    tickets?: boolean | TicketTier$ticketsArgs<ExtArgs>
    _count?: boolean | TicketTierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketTier"]>

  export type TicketTierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    name?: boolean
    price?: boolean
    currency?: boolean
    description?: boolean
    available?: boolean
    total?: boolean
    benefits?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketTier"]>

  export type TicketTierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    name?: boolean
    price?: boolean
    currency?: boolean
    description?: boolean
    available?: boolean
    total?: boolean
    benefits?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticketTier"]>

  export type TicketTierSelectScalar = {
    id?: boolean
    eventId?: boolean
    name?: boolean
    price?: boolean
    currency?: boolean
    description?: boolean
    available?: boolean
    total?: boolean
    benefits?: boolean
  }

  export type TicketTierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "name" | "price" | "currency" | "description" | "available" | "total" | "benefits", ExtArgs["result"]["ticketTier"]>
  export type TicketTierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    tickets?: boolean | TicketTier$ticketsArgs<ExtArgs>
    _count?: boolean | TicketTierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TicketTierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }
  export type TicketTierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
  }

  export type $TicketTierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketTier"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
      tickets: Prisma.$TicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      name: string
      price: number
      currency: string
      description: string
      available: number
      total: number
      benefits: string[]
    }, ExtArgs["result"]["ticketTier"]>
    composites: {}
  }

  type TicketTierGetPayload<S extends boolean | null | undefined | TicketTierDefaultArgs> = $Result.GetResult<Prisma.$TicketTierPayload, S>

  type TicketTierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketTierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketTierCountAggregateInputType | true
    }

  export interface TicketTierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketTier'], meta: { name: 'TicketTier' } }
    /**
     * Find zero or one TicketTier that matches the filter.
     * @param {TicketTierFindUniqueArgs} args - Arguments to find a TicketTier
     * @example
     * // Get one TicketTier
     * const ticketTier = await prisma.ticketTier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketTierFindUniqueArgs>(args: SelectSubset<T, TicketTierFindUniqueArgs<ExtArgs>>): Prisma__TicketTierClient<$Result.GetResult<Prisma.$TicketTierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TicketTier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketTierFindUniqueOrThrowArgs} args - Arguments to find a TicketTier
     * @example
     * // Get one TicketTier
     * const ticketTier = await prisma.ticketTier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketTierFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketTierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketTierClient<$Result.GetResult<Prisma.$TicketTierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketTier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTierFindFirstArgs} args - Arguments to find a TicketTier
     * @example
     * // Get one TicketTier
     * const ticketTier = await prisma.ticketTier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketTierFindFirstArgs>(args?: SelectSubset<T, TicketTierFindFirstArgs<ExtArgs>>): Prisma__TicketTierClient<$Result.GetResult<Prisma.$TicketTierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketTier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTierFindFirstOrThrowArgs} args - Arguments to find a TicketTier
     * @example
     * // Get one TicketTier
     * const ticketTier = await prisma.ticketTier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketTierFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketTierFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketTierClient<$Result.GetResult<Prisma.$TicketTierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketTiers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketTiers
     * const ticketTiers = await prisma.ticketTier.findMany()
     * 
     * // Get first 10 TicketTiers
     * const ticketTiers = await prisma.ticketTier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketTierWithIdOnly = await prisma.ticketTier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketTierFindManyArgs>(args?: SelectSubset<T, TicketTierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketTierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TicketTier.
     * @param {TicketTierCreateArgs} args - Arguments to create a TicketTier.
     * @example
     * // Create one TicketTier
     * const TicketTier = await prisma.ticketTier.create({
     *   data: {
     *     // ... data to create a TicketTier
     *   }
     * })
     * 
     */
    create<T extends TicketTierCreateArgs>(args: SelectSubset<T, TicketTierCreateArgs<ExtArgs>>): Prisma__TicketTierClient<$Result.GetResult<Prisma.$TicketTierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TicketTiers.
     * @param {TicketTierCreateManyArgs} args - Arguments to create many TicketTiers.
     * @example
     * // Create many TicketTiers
     * const ticketTier = await prisma.ticketTier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketTierCreateManyArgs>(args?: SelectSubset<T, TicketTierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketTiers and returns the data saved in the database.
     * @param {TicketTierCreateManyAndReturnArgs} args - Arguments to create many TicketTiers.
     * @example
     * // Create many TicketTiers
     * const ticketTier = await prisma.ticketTier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketTiers and only return the `id`
     * const ticketTierWithIdOnly = await prisma.ticketTier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketTierCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketTierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketTierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TicketTier.
     * @param {TicketTierDeleteArgs} args - Arguments to delete one TicketTier.
     * @example
     * // Delete one TicketTier
     * const TicketTier = await prisma.ticketTier.delete({
     *   where: {
     *     // ... filter to delete one TicketTier
     *   }
     * })
     * 
     */
    delete<T extends TicketTierDeleteArgs>(args: SelectSubset<T, TicketTierDeleteArgs<ExtArgs>>): Prisma__TicketTierClient<$Result.GetResult<Prisma.$TicketTierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TicketTier.
     * @param {TicketTierUpdateArgs} args - Arguments to update one TicketTier.
     * @example
     * // Update one TicketTier
     * const ticketTier = await prisma.ticketTier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketTierUpdateArgs>(args: SelectSubset<T, TicketTierUpdateArgs<ExtArgs>>): Prisma__TicketTierClient<$Result.GetResult<Prisma.$TicketTierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TicketTiers.
     * @param {TicketTierDeleteManyArgs} args - Arguments to filter TicketTiers to delete.
     * @example
     * // Delete a few TicketTiers
     * const { count } = await prisma.ticketTier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketTierDeleteManyArgs>(args?: SelectSubset<T, TicketTierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketTiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketTiers
     * const ticketTier = await prisma.ticketTier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketTierUpdateManyArgs>(args: SelectSubset<T, TicketTierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketTiers and returns the data updated in the database.
     * @param {TicketTierUpdateManyAndReturnArgs} args - Arguments to update many TicketTiers.
     * @example
     * // Update many TicketTiers
     * const ticketTier = await prisma.ticketTier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TicketTiers and only return the `id`
     * const ticketTierWithIdOnly = await prisma.ticketTier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketTierUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketTierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketTierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TicketTier.
     * @param {TicketTierUpsertArgs} args - Arguments to update or create a TicketTier.
     * @example
     * // Update or create a TicketTier
     * const ticketTier = await prisma.ticketTier.upsert({
     *   create: {
     *     // ... data to create a TicketTier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketTier we want to update
     *   }
     * })
     */
    upsert<T extends TicketTierUpsertArgs>(args: SelectSubset<T, TicketTierUpsertArgs<ExtArgs>>): Prisma__TicketTierClient<$Result.GetResult<Prisma.$TicketTierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TicketTiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTierCountArgs} args - Arguments to filter TicketTiers to count.
     * @example
     * // Count the number of TicketTiers
     * const count = await prisma.ticketTier.count({
     *   where: {
     *     // ... the filter for the TicketTiers we want to count
     *   }
     * })
    **/
    count<T extends TicketTierCountArgs>(
      args?: Subset<T, TicketTierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketTierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketTier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketTierAggregateArgs>(args: Subset<T, TicketTierAggregateArgs>): Prisma.PrismaPromise<GetTicketTierAggregateType<T>>

    /**
     * Group by TicketTier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketTierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketTierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketTierGroupByArgs['orderBy'] }
        : { orderBy?: TicketTierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketTierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketTierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketTier model
   */
  readonly fields: TicketTierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketTier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketTierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tickets<T extends TicketTier$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, TicketTier$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketTier model
   */
  interface TicketTierFieldRefs {
    readonly id: FieldRef<"TicketTier", 'String'>
    readonly eventId: FieldRef<"TicketTier", 'String'>
    readonly name: FieldRef<"TicketTier", 'String'>
    readonly price: FieldRef<"TicketTier", 'Float'>
    readonly currency: FieldRef<"TicketTier", 'String'>
    readonly description: FieldRef<"TicketTier", 'String'>
    readonly available: FieldRef<"TicketTier", 'Int'>
    readonly total: FieldRef<"TicketTier", 'Int'>
    readonly benefits: FieldRef<"TicketTier", 'String[]'>
  }
    

  // Custom InputTypes
  /**
   * TicketTier findUnique
   */
  export type TicketTierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTier
     */
    select?: TicketTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTier
     */
    omit?: TicketTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTierInclude<ExtArgs> | null
    /**
     * Filter, which TicketTier to fetch.
     */
    where: TicketTierWhereUniqueInput
  }

  /**
   * TicketTier findUniqueOrThrow
   */
  export type TicketTierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTier
     */
    select?: TicketTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTier
     */
    omit?: TicketTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTierInclude<ExtArgs> | null
    /**
     * Filter, which TicketTier to fetch.
     */
    where: TicketTierWhereUniqueInput
  }

  /**
   * TicketTier findFirst
   */
  export type TicketTierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTier
     */
    select?: TicketTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTier
     */
    omit?: TicketTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTierInclude<ExtArgs> | null
    /**
     * Filter, which TicketTier to fetch.
     */
    where?: TicketTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketTiers to fetch.
     */
    orderBy?: TicketTierOrderByWithRelationInput | TicketTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketTiers.
     */
    cursor?: TicketTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketTiers.
     */
    distinct?: TicketTierScalarFieldEnum | TicketTierScalarFieldEnum[]
  }

  /**
   * TicketTier findFirstOrThrow
   */
  export type TicketTierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTier
     */
    select?: TicketTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTier
     */
    omit?: TicketTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTierInclude<ExtArgs> | null
    /**
     * Filter, which TicketTier to fetch.
     */
    where?: TicketTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketTiers to fetch.
     */
    orderBy?: TicketTierOrderByWithRelationInput | TicketTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketTiers.
     */
    cursor?: TicketTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketTiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketTiers.
     */
    distinct?: TicketTierScalarFieldEnum | TicketTierScalarFieldEnum[]
  }

  /**
   * TicketTier findMany
   */
  export type TicketTierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTier
     */
    select?: TicketTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTier
     */
    omit?: TicketTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTierInclude<ExtArgs> | null
    /**
     * Filter, which TicketTiers to fetch.
     */
    where?: TicketTierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketTiers to fetch.
     */
    orderBy?: TicketTierOrderByWithRelationInput | TicketTierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketTiers.
     */
    cursor?: TicketTierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketTiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketTiers.
     */
    skip?: number
    distinct?: TicketTierScalarFieldEnum | TicketTierScalarFieldEnum[]
  }

  /**
   * TicketTier create
   */
  export type TicketTierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTier
     */
    select?: TicketTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTier
     */
    omit?: TicketTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTierInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketTier.
     */
    data: XOR<TicketTierCreateInput, TicketTierUncheckedCreateInput>
  }

  /**
   * TicketTier createMany
   */
  export type TicketTierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketTiers.
     */
    data: TicketTierCreateManyInput | TicketTierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketTier createManyAndReturn
   */
  export type TicketTierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTier
     */
    select?: TicketTierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTier
     */
    omit?: TicketTierOmit<ExtArgs> | null
    /**
     * The data used to create many TicketTiers.
     */
    data: TicketTierCreateManyInput | TicketTierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketTier update
   */
  export type TicketTierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTier
     */
    select?: TicketTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTier
     */
    omit?: TicketTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTierInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketTier.
     */
    data: XOR<TicketTierUpdateInput, TicketTierUncheckedUpdateInput>
    /**
     * Choose, which TicketTier to update.
     */
    where: TicketTierWhereUniqueInput
  }

  /**
   * TicketTier updateMany
   */
  export type TicketTierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketTiers.
     */
    data: XOR<TicketTierUpdateManyMutationInput, TicketTierUncheckedUpdateManyInput>
    /**
     * Filter which TicketTiers to update
     */
    where?: TicketTierWhereInput
    /**
     * Limit how many TicketTiers to update.
     */
    limit?: number
  }

  /**
   * TicketTier updateManyAndReturn
   */
  export type TicketTierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTier
     */
    select?: TicketTierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTier
     */
    omit?: TicketTierOmit<ExtArgs> | null
    /**
     * The data used to update TicketTiers.
     */
    data: XOR<TicketTierUpdateManyMutationInput, TicketTierUncheckedUpdateManyInput>
    /**
     * Filter which TicketTiers to update
     */
    where?: TicketTierWhereInput
    /**
     * Limit how many TicketTiers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketTier upsert
   */
  export type TicketTierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTier
     */
    select?: TicketTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTier
     */
    omit?: TicketTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTierInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketTier to update in case it exists.
     */
    where: TicketTierWhereUniqueInput
    /**
     * In case the TicketTier found by the `where` argument doesn't exist, create a new TicketTier with this data.
     */
    create: XOR<TicketTierCreateInput, TicketTierUncheckedCreateInput>
    /**
     * In case the TicketTier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketTierUpdateInput, TicketTierUncheckedUpdateInput>
  }

  /**
   * TicketTier delete
   */
  export type TicketTierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTier
     */
    select?: TicketTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTier
     */
    omit?: TicketTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTierInclude<ExtArgs> | null
    /**
     * Filter which TicketTier to delete.
     */
    where: TicketTierWhereUniqueInput
  }

  /**
   * TicketTier deleteMany
   */
  export type TicketTierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketTiers to delete
     */
    where?: TicketTierWhereInput
    /**
     * Limit how many TicketTiers to delete.
     */
    limit?: number
  }

  /**
   * TicketTier.tickets
   */
  export type TicketTier$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * TicketTier without action
   */
  export type TicketTierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketTier
     */
    select?: TicketTierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketTier
     */
    omit?: TicketTierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketTierInclude<ExtArgs> | null
  }


  /**
   * Model Ticket
   */

  export type AggregateTicket = {
    _count: TicketCountAggregateOutputType | null
    _avg: TicketAvgAggregateOutputType | null
    _sum: TicketSumAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  export type TicketAvgAggregateOutputType = {
    originalPrice: number | null
    currentPrice: number | null
  }

  export type TicketSumAggregateOutputType = {
    originalPrice: number | null
    currentPrice: number | null
  }

  export type TicketMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    tierId: string | null
    ownerId: string | null
    originalPrice: number | null
    currentPrice: number | null
    purchaseDate: Date | null
    status: string | null
    qrCode: string | null
    tokenId: string | null
    txHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TicketMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    tierId: string | null
    ownerId: string | null
    originalPrice: number | null
    currentPrice: number | null
    purchaseDate: Date | null
    status: string | null
    qrCode: string | null
    tokenId: string | null
    txHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TicketCountAggregateOutputType = {
    id: number
    eventId: number
    tierId: number
    ownerId: number
    originalPrice: number
    currentPrice: number
    purchaseDate: number
    status: number
    qrCode: number
    tokenId: number
    txHash: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TicketAvgAggregateInputType = {
    originalPrice?: true
    currentPrice?: true
  }

  export type TicketSumAggregateInputType = {
    originalPrice?: true
    currentPrice?: true
  }

  export type TicketMinAggregateInputType = {
    id?: true
    eventId?: true
    tierId?: true
    ownerId?: true
    originalPrice?: true
    currentPrice?: true
    purchaseDate?: true
    status?: true
    qrCode?: true
    tokenId?: true
    txHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TicketMaxAggregateInputType = {
    id?: true
    eventId?: true
    tierId?: true
    ownerId?: true
    originalPrice?: true
    currentPrice?: true
    purchaseDate?: true
    status?: true
    qrCode?: true
    tokenId?: true
    txHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TicketCountAggregateInputType = {
    id?: true
    eventId?: true
    tierId?: true
    ownerId?: true
    originalPrice?: true
    currentPrice?: true
    purchaseDate?: true
    status?: true
    qrCode?: true
    tokenId?: true
    txHash?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ticket to aggregate.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tickets
    **/
    _count?: true | TicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMaxAggregateInputType
  }

  export type GetTicketAggregateType<T extends TicketAggregateArgs> = {
        [P in keyof T & keyof AggregateTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicket[P]>
      : GetScalarType<T[P], AggregateTicket[P]>
  }




  export type TicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithAggregationInput | TicketOrderByWithAggregationInput[]
    by: TicketScalarFieldEnum[] | TicketScalarFieldEnum
    having?: TicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCountAggregateInputType | true
    _avg?: TicketAvgAggregateInputType
    _sum?: TicketSumAggregateInputType
    _min?: TicketMinAggregateInputType
    _max?: TicketMaxAggregateInputType
  }

  export type TicketGroupByOutputType = {
    id: string
    eventId: string
    tierId: string
    ownerId: string
    originalPrice: number
    currentPrice: number
    purchaseDate: Date
    status: string
    qrCode: string | null
    tokenId: string | null
    txHash: string | null
    createdAt: Date
    updatedAt: Date
    _count: TicketCountAggregateOutputType | null
    _avg: TicketAvgAggregateOutputType | null
    _sum: TicketSumAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  type GetTicketGroupByPayload<T extends TicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketGroupByOutputType[P]>
            : GetScalarType<T[P], TicketGroupByOutputType[P]>
        }
      >
    >


  export type TicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    tierId?: boolean
    ownerId?: boolean
    originalPrice?: boolean
    currentPrice?: boolean
    purchaseDate?: boolean
    status?: boolean
    qrCode?: boolean
    tokenId?: boolean
    txHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    tier?: boolean | TicketTierDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    tierId?: boolean
    ownerId?: boolean
    originalPrice?: boolean
    currentPrice?: boolean
    purchaseDate?: boolean
    status?: boolean
    qrCode?: boolean
    tokenId?: boolean
    txHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    tier?: boolean | TicketTierDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    tierId?: boolean
    ownerId?: boolean
    originalPrice?: boolean
    currentPrice?: boolean
    purchaseDate?: boolean
    status?: boolean
    qrCode?: boolean
    tokenId?: boolean
    txHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    tier?: boolean | TicketTierDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectScalar = {
    id?: boolean
    eventId?: boolean
    tierId?: boolean
    ownerId?: boolean
    originalPrice?: boolean
    currentPrice?: boolean
    purchaseDate?: boolean
    status?: boolean
    qrCode?: boolean
    tokenId?: boolean
    txHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TicketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "tierId" | "ownerId" | "originalPrice" | "currentPrice" | "purchaseDate" | "status" | "qrCode" | "tokenId" | "txHash" | "createdAt" | "updatedAt", ExtArgs["result"]["ticket"]>
  export type TicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    tier?: boolean | TicketTierDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    tier?: boolean | TicketTierDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TicketIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    tier?: boolean | TicketTierDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ticket"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
      tier: Prisma.$TicketTierPayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      tierId: string
      ownerId: string
      originalPrice: number
      currentPrice: number
      purchaseDate: Date
      status: string
      qrCode: string | null
      tokenId: string | null
      txHash: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ticket"]>
    composites: {}
  }

  type TicketGetPayload<S extends boolean | null | undefined | TicketDefaultArgs> = $Result.GetResult<Prisma.$TicketPayload, S>

  type TicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketCountAggregateInputType | true
    }

  export interface TicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ticket'], meta: { name: 'Ticket' } }
    /**
     * Find zero or one Ticket that matches the filter.
     * @param {TicketFindUniqueArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketFindUniqueArgs>(args: SelectSubset<T, TicketFindUniqueArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ticket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketFindUniqueOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketFindFirstArgs>(args?: SelectSubset<T, TicketFindFirstArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.ticket.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.ticket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketWithIdOnly = await prisma.ticket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketFindManyArgs>(args?: SelectSubset<T, TicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ticket.
     * @param {TicketCreateArgs} args - Arguments to create a Ticket.
     * @example
     * // Create one Ticket
     * const Ticket = await prisma.ticket.create({
     *   data: {
     *     // ... data to create a Ticket
     *   }
     * })
     * 
     */
    create<T extends TicketCreateArgs>(args: SelectSubset<T, TicketCreateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tickets.
     * @param {TicketCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCreateManyArgs>(args?: SelectSubset<T, TicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tickets and returns the data saved in the database.
     * @param {TicketCreateManyAndReturnArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ticket.
     * @param {TicketDeleteArgs} args - Arguments to delete one Ticket.
     * @example
     * // Delete one Ticket
     * const Ticket = await prisma.ticket.delete({
     *   where: {
     *     // ... filter to delete one Ticket
     *   }
     * })
     * 
     */
    delete<T extends TicketDeleteArgs>(args: SelectSubset<T, TicketDeleteArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ticket.
     * @param {TicketUpdateArgs} args - Arguments to update one Ticket.
     * @example
     * // Update one Ticket
     * const ticket = await prisma.ticket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketUpdateArgs>(args: SelectSubset<T, TicketUpdateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tickets.
     * @param {TicketDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.ticket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketDeleteManyArgs>(args?: SelectSubset<T, TicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketUpdateManyArgs>(args: SelectSubset<T, TicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets and returns the data updated in the database.
     * @param {TicketUpdateManyAndReturnArgs} args - Arguments to update many Tickets.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ticket.
     * @param {TicketUpsertArgs} args - Arguments to update or create a Ticket.
     * @example
     * // Update or create a Ticket
     * const ticket = await prisma.ticket.upsert({
     *   create: {
     *     // ... data to create a Ticket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ticket we want to update
     *   }
     * })
     */
    upsert<T extends TicketUpsertArgs>(args: SelectSubset<T, TicketUpsertArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.ticket.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends TicketCountArgs>(
      args?: Subset<T, TicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAggregateArgs>(args: Subset<T, TicketAggregateArgs>): Prisma.PrismaPromise<GetTicketAggregateType<T>>

    /**
     * Group by Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketGroupByArgs['orderBy'] }
        : { orderBy?: TicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ticket model
   */
  readonly fields: TicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ticket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tier<T extends TicketTierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketTierDefaultArgs<ExtArgs>>): Prisma__TicketTierClient<$Result.GetResult<Prisma.$TicketTierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ticket model
   */
  interface TicketFieldRefs {
    readonly id: FieldRef<"Ticket", 'String'>
    readonly eventId: FieldRef<"Ticket", 'String'>
    readonly tierId: FieldRef<"Ticket", 'String'>
    readonly ownerId: FieldRef<"Ticket", 'String'>
    readonly originalPrice: FieldRef<"Ticket", 'Float'>
    readonly currentPrice: FieldRef<"Ticket", 'Float'>
    readonly purchaseDate: FieldRef<"Ticket", 'DateTime'>
    readonly status: FieldRef<"Ticket", 'String'>
    readonly qrCode: FieldRef<"Ticket", 'String'>
    readonly tokenId: FieldRef<"Ticket", 'String'>
    readonly txHash: FieldRef<"Ticket", 'String'>
    readonly createdAt: FieldRef<"Ticket", 'DateTime'>
    readonly updatedAt: FieldRef<"Ticket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Ticket findUnique
   */
  export type TicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findUniqueOrThrow
   */
  export type TicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findFirst
   */
  export type TicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findFirstOrThrow
   */
  export type TicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findMany
   */
  export type TicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket create
   */
  export type TicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to create a Ticket.
     */
    data: XOR<TicketCreateInput, TicketUncheckedCreateInput>
  }

  /**
   * Ticket createMany
   */
  export type TicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ticket createManyAndReturn
   */
  export type TicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket update
   */
  export type TicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to update a Ticket.
     */
    data: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
    /**
     * Choose, which Ticket to update.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket updateMany
   */
  export type TicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
  }

  /**
   * Ticket updateManyAndReturn
   */
  export type TicketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket upsert
   */
  export type TicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The filter to search for the Ticket to update in case it exists.
     */
    where: TicketWhereUniqueInput
    /**
     * In case the Ticket found by the `where` argument doesn't exist, create a new Ticket with this data.
     */
    create: XOR<TicketCreateInput, TicketUncheckedCreateInput>
    /**
     * In case the Ticket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
  }

  /**
   * Ticket delete
   */
  export type TicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter which Ticket to delete.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket deleteMany
   */
  export type TicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to delete
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to delete.
     */
    limit?: number
  }

  /**
   * Ticket without action
   */
  export type TicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
  }


  /**
   * Model Community
   */

  export type AggregateCommunity = {
    _count: CommunityCountAggregateOutputType | null
    _avg: CommunityAvgAggregateOutputType | null
    _sum: CommunitySumAggregateOutputType | null
    _min: CommunityMinAggregateOutputType | null
    _max: CommunityMaxAggregateOutputType | null
  }

  export type CommunityAvgAggregateOutputType = {
    memberCount: number | null
  }

  export type CommunitySumAggregateOutputType = {
    memberCount: number | null
  }

  export type CommunityMinAggregateOutputType = {
    id: string | null
    name: string | null
    artistId: string | null
    artistName: string | null
    artistImage: string | null
    description: string | null
    memberCount: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunityMaxAggregateOutputType = {
    id: string | null
    name: string | null
    artistId: string | null
    artistName: string | null
    artistImage: string | null
    description: string | null
    memberCount: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunityCountAggregateOutputType = {
    id: number
    name: number
    artistId: number
    artistName: number
    artistImage: number
    description: number
    memberCount: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommunityAvgAggregateInputType = {
    memberCount?: true
  }

  export type CommunitySumAggregateInputType = {
    memberCount?: true
  }

  export type CommunityMinAggregateInputType = {
    id?: true
    name?: true
    artistId?: true
    artistName?: true
    artistImage?: true
    description?: true
    memberCount?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunityMaxAggregateInputType = {
    id?: true
    name?: true
    artistId?: true
    artistName?: true
    artistImage?: true
    description?: true
    memberCount?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunityCountAggregateInputType = {
    id?: true
    name?: true
    artistId?: true
    artistName?: true
    artistImage?: true
    description?: true
    memberCount?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommunityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Community to aggregate.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Communities
    **/
    _count?: true | CommunityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityMaxAggregateInputType
  }

  export type GetCommunityAggregateType<T extends CommunityAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunity[P]>
      : GetScalarType<T[P], AggregateCommunity[P]>
  }




  export type CommunityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityWhereInput
    orderBy?: CommunityOrderByWithAggregationInput | CommunityOrderByWithAggregationInput[]
    by: CommunityScalarFieldEnum[] | CommunityScalarFieldEnum
    having?: CommunityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityCountAggregateInputType | true
    _avg?: CommunityAvgAggregateInputType
    _sum?: CommunitySumAggregateInputType
    _min?: CommunityMinAggregateInputType
    _max?: CommunityMaxAggregateInputType
  }

  export type CommunityGroupByOutputType = {
    id: string
    name: string
    artistId: string
    artistName: string
    artistImage: string
    description: string
    memberCount: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: CommunityCountAggregateOutputType | null
    _avg: CommunityAvgAggregateOutputType | null
    _sum: CommunitySumAggregateOutputType | null
    _min: CommunityMinAggregateOutputType | null
    _max: CommunityMaxAggregateOutputType | null
  }

  type GetCommunityGroupByPayload<T extends CommunityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityGroupByOutputType[P]>
        }
      >
    >


  export type CommunitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    artistId?: boolean
    artistName?: boolean
    artistImage?: boolean
    description?: boolean
    memberCount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    posts?: boolean | Community$postsArgs<ExtArgs>
    members?: boolean | Community$membersArgs<ExtArgs>
    proposals?: boolean | Community$proposalsArgs<ExtArgs>
    _count?: boolean | CommunityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["community"]>

  export type CommunitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    artistId?: boolean
    artistName?: boolean
    artistImage?: boolean
    description?: boolean
    memberCount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["community"]>

  export type CommunitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    artistId?: boolean
    artistName?: boolean
    artistImage?: boolean
    description?: boolean
    memberCount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["community"]>

  export type CommunitySelectScalar = {
    id?: boolean
    name?: boolean
    artistId?: boolean
    artistName?: boolean
    artistImage?: boolean
    description?: boolean
    memberCount?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommunityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "artistId" | "artistName" | "artistImage" | "description" | "memberCount" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["community"]>
  export type CommunityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | Community$postsArgs<ExtArgs>
    members?: boolean | Community$membersArgs<ExtArgs>
    proposals?: boolean | Community$proposalsArgs<ExtArgs>
    _count?: boolean | CommunityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommunityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CommunityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CommunityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Community"
    objects: {
      posts: Prisma.$CommunityPostPayload<ExtArgs>[]
      members: Prisma.$CommunityMemberPayload<ExtArgs>[]
      proposals: Prisma.$GovernanceProposalPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      artistId: string
      artistName: string
      artistImage: string
      description: string
      memberCount: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["community"]>
    composites: {}
  }

  type CommunityGetPayload<S extends boolean | null | undefined | CommunityDefaultArgs> = $Result.GetResult<Prisma.$CommunityPayload, S>

  type CommunityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommunityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommunityCountAggregateInputType | true
    }

  export interface CommunityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Community'], meta: { name: 'Community' } }
    /**
     * Find zero or one Community that matches the filter.
     * @param {CommunityFindUniqueArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunityFindUniqueArgs>(args: SelectSubset<T, CommunityFindUniqueArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Community that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommunityFindUniqueOrThrowArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunityFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Community that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFindFirstArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunityFindFirstArgs>(args?: SelectSubset<T, CommunityFindFirstArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Community that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFindFirstOrThrowArgs} args - Arguments to find a Community
     * @example
     * // Get one Community
     * const community = await prisma.community.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunityFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunityFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Communities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Communities
     * const communities = await prisma.community.findMany()
     * 
     * // Get first 10 Communities
     * const communities = await prisma.community.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityWithIdOnly = await prisma.community.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunityFindManyArgs>(args?: SelectSubset<T, CommunityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Community.
     * @param {CommunityCreateArgs} args - Arguments to create a Community.
     * @example
     * // Create one Community
     * const Community = await prisma.community.create({
     *   data: {
     *     // ... data to create a Community
     *   }
     * })
     * 
     */
    create<T extends CommunityCreateArgs>(args: SelectSubset<T, CommunityCreateArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Communities.
     * @param {CommunityCreateManyArgs} args - Arguments to create many Communities.
     * @example
     * // Create many Communities
     * const community = await prisma.community.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunityCreateManyArgs>(args?: SelectSubset<T, CommunityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Communities and returns the data saved in the database.
     * @param {CommunityCreateManyAndReturnArgs} args - Arguments to create many Communities.
     * @example
     * // Create many Communities
     * const community = await prisma.community.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Communities and only return the `id`
     * const communityWithIdOnly = await prisma.community.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommunityCreateManyAndReturnArgs>(args?: SelectSubset<T, CommunityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Community.
     * @param {CommunityDeleteArgs} args - Arguments to delete one Community.
     * @example
     * // Delete one Community
     * const Community = await prisma.community.delete({
     *   where: {
     *     // ... filter to delete one Community
     *   }
     * })
     * 
     */
    delete<T extends CommunityDeleteArgs>(args: SelectSubset<T, CommunityDeleteArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Community.
     * @param {CommunityUpdateArgs} args - Arguments to update one Community.
     * @example
     * // Update one Community
     * const community = await prisma.community.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunityUpdateArgs>(args: SelectSubset<T, CommunityUpdateArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Communities.
     * @param {CommunityDeleteManyArgs} args - Arguments to filter Communities to delete.
     * @example
     * // Delete a few Communities
     * const { count } = await prisma.community.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunityDeleteManyArgs>(args?: SelectSubset<T, CommunityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Communities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Communities
     * const community = await prisma.community.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunityUpdateManyArgs>(args: SelectSubset<T, CommunityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Communities and returns the data updated in the database.
     * @param {CommunityUpdateManyAndReturnArgs} args - Arguments to update many Communities.
     * @example
     * // Update many Communities
     * const community = await prisma.community.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Communities and only return the `id`
     * const communityWithIdOnly = await prisma.community.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommunityUpdateManyAndReturnArgs>(args: SelectSubset<T, CommunityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Community.
     * @param {CommunityUpsertArgs} args - Arguments to update or create a Community.
     * @example
     * // Update or create a Community
     * const community = await prisma.community.upsert({
     *   create: {
     *     // ... data to create a Community
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Community we want to update
     *   }
     * })
     */
    upsert<T extends CommunityUpsertArgs>(args: SelectSubset<T, CommunityUpsertArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Communities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityCountArgs} args - Arguments to filter Communities to count.
     * @example
     * // Count the number of Communities
     * const count = await prisma.community.count({
     *   where: {
     *     // ... the filter for the Communities we want to count
     *   }
     * })
    **/
    count<T extends CommunityCountArgs>(
      args?: Subset<T, CommunityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Community.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityAggregateArgs>(args: Subset<T, CommunityAggregateArgs>): Prisma.PrismaPromise<GetCommunityAggregateType<T>>

    /**
     * Group by Community.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityGroupByArgs['orderBy'] }
        : { orderBy?: CommunityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Community model
   */
  readonly fields: CommunityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Community.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends Community$postsArgs<ExtArgs> = {}>(args?: Subset<T, Community$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    members<T extends Community$membersArgs<ExtArgs> = {}>(args?: Subset<T, Community$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    proposals<T extends Community$proposalsArgs<ExtArgs> = {}>(args?: Subset<T, Community$proposalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GovernanceProposalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Community model
   */
  interface CommunityFieldRefs {
    readonly id: FieldRef<"Community", 'String'>
    readonly name: FieldRef<"Community", 'String'>
    readonly artistId: FieldRef<"Community", 'String'>
    readonly artistName: FieldRef<"Community", 'String'>
    readonly artistImage: FieldRef<"Community", 'String'>
    readonly description: FieldRef<"Community", 'String'>
    readonly memberCount: FieldRef<"Community", 'Int'>
    readonly isActive: FieldRef<"Community", 'Boolean'>
    readonly createdAt: FieldRef<"Community", 'DateTime'>
    readonly updatedAt: FieldRef<"Community", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Community findUnique
   */
  export type CommunityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community findUniqueOrThrow
   */
  export type CommunityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community findFirst
   */
  export type CommunityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Communities.
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Communities.
     */
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }

  /**
   * Community findFirstOrThrow
   */
  export type CommunityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Community to fetch.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Communities.
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Communities.
     */
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }

  /**
   * Community findMany
   */
  export type CommunityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter, which Communities to fetch.
     */
    where?: CommunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Communities to fetch.
     */
    orderBy?: CommunityOrderByWithRelationInput | CommunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Communities.
     */
    cursor?: CommunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Communities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Communities.
     */
    skip?: number
    distinct?: CommunityScalarFieldEnum | CommunityScalarFieldEnum[]
  }

  /**
   * Community create
   */
  export type CommunityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * The data needed to create a Community.
     */
    data: XOR<CommunityCreateInput, CommunityUncheckedCreateInput>
  }

  /**
   * Community createMany
   */
  export type CommunityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Communities.
     */
    data: CommunityCreateManyInput | CommunityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Community createManyAndReturn
   */
  export type CommunityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * The data used to create many Communities.
     */
    data: CommunityCreateManyInput | CommunityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Community update
   */
  export type CommunityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * The data needed to update a Community.
     */
    data: XOR<CommunityUpdateInput, CommunityUncheckedUpdateInput>
    /**
     * Choose, which Community to update.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community updateMany
   */
  export type CommunityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Communities.
     */
    data: XOR<CommunityUpdateManyMutationInput, CommunityUncheckedUpdateManyInput>
    /**
     * Filter which Communities to update
     */
    where?: CommunityWhereInput
    /**
     * Limit how many Communities to update.
     */
    limit?: number
  }

  /**
   * Community updateManyAndReturn
   */
  export type CommunityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * The data used to update Communities.
     */
    data: XOR<CommunityUpdateManyMutationInput, CommunityUncheckedUpdateManyInput>
    /**
     * Filter which Communities to update
     */
    where?: CommunityWhereInput
    /**
     * Limit how many Communities to update.
     */
    limit?: number
  }

  /**
   * Community upsert
   */
  export type CommunityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * The filter to search for the Community to update in case it exists.
     */
    where: CommunityWhereUniqueInput
    /**
     * In case the Community found by the `where` argument doesn't exist, create a new Community with this data.
     */
    create: XOR<CommunityCreateInput, CommunityUncheckedCreateInput>
    /**
     * In case the Community was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityUpdateInput, CommunityUncheckedUpdateInput>
  }

  /**
   * Community delete
   */
  export type CommunityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
    /**
     * Filter which Community to delete.
     */
    where: CommunityWhereUniqueInput
  }

  /**
   * Community deleteMany
   */
  export type CommunityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Communities to delete
     */
    where?: CommunityWhereInput
    /**
     * Limit how many Communities to delete.
     */
    limit?: number
  }

  /**
   * Community.posts
   */
  export type Community$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityPost
     */
    omit?: CommunityPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityPostInclude<ExtArgs> | null
    where?: CommunityPostWhereInput
    orderBy?: CommunityPostOrderByWithRelationInput | CommunityPostOrderByWithRelationInput[]
    cursor?: CommunityPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityPostScalarFieldEnum | CommunityPostScalarFieldEnum[]
  }

  /**
   * Community.members
   */
  export type Community$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberInclude<ExtArgs> | null
    where?: CommunityMemberWhereInput
    orderBy?: CommunityMemberOrderByWithRelationInput | CommunityMemberOrderByWithRelationInput[]
    cursor?: CommunityMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommunityMemberScalarFieldEnum | CommunityMemberScalarFieldEnum[]
  }

  /**
   * Community.proposals
   */
  export type Community$proposalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposal
     */
    select?: GovernanceProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceProposal
     */
    omit?: GovernanceProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceProposalInclude<ExtArgs> | null
    where?: GovernanceProposalWhereInput
    orderBy?: GovernanceProposalOrderByWithRelationInput | GovernanceProposalOrderByWithRelationInput[]
    cursor?: GovernanceProposalWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GovernanceProposalScalarFieldEnum | GovernanceProposalScalarFieldEnum[]
  }

  /**
   * Community without action
   */
  export type CommunityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Community
     */
    select?: CommunitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Community
     */
    omit?: CommunityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityInclude<ExtArgs> | null
  }


  /**
   * Model CommunityPost
   */

  export type AggregateCommunityPost = {
    _count: CommunityPostCountAggregateOutputType | null
    _avg: CommunityPostAvgAggregateOutputType | null
    _sum: CommunityPostSumAggregateOutputType | null
    _min: CommunityPostMinAggregateOutputType | null
    _max: CommunityPostMaxAggregateOutputType | null
  }

  export type CommunityPostAvgAggregateOutputType = {
    upvotes: number | null
    downvotes: number | null
    commentCount: number | null
  }

  export type CommunityPostSumAggregateOutputType = {
    upvotes: number | null
    downvotes: number | null
    commentCount: number | null
  }

  export type CommunityPostMinAggregateOutputType = {
    id: string | null
    communityId: string | null
    authorId: string | null
    title: string | null
    content: string | null
    type: string | null
    upvotes: number | null
    downvotes: number | null
    commentCount: number | null
    isPinned: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunityPostMaxAggregateOutputType = {
    id: string | null
    communityId: string | null
    authorId: string | null
    title: string | null
    content: string | null
    type: string | null
    upvotes: number | null
    downvotes: number | null
    commentCount: number | null
    isPinned: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommunityPostCountAggregateOutputType = {
    id: number
    communityId: number
    authorId: number
    title: number
    content: number
    type: number
    images: number
    upvotes: number
    downvotes: number
    commentCount: number
    isPinned: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommunityPostAvgAggregateInputType = {
    upvotes?: true
    downvotes?: true
    commentCount?: true
  }

  export type CommunityPostSumAggregateInputType = {
    upvotes?: true
    downvotes?: true
    commentCount?: true
  }

  export type CommunityPostMinAggregateInputType = {
    id?: true
    communityId?: true
    authorId?: true
    title?: true
    content?: true
    type?: true
    upvotes?: true
    downvotes?: true
    commentCount?: true
    isPinned?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunityPostMaxAggregateInputType = {
    id?: true
    communityId?: true
    authorId?: true
    title?: true
    content?: true
    type?: true
    upvotes?: true
    downvotes?: true
    commentCount?: true
    isPinned?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommunityPostCountAggregateInputType = {
    id?: true
    communityId?: true
    authorId?: true
    title?: true
    content?: true
    type?: true
    images?: true
    upvotes?: true
    downvotes?: true
    commentCount?: true
    isPinned?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommunityPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityPost to aggregate.
     */
    where?: CommunityPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityPosts to fetch.
     */
    orderBy?: CommunityPostOrderByWithRelationInput | CommunityPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityPosts
    **/
    _count?: true | CommunityPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunityPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityPostMaxAggregateInputType
  }

  export type GetCommunityPostAggregateType<T extends CommunityPostAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunityPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityPost[P]>
      : GetScalarType<T[P], AggregateCommunityPost[P]>
  }




  export type CommunityPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityPostWhereInput
    orderBy?: CommunityPostOrderByWithAggregationInput | CommunityPostOrderByWithAggregationInput[]
    by: CommunityPostScalarFieldEnum[] | CommunityPostScalarFieldEnum
    having?: CommunityPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityPostCountAggregateInputType | true
    _avg?: CommunityPostAvgAggregateInputType
    _sum?: CommunityPostSumAggregateInputType
    _min?: CommunityPostMinAggregateInputType
    _max?: CommunityPostMaxAggregateInputType
  }

  export type CommunityPostGroupByOutputType = {
    id: string
    communityId: string
    authorId: string
    title: string
    content: string
    type: string
    images: string[]
    upvotes: number
    downvotes: number
    commentCount: number
    isPinned: boolean
    createdAt: Date
    updatedAt: Date
    _count: CommunityPostCountAggregateOutputType | null
    _avg: CommunityPostAvgAggregateOutputType | null
    _sum: CommunityPostSumAggregateOutputType | null
    _min: CommunityPostMinAggregateOutputType | null
    _max: CommunityPostMaxAggregateOutputType | null
  }

  type GetCommunityPostGroupByPayload<T extends CommunityPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityPostGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityPostGroupByOutputType[P]>
        }
      >
    >


  export type CommunityPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    communityId?: boolean
    authorId?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    images?: boolean
    upvotes?: boolean
    downvotes?: boolean
    commentCount?: boolean
    isPinned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    votes?: boolean | CommunityPost$votesArgs<ExtArgs>
    comments?: boolean | CommunityPost$commentsArgs<ExtArgs>
    _count?: boolean | CommunityPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communityPost"]>

  export type CommunityPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    communityId?: boolean
    authorId?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    images?: boolean
    upvotes?: boolean
    downvotes?: boolean
    commentCount?: boolean
    isPinned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communityPost"]>

  export type CommunityPostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    communityId?: boolean
    authorId?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    images?: boolean
    upvotes?: boolean
    downvotes?: boolean
    commentCount?: boolean
    isPinned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communityPost"]>

  export type CommunityPostSelectScalar = {
    id?: boolean
    communityId?: boolean
    authorId?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    images?: boolean
    upvotes?: boolean
    downvotes?: boolean
    commentCount?: boolean
    isPinned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommunityPostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "communityId" | "authorId" | "title" | "content" | "type" | "images" | "upvotes" | "downvotes" | "commentCount" | "isPinned" | "createdAt" | "updatedAt", ExtArgs["result"]["communityPost"]>
  export type CommunityPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    votes?: boolean | CommunityPost$votesArgs<ExtArgs>
    comments?: boolean | CommunityPost$commentsArgs<ExtArgs>
    _count?: boolean | CommunityPostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommunityPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommunityPostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommunityPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommunityPost"
    objects: {
      community: Prisma.$CommunityPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
      votes: Prisma.$PostVotePayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      communityId: string
      authorId: string
      title: string
      content: string
      type: string
      images: string[]
      upvotes: number
      downvotes: number
      commentCount: number
      isPinned: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["communityPost"]>
    composites: {}
  }

  type CommunityPostGetPayload<S extends boolean | null | undefined | CommunityPostDefaultArgs> = $Result.GetResult<Prisma.$CommunityPostPayload, S>

  type CommunityPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommunityPostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommunityPostCountAggregateInputType | true
    }

  export interface CommunityPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommunityPost'], meta: { name: 'CommunityPost' } }
    /**
     * Find zero or one CommunityPost that matches the filter.
     * @param {CommunityPostFindUniqueArgs} args - Arguments to find a CommunityPost
     * @example
     * // Get one CommunityPost
     * const communityPost = await prisma.communityPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunityPostFindUniqueArgs>(args: SelectSubset<T, CommunityPostFindUniqueArgs<ExtArgs>>): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CommunityPost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommunityPostFindUniqueOrThrowArgs} args - Arguments to find a CommunityPost
     * @example
     * // Get one CommunityPost
     * const communityPost = await prisma.communityPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunityPostFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunityPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommunityPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostFindFirstArgs} args - Arguments to find a CommunityPost
     * @example
     * // Get one CommunityPost
     * const communityPost = await prisma.communityPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunityPostFindFirstArgs>(args?: SelectSubset<T, CommunityPostFindFirstArgs<ExtArgs>>): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommunityPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostFindFirstOrThrowArgs} args - Arguments to find a CommunityPost
     * @example
     * // Get one CommunityPost
     * const communityPost = await prisma.communityPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunityPostFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunityPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommunityPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityPosts
     * const communityPosts = await prisma.communityPost.findMany()
     * 
     * // Get first 10 CommunityPosts
     * const communityPosts = await prisma.communityPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityPostWithIdOnly = await prisma.communityPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunityPostFindManyArgs>(args?: SelectSubset<T, CommunityPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CommunityPost.
     * @param {CommunityPostCreateArgs} args - Arguments to create a CommunityPost.
     * @example
     * // Create one CommunityPost
     * const CommunityPost = await prisma.communityPost.create({
     *   data: {
     *     // ... data to create a CommunityPost
     *   }
     * })
     * 
     */
    create<T extends CommunityPostCreateArgs>(args: SelectSubset<T, CommunityPostCreateArgs<ExtArgs>>): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CommunityPosts.
     * @param {CommunityPostCreateManyArgs} args - Arguments to create many CommunityPosts.
     * @example
     * // Create many CommunityPosts
     * const communityPost = await prisma.communityPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunityPostCreateManyArgs>(args?: SelectSubset<T, CommunityPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommunityPosts and returns the data saved in the database.
     * @param {CommunityPostCreateManyAndReturnArgs} args - Arguments to create many CommunityPosts.
     * @example
     * // Create many CommunityPosts
     * const communityPost = await prisma.communityPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommunityPosts and only return the `id`
     * const communityPostWithIdOnly = await prisma.communityPost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommunityPostCreateManyAndReturnArgs>(args?: SelectSubset<T, CommunityPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CommunityPost.
     * @param {CommunityPostDeleteArgs} args - Arguments to delete one CommunityPost.
     * @example
     * // Delete one CommunityPost
     * const CommunityPost = await prisma.communityPost.delete({
     *   where: {
     *     // ... filter to delete one CommunityPost
     *   }
     * })
     * 
     */
    delete<T extends CommunityPostDeleteArgs>(args: SelectSubset<T, CommunityPostDeleteArgs<ExtArgs>>): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CommunityPost.
     * @param {CommunityPostUpdateArgs} args - Arguments to update one CommunityPost.
     * @example
     * // Update one CommunityPost
     * const communityPost = await prisma.communityPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunityPostUpdateArgs>(args: SelectSubset<T, CommunityPostUpdateArgs<ExtArgs>>): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CommunityPosts.
     * @param {CommunityPostDeleteManyArgs} args - Arguments to filter CommunityPosts to delete.
     * @example
     * // Delete a few CommunityPosts
     * const { count } = await prisma.communityPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunityPostDeleteManyArgs>(args?: SelectSubset<T, CommunityPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityPosts
     * const communityPost = await prisma.communityPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunityPostUpdateManyArgs>(args: SelectSubset<T, CommunityPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityPosts and returns the data updated in the database.
     * @param {CommunityPostUpdateManyAndReturnArgs} args - Arguments to update many CommunityPosts.
     * @example
     * // Update many CommunityPosts
     * const communityPost = await prisma.communityPost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CommunityPosts and only return the `id`
     * const communityPostWithIdOnly = await prisma.communityPost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommunityPostUpdateManyAndReturnArgs>(args: SelectSubset<T, CommunityPostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CommunityPost.
     * @param {CommunityPostUpsertArgs} args - Arguments to update or create a CommunityPost.
     * @example
     * // Update or create a CommunityPost
     * const communityPost = await prisma.communityPost.upsert({
     *   create: {
     *     // ... data to create a CommunityPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityPost we want to update
     *   }
     * })
     */
    upsert<T extends CommunityPostUpsertArgs>(args: SelectSubset<T, CommunityPostUpsertArgs<ExtArgs>>): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CommunityPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostCountArgs} args - Arguments to filter CommunityPosts to count.
     * @example
     * // Count the number of CommunityPosts
     * const count = await prisma.communityPost.count({
     *   where: {
     *     // ... the filter for the CommunityPosts we want to count
     *   }
     * })
    **/
    count<T extends CommunityPostCountArgs>(
      args?: Subset<T, CommunityPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityPostAggregateArgs>(args: Subset<T, CommunityPostAggregateArgs>): Prisma.PrismaPromise<GetCommunityPostAggregateType<T>>

    /**
     * Group by CommunityPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityPostGroupByArgs['orderBy'] }
        : { orderBy?: CommunityPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommunityPost model
   */
  readonly fields: CommunityPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    community<T extends CommunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunityDefaultArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    votes<T extends CommunityPost$votesArgs<ExtArgs> = {}>(args?: Subset<T, CommunityPost$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends CommunityPost$commentsArgs<ExtArgs> = {}>(args?: Subset<T, CommunityPost$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommunityPost model
   */
  interface CommunityPostFieldRefs {
    readonly id: FieldRef<"CommunityPost", 'String'>
    readonly communityId: FieldRef<"CommunityPost", 'String'>
    readonly authorId: FieldRef<"CommunityPost", 'String'>
    readonly title: FieldRef<"CommunityPost", 'String'>
    readonly content: FieldRef<"CommunityPost", 'String'>
    readonly type: FieldRef<"CommunityPost", 'String'>
    readonly images: FieldRef<"CommunityPost", 'String[]'>
    readonly upvotes: FieldRef<"CommunityPost", 'Int'>
    readonly downvotes: FieldRef<"CommunityPost", 'Int'>
    readonly commentCount: FieldRef<"CommunityPost", 'Int'>
    readonly isPinned: FieldRef<"CommunityPost", 'Boolean'>
    readonly createdAt: FieldRef<"CommunityPost", 'DateTime'>
    readonly updatedAt: FieldRef<"CommunityPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommunityPost findUnique
   */
  export type CommunityPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityPost
     */
    omit?: CommunityPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityPostInclude<ExtArgs> | null
    /**
     * Filter, which CommunityPost to fetch.
     */
    where: CommunityPostWhereUniqueInput
  }

  /**
   * CommunityPost findUniqueOrThrow
   */
  export type CommunityPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityPost
     */
    omit?: CommunityPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityPostInclude<ExtArgs> | null
    /**
     * Filter, which CommunityPost to fetch.
     */
    where: CommunityPostWhereUniqueInput
  }

  /**
   * CommunityPost findFirst
   */
  export type CommunityPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityPost
     */
    omit?: CommunityPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityPostInclude<ExtArgs> | null
    /**
     * Filter, which CommunityPost to fetch.
     */
    where?: CommunityPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityPosts to fetch.
     */
    orderBy?: CommunityPostOrderByWithRelationInput | CommunityPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityPosts.
     */
    cursor?: CommunityPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityPosts.
     */
    distinct?: CommunityPostScalarFieldEnum | CommunityPostScalarFieldEnum[]
  }

  /**
   * CommunityPost findFirstOrThrow
   */
  export type CommunityPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityPost
     */
    omit?: CommunityPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityPostInclude<ExtArgs> | null
    /**
     * Filter, which CommunityPost to fetch.
     */
    where?: CommunityPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityPosts to fetch.
     */
    orderBy?: CommunityPostOrderByWithRelationInput | CommunityPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityPosts.
     */
    cursor?: CommunityPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityPosts.
     */
    distinct?: CommunityPostScalarFieldEnum | CommunityPostScalarFieldEnum[]
  }

  /**
   * CommunityPost findMany
   */
  export type CommunityPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityPost
     */
    omit?: CommunityPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityPostInclude<ExtArgs> | null
    /**
     * Filter, which CommunityPosts to fetch.
     */
    where?: CommunityPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityPosts to fetch.
     */
    orderBy?: CommunityPostOrderByWithRelationInput | CommunityPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityPosts.
     */
    cursor?: CommunityPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityPosts.
     */
    skip?: number
    distinct?: CommunityPostScalarFieldEnum | CommunityPostScalarFieldEnum[]
  }

  /**
   * CommunityPost create
   */
  export type CommunityPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityPost
     */
    omit?: CommunityPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityPostInclude<ExtArgs> | null
    /**
     * The data needed to create a CommunityPost.
     */
    data: XOR<CommunityPostCreateInput, CommunityPostUncheckedCreateInput>
  }

  /**
   * CommunityPost createMany
   */
  export type CommunityPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommunityPosts.
     */
    data: CommunityPostCreateManyInput | CommunityPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommunityPost createManyAndReturn
   */
  export type CommunityPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityPost
     */
    omit?: CommunityPostOmit<ExtArgs> | null
    /**
     * The data used to create many CommunityPosts.
     */
    data: CommunityPostCreateManyInput | CommunityPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommunityPost update
   */
  export type CommunityPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityPost
     */
    omit?: CommunityPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityPostInclude<ExtArgs> | null
    /**
     * The data needed to update a CommunityPost.
     */
    data: XOR<CommunityPostUpdateInput, CommunityPostUncheckedUpdateInput>
    /**
     * Choose, which CommunityPost to update.
     */
    where: CommunityPostWhereUniqueInput
  }

  /**
   * CommunityPost updateMany
   */
  export type CommunityPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommunityPosts.
     */
    data: XOR<CommunityPostUpdateManyMutationInput, CommunityPostUncheckedUpdateManyInput>
    /**
     * Filter which CommunityPosts to update
     */
    where?: CommunityPostWhereInput
    /**
     * Limit how many CommunityPosts to update.
     */
    limit?: number
  }

  /**
   * CommunityPost updateManyAndReturn
   */
  export type CommunityPostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityPost
     */
    omit?: CommunityPostOmit<ExtArgs> | null
    /**
     * The data used to update CommunityPosts.
     */
    data: XOR<CommunityPostUpdateManyMutationInput, CommunityPostUncheckedUpdateManyInput>
    /**
     * Filter which CommunityPosts to update
     */
    where?: CommunityPostWhereInput
    /**
     * Limit how many CommunityPosts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityPostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommunityPost upsert
   */
  export type CommunityPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityPost
     */
    omit?: CommunityPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityPostInclude<ExtArgs> | null
    /**
     * The filter to search for the CommunityPost to update in case it exists.
     */
    where: CommunityPostWhereUniqueInput
    /**
     * In case the CommunityPost found by the `where` argument doesn't exist, create a new CommunityPost with this data.
     */
    create: XOR<CommunityPostCreateInput, CommunityPostUncheckedCreateInput>
    /**
     * In case the CommunityPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityPostUpdateInput, CommunityPostUncheckedUpdateInput>
  }

  /**
   * CommunityPost delete
   */
  export type CommunityPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityPost
     */
    omit?: CommunityPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityPostInclude<ExtArgs> | null
    /**
     * Filter which CommunityPost to delete.
     */
    where: CommunityPostWhereUniqueInput
  }

  /**
   * CommunityPost deleteMany
   */
  export type CommunityPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityPosts to delete
     */
    where?: CommunityPostWhereInput
    /**
     * Limit how many CommunityPosts to delete.
     */
    limit?: number
  }

  /**
   * CommunityPost.votes
   */
  export type CommunityPost$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVote
     */
    select?: PostVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVote
     */
    omit?: PostVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVoteInclude<ExtArgs> | null
    where?: PostVoteWhereInput
    orderBy?: PostVoteOrderByWithRelationInput | PostVoteOrderByWithRelationInput[]
    cursor?: PostVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostVoteScalarFieldEnum | PostVoteScalarFieldEnum[]
  }

  /**
   * CommunityPost.comments
   */
  export type CommunityPost$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * CommunityPost without action
   */
  export type CommunityPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityPost
     */
    select?: CommunityPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityPost
     */
    omit?: CommunityPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityPostInclude<ExtArgs> | null
  }


  /**
   * Model PostVote
   */

  export type AggregatePostVote = {
    _count: PostVoteCountAggregateOutputType | null
    _min: PostVoteMinAggregateOutputType | null
    _max: PostVoteMaxAggregateOutputType | null
  }

  export type PostVoteMinAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    type: string | null
    createdAt: Date | null
  }

  export type PostVoteMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    userId: string | null
    type: string | null
    createdAt: Date | null
  }

  export type PostVoteCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    type: number
    createdAt: number
    _all: number
  }


  export type PostVoteMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    type?: true
    createdAt?: true
  }

  export type PostVoteMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    type?: true
    createdAt?: true
  }

  export type PostVoteCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type PostVoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostVote to aggregate.
     */
    where?: PostVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostVotes to fetch.
     */
    orderBy?: PostVoteOrderByWithRelationInput | PostVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostVotes
    **/
    _count?: true | PostVoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostVoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostVoteMaxAggregateInputType
  }

  export type GetPostVoteAggregateType<T extends PostVoteAggregateArgs> = {
        [P in keyof T & keyof AggregatePostVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostVote[P]>
      : GetScalarType<T[P], AggregatePostVote[P]>
  }




  export type PostVoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostVoteWhereInput
    orderBy?: PostVoteOrderByWithAggregationInput | PostVoteOrderByWithAggregationInput[]
    by: PostVoteScalarFieldEnum[] | PostVoteScalarFieldEnum
    having?: PostVoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostVoteCountAggregateInputType | true
    _min?: PostVoteMinAggregateInputType
    _max?: PostVoteMaxAggregateInputType
  }

  export type PostVoteGroupByOutputType = {
    id: string
    postId: string
    userId: string
    type: string
    createdAt: Date
    _count: PostVoteCountAggregateOutputType | null
    _min: PostVoteMinAggregateOutputType | null
    _max: PostVoteMaxAggregateOutputType | null
  }

  type GetPostVoteGroupByPayload<T extends PostVoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostVoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostVoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostVoteGroupByOutputType[P]>
            : GetScalarType<T[P], PostVoteGroupByOutputType[P]>
        }
      >
    >


  export type PostVoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
    post?: boolean | CommunityPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postVote"]>

  export type PostVoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
    post?: boolean | CommunityPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postVote"]>

  export type PostVoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
    post?: boolean | CommunityPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postVote"]>

  export type PostVoteSelectScalar = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type PostVoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "userId" | "type" | "createdAt", ExtArgs["result"]["postVote"]>
  export type PostVoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | CommunityPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PostVoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | CommunityPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PostVoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | CommunityPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PostVotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostVote"
    objects: {
      post: Prisma.$CommunityPostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      userId: string
      type: string
      createdAt: Date
    }, ExtArgs["result"]["postVote"]>
    composites: {}
  }

  type PostVoteGetPayload<S extends boolean | null | undefined | PostVoteDefaultArgs> = $Result.GetResult<Prisma.$PostVotePayload, S>

  type PostVoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostVoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostVoteCountAggregateInputType | true
    }

  export interface PostVoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostVote'], meta: { name: 'PostVote' } }
    /**
     * Find zero or one PostVote that matches the filter.
     * @param {PostVoteFindUniqueArgs} args - Arguments to find a PostVote
     * @example
     * // Get one PostVote
     * const postVote = await prisma.postVote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostVoteFindUniqueArgs>(args: SelectSubset<T, PostVoteFindUniqueArgs<ExtArgs>>): Prisma__PostVoteClient<$Result.GetResult<Prisma.$PostVotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostVote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostVoteFindUniqueOrThrowArgs} args - Arguments to find a PostVote
     * @example
     * // Get one PostVote
     * const postVote = await prisma.postVote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostVoteFindUniqueOrThrowArgs>(args: SelectSubset<T, PostVoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostVoteClient<$Result.GetResult<Prisma.$PostVotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostVote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostVoteFindFirstArgs} args - Arguments to find a PostVote
     * @example
     * // Get one PostVote
     * const postVote = await prisma.postVote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostVoteFindFirstArgs>(args?: SelectSubset<T, PostVoteFindFirstArgs<ExtArgs>>): Prisma__PostVoteClient<$Result.GetResult<Prisma.$PostVotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostVote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostVoteFindFirstOrThrowArgs} args - Arguments to find a PostVote
     * @example
     * // Get one PostVote
     * const postVote = await prisma.postVote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostVoteFindFirstOrThrowArgs>(args?: SelectSubset<T, PostVoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostVoteClient<$Result.GetResult<Prisma.$PostVotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostVotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostVoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostVotes
     * const postVotes = await prisma.postVote.findMany()
     * 
     * // Get first 10 PostVotes
     * const postVotes = await prisma.postVote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postVoteWithIdOnly = await prisma.postVote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostVoteFindManyArgs>(args?: SelectSubset<T, PostVoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostVote.
     * @param {PostVoteCreateArgs} args - Arguments to create a PostVote.
     * @example
     * // Create one PostVote
     * const PostVote = await prisma.postVote.create({
     *   data: {
     *     // ... data to create a PostVote
     *   }
     * })
     * 
     */
    create<T extends PostVoteCreateArgs>(args: SelectSubset<T, PostVoteCreateArgs<ExtArgs>>): Prisma__PostVoteClient<$Result.GetResult<Prisma.$PostVotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostVotes.
     * @param {PostVoteCreateManyArgs} args - Arguments to create many PostVotes.
     * @example
     * // Create many PostVotes
     * const postVote = await prisma.postVote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostVoteCreateManyArgs>(args?: SelectSubset<T, PostVoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostVotes and returns the data saved in the database.
     * @param {PostVoteCreateManyAndReturnArgs} args - Arguments to create many PostVotes.
     * @example
     * // Create many PostVotes
     * const postVote = await prisma.postVote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostVotes and only return the `id`
     * const postVoteWithIdOnly = await prisma.postVote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostVoteCreateManyAndReturnArgs>(args?: SelectSubset<T, PostVoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostVotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostVote.
     * @param {PostVoteDeleteArgs} args - Arguments to delete one PostVote.
     * @example
     * // Delete one PostVote
     * const PostVote = await prisma.postVote.delete({
     *   where: {
     *     // ... filter to delete one PostVote
     *   }
     * })
     * 
     */
    delete<T extends PostVoteDeleteArgs>(args: SelectSubset<T, PostVoteDeleteArgs<ExtArgs>>): Prisma__PostVoteClient<$Result.GetResult<Prisma.$PostVotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostVote.
     * @param {PostVoteUpdateArgs} args - Arguments to update one PostVote.
     * @example
     * // Update one PostVote
     * const postVote = await prisma.postVote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostVoteUpdateArgs>(args: SelectSubset<T, PostVoteUpdateArgs<ExtArgs>>): Prisma__PostVoteClient<$Result.GetResult<Prisma.$PostVotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostVotes.
     * @param {PostVoteDeleteManyArgs} args - Arguments to filter PostVotes to delete.
     * @example
     * // Delete a few PostVotes
     * const { count } = await prisma.postVote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostVoteDeleteManyArgs>(args?: SelectSubset<T, PostVoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostVoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostVotes
     * const postVote = await prisma.postVote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostVoteUpdateManyArgs>(args: SelectSubset<T, PostVoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostVotes and returns the data updated in the database.
     * @param {PostVoteUpdateManyAndReturnArgs} args - Arguments to update many PostVotes.
     * @example
     * // Update many PostVotes
     * const postVote = await prisma.postVote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostVotes and only return the `id`
     * const postVoteWithIdOnly = await prisma.postVote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostVoteUpdateManyAndReturnArgs>(args: SelectSubset<T, PostVoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostVotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostVote.
     * @param {PostVoteUpsertArgs} args - Arguments to update or create a PostVote.
     * @example
     * // Update or create a PostVote
     * const postVote = await prisma.postVote.upsert({
     *   create: {
     *     // ... data to create a PostVote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostVote we want to update
     *   }
     * })
     */
    upsert<T extends PostVoteUpsertArgs>(args: SelectSubset<T, PostVoteUpsertArgs<ExtArgs>>): Prisma__PostVoteClient<$Result.GetResult<Prisma.$PostVotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostVoteCountArgs} args - Arguments to filter PostVotes to count.
     * @example
     * // Count the number of PostVotes
     * const count = await prisma.postVote.count({
     *   where: {
     *     // ... the filter for the PostVotes we want to count
     *   }
     * })
    **/
    count<T extends PostVoteCountArgs>(
      args?: Subset<T, PostVoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostVoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostVoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostVoteAggregateArgs>(args: Subset<T, PostVoteAggregateArgs>): Prisma.PrismaPromise<GetPostVoteAggregateType<T>>

    /**
     * Group by PostVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostVoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostVoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostVoteGroupByArgs['orderBy'] }
        : { orderBy?: PostVoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostVoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostVoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostVote model
   */
  readonly fields: PostVoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostVote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostVoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends CommunityPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunityPostDefaultArgs<ExtArgs>>): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostVote model
   */
  interface PostVoteFieldRefs {
    readonly id: FieldRef<"PostVote", 'String'>
    readonly postId: FieldRef<"PostVote", 'String'>
    readonly userId: FieldRef<"PostVote", 'String'>
    readonly type: FieldRef<"PostVote", 'String'>
    readonly createdAt: FieldRef<"PostVote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostVote findUnique
   */
  export type PostVoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVote
     */
    select?: PostVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVote
     */
    omit?: PostVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVoteInclude<ExtArgs> | null
    /**
     * Filter, which PostVote to fetch.
     */
    where: PostVoteWhereUniqueInput
  }

  /**
   * PostVote findUniqueOrThrow
   */
  export type PostVoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVote
     */
    select?: PostVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVote
     */
    omit?: PostVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVoteInclude<ExtArgs> | null
    /**
     * Filter, which PostVote to fetch.
     */
    where: PostVoteWhereUniqueInput
  }

  /**
   * PostVote findFirst
   */
  export type PostVoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVote
     */
    select?: PostVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVote
     */
    omit?: PostVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVoteInclude<ExtArgs> | null
    /**
     * Filter, which PostVote to fetch.
     */
    where?: PostVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostVotes to fetch.
     */
    orderBy?: PostVoteOrderByWithRelationInput | PostVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostVotes.
     */
    cursor?: PostVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostVotes.
     */
    distinct?: PostVoteScalarFieldEnum | PostVoteScalarFieldEnum[]
  }

  /**
   * PostVote findFirstOrThrow
   */
  export type PostVoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVote
     */
    select?: PostVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVote
     */
    omit?: PostVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVoteInclude<ExtArgs> | null
    /**
     * Filter, which PostVote to fetch.
     */
    where?: PostVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostVotes to fetch.
     */
    orderBy?: PostVoteOrderByWithRelationInput | PostVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostVotes.
     */
    cursor?: PostVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostVotes.
     */
    distinct?: PostVoteScalarFieldEnum | PostVoteScalarFieldEnum[]
  }

  /**
   * PostVote findMany
   */
  export type PostVoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVote
     */
    select?: PostVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVote
     */
    omit?: PostVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVoteInclude<ExtArgs> | null
    /**
     * Filter, which PostVotes to fetch.
     */
    where?: PostVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostVotes to fetch.
     */
    orderBy?: PostVoteOrderByWithRelationInput | PostVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostVotes.
     */
    cursor?: PostVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostVotes.
     */
    skip?: number
    distinct?: PostVoteScalarFieldEnum | PostVoteScalarFieldEnum[]
  }

  /**
   * PostVote create
   */
  export type PostVoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVote
     */
    select?: PostVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVote
     */
    omit?: PostVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVoteInclude<ExtArgs> | null
    /**
     * The data needed to create a PostVote.
     */
    data: XOR<PostVoteCreateInput, PostVoteUncheckedCreateInput>
  }

  /**
   * PostVote createMany
   */
  export type PostVoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostVotes.
     */
    data: PostVoteCreateManyInput | PostVoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostVote createManyAndReturn
   */
  export type PostVoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVote
     */
    select?: PostVoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostVote
     */
    omit?: PostVoteOmit<ExtArgs> | null
    /**
     * The data used to create many PostVotes.
     */
    data: PostVoteCreateManyInput | PostVoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostVote update
   */
  export type PostVoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVote
     */
    select?: PostVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVote
     */
    omit?: PostVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVoteInclude<ExtArgs> | null
    /**
     * The data needed to update a PostVote.
     */
    data: XOR<PostVoteUpdateInput, PostVoteUncheckedUpdateInput>
    /**
     * Choose, which PostVote to update.
     */
    where: PostVoteWhereUniqueInput
  }

  /**
   * PostVote updateMany
   */
  export type PostVoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostVotes.
     */
    data: XOR<PostVoteUpdateManyMutationInput, PostVoteUncheckedUpdateManyInput>
    /**
     * Filter which PostVotes to update
     */
    where?: PostVoteWhereInput
    /**
     * Limit how many PostVotes to update.
     */
    limit?: number
  }

  /**
   * PostVote updateManyAndReturn
   */
  export type PostVoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVote
     */
    select?: PostVoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostVote
     */
    omit?: PostVoteOmit<ExtArgs> | null
    /**
     * The data used to update PostVotes.
     */
    data: XOR<PostVoteUpdateManyMutationInput, PostVoteUncheckedUpdateManyInput>
    /**
     * Filter which PostVotes to update
     */
    where?: PostVoteWhereInput
    /**
     * Limit how many PostVotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostVote upsert
   */
  export type PostVoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVote
     */
    select?: PostVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVote
     */
    omit?: PostVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVoteInclude<ExtArgs> | null
    /**
     * The filter to search for the PostVote to update in case it exists.
     */
    where: PostVoteWhereUniqueInput
    /**
     * In case the PostVote found by the `where` argument doesn't exist, create a new PostVote with this data.
     */
    create: XOR<PostVoteCreateInput, PostVoteUncheckedCreateInput>
    /**
     * In case the PostVote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostVoteUpdateInput, PostVoteUncheckedUpdateInput>
  }

  /**
   * PostVote delete
   */
  export type PostVoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVote
     */
    select?: PostVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVote
     */
    omit?: PostVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVoteInclude<ExtArgs> | null
    /**
     * Filter which PostVote to delete.
     */
    where: PostVoteWhereUniqueInput
  }

  /**
   * PostVote deleteMany
   */
  export type PostVoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostVotes to delete
     */
    where?: PostVoteWhereInput
    /**
     * Limit how many PostVotes to delete.
     */
    limit?: number
  }

  /**
   * PostVote without action
   */
  export type PostVoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostVote
     */
    select?: PostVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostVote
     */
    omit?: PostVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostVoteInclude<ExtArgs> | null
  }


  /**
   * Model CommunityMember
   */

  export type AggregateCommunityMember = {
    _count: CommunityMemberCountAggregateOutputType | null
    _avg: CommunityMemberAvgAggregateOutputType | null
    _sum: CommunityMemberSumAggregateOutputType | null
    _min: CommunityMemberMinAggregateOutputType | null
    _max: CommunityMemberMaxAggregateOutputType | null
  }

  export type CommunityMemberAvgAggregateOutputType = {
    reputationPoints: number | null
    votingPower: number | null
  }

  export type CommunityMemberSumAggregateOutputType = {
    reputationPoints: number | null
    votingPower: number | null
  }

  export type CommunityMemberMinAggregateOutputType = {
    id: string | null
    userId: string | null
    communityId: string | null
    role: string | null
    reputationPoints: number | null
    votingPower: number | null
    isActive: boolean | null
    joinedAt: Date | null
  }

  export type CommunityMemberMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    communityId: string | null
    role: string | null
    reputationPoints: number | null
    votingPower: number | null
    isActive: boolean | null
    joinedAt: Date | null
  }

  export type CommunityMemberCountAggregateOutputType = {
    id: number
    userId: number
    communityId: number
    role: number
    reputationPoints: number
    votingPower: number
    isActive: number
    joinedAt: number
    _all: number
  }


  export type CommunityMemberAvgAggregateInputType = {
    reputationPoints?: true
    votingPower?: true
  }

  export type CommunityMemberSumAggregateInputType = {
    reputationPoints?: true
    votingPower?: true
  }

  export type CommunityMemberMinAggregateInputType = {
    id?: true
    userId?: true
    communityId?: true
    role?: true
    reputationPoints?: true
    votingPower?: true
    isActive?: true
    joinedAt?: true
  }

  export type CommunityMemberMaxAggregateInputType = {
    id?: true
    userId?: true
    communityId?: true
    role?: true
    reputationPoints?: true
    votingPower?: true
    isActive?: true
    joinedAt?: true
  }

  export type CommunityMemberCountAggregateInputType = {
    id?: true
    userId?: true
    communityId?: true
    role?: true
    reputationPoints?: true
    votingPower?: true
    isActive?: true
    joinedAt?: true
    _all?: true
  }

  export type CommunityMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityMember to aggregate.
     */
    where?: CommunityMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityMembers to fetch.
     */
    orderBy?: CommunityMemberOrderByWithRelationInput | CommunityMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommunityMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommunityMembers
    **/
    _count?: true | CommunityMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommunityMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommunityMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommunityMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommunityMemberMaxAggregateInputType
  }

  export type GetCommunityMemberAggregateType<T extends CommunityMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateCommunityMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityMember[P]>
      : GetScalarType<T[P], AggregateCommunityMember[P]>
  }




  export type CommunityMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommunityMemberWhereInput
    orderBy?: CommunityMemberOrderByWithAggregationInput | CommunityMemberOrderByWithAggregationInput[]
    by: CommunityMemberScalarFieldEnum[] | CommunityMemberScalarFieldEnum
    having?: CommunityMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommunityMemberCountAggregateInputType | true
    _avg?: CommunityMemberAvgAggregateInputType
    _sum?: CommunityMemberSumAggregateInputType
    _min?: CommunityMemberMinAggregateInputType
    _max?: CommunityMemberMaxAggregateInputType
  }

  export type CommunityMemberGroupByOutputType = {
    id: string
    userId: string
    communityId: string
    role: string
    reputationPoints: number
    votingPower: number
    isActive: boolean
    joinedAt: Date
    _count: CommunityMemberCountAggregateOutputType | null
    _avg: CommunityMemberAvgAggregateOutputType | null
    _sum: CommunityMemberSumAggregateOutputType | null
    _min: CommunityMemberMinAggregateOutputType | null
    _max: CommunityMemberMaxAggregateOutputType | null
  }

  type GetCommunityMemberGroupByPayload<T extends CommunityMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommunityMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommunityMemberGroupByOutputType[P]>
            : GetScalarType<T[P], CommunityMemberGroupByOutputType[P]>
        }
      >
    >


  export type CommunityMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    communityId?: boolean
    role?: boolean
    reputationPoints?: boolean
    votingPower?: boolean
    isActive?: boolean
    joinedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    community?: boolean | CommunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communityMember"]>

  export type CommunityMemberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    communityId?: boolean
    role?: boolean
    reputationPoints?: boolean
    votingPower?: boolean
    isActive?: boolean
    joinedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    community?: boolean | CommunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communityMember"]>

  export type CommunityMemberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    communityId?: boolean
    role?: boolean
    reputationPoints?: boolean
    votingPower?: boolean
    isActive?: boolean
    joinedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    community?: boolean | CommunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["communityMember"]>

  export type CommunityMemberSelectScalar = {
    id?: boolean
    userId?: boolean
    communityId?: boolean
    role?: boolean
    reputationPoints?: boolean
    votingPower?: boolean
    isActive?: boolean
    joinedAt?: boolean
  }

  export type CommunityMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "communityId" | "role" | "reputationPoints" | "votingPower" | "isActive" | "joinedAt", ExtArgs["result"]["communityMember"]>
  export type CommunityMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    community?: boolean | CommunityDefaultArgs<ExtArgs>
  }
  export type CommunityMemberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    community?: boolean | CommunityDefaultArgs<ExtArgs>
  }
  export type CommunityMemberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    community?: boolean | CommunityDefaultArgs<ExtArgs>
  }

  export type $CommunityMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommunityMember"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      community: Prisma.$CommunityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      communityId: string
      role: string
      reputationPoints: number
      votingPower: number
      isActive: boolean
      joinedAt: Date
    }, ExtArgs["result"]["communityMember"]>
    composites: {}
  }

  type CommunityMemberGetPayload<S extends boolean | null | undefined | CommunityMemberDefaultArgs> = $Result.GetResult<Prisma.$CommunityMemberPayload, S>

  type CommunityMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommunityMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommunityMemberCountAggregateInputType | true
    }

  export interface CommunityMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommunityMember'], meta: { name: 'CommunityMember' } }
    /**
     * Find zero or one CommunityMember that matches the filter.
     * @param {CommunityMemberFindUniqueArgs} args - Arguments to find a CommunityMember
     * @example
     * // Get one CommunityMember
     * const communityMember = await prisma.communityMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunityMemberFindUniqueArgs>(args: SelectSubset<T, CommunityMemberFindUniqueArgs<ExtArgs>>): Prisma__CommunityMemberClient<$Result.GetResult<Prisma.$CommunityMemberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CommunityMember that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommunityMemberFindUniqueOrThrowArgs} args - Arguments to find a CommunityMember
     * @example
     * // Get one CommunityMember
     * const communityMember = await prisma.communityMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunityMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, CommunityMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommunityMemberClient<$Result.GetResult<Prisma.$CommunityMemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommunityMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityMemberFindFirstArgs} args - Arguments to find a CommunityMember
     * @example
     * // Get one CommunityMember
     * const communityMember = await prisma.communityMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunityMemberFindFirstArgs>(args?: SelectSubset<T, CommunityMemberFindFirstArgs<ExtArgs>>): Prisma__CommunityMemberClient<$Result.GetResult<Prisma.$CommunityMemberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommunityMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityMemberFindFirstOrThrowArgs} args - Arguments to find a CommunityMember
     * @example
     * // Get one CommunityMember
     * const communityMember = await prisma.communityMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunityMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, CommunityMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommunityMemberClient<$Result.GetResult<Prisma.$CommunityMemberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommunityMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityMembers
     * const communityMembers = await prisma.communityMember.findMany()
     * 
     * // Get first 10 CommunityMembers
     * const communityMembers = await prisma.communityMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const communityMemberWithIdOnly = await prisma.communityMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommunityMemberFindManyArgs>(args?: SelectSubset<T, CommunityMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityMemberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CommunityMember.
     * @param {CommunityMemberCreateArgs} args - Arguments to create a CommunityMember.
     * @example
     * // Create one CommunityMember
     * const CommunityMember = await prisma.communityMember.create({
     *   data: {
     *     // ... data to create a CommunityMember
     *   }
     * })
     * 
     */
    create<T extends CommunityMemberCreateArgs>(args: SelectSubset<T, CommunityMemberCreateArgs<ExtArgs>>): Prisma__CommunityMemberClient<$Result.GetResult<Prisma.$CommunityMemberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CommunityMembers.
     * @param {CommunityMemberCreateManyArgs} args - Arguments to create many CommunityMembers.
     * @example
     * // Create many CommunityMembers
     * const communityMember = await prisma.communityMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommunityMemberCreateManyArgs>(args?: SelectSubset<T, CommunityMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommunityMembers and returns the data saved in the database.
     * @param {CommunityMemberCreateManyAndReturnArgs} args - Arguments to create many CommunityMembers.
     * @example
     * // Create many CommunityMembers
     * const communityMember = await prisma.communityMember.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommunityMembers and only return the `id`
     * const communityMemberWithIdOnly = await prisma.communityMember.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommunityMemberCreateManyAndReturnArgs>(args?: SelectSubset<T, CommunityMemberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityMemberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CommunityMember.
     * @param {CommunityMemberDeleteArgs} args - Arguments to delete one CommunityMember.
     * @example
     * // Delete one CommunityMember
     * const CommunityMember = await prisma.communityMember.delete({
     *   where: {
     *     // ... filter to delete one CommunityMember
     *   }
     * })
     * 
     */
    delete<T extends CommunityMemberDeleteArgs>(args: SelectSubset<T, CommunityMemberDeleteArgs<ExtArgs>>): Prisma__CommunityMemberClient<$Result.GetResult<Prisma.$CommunityMemberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CommunityMember.
     * @param {CommunityMemberUpdateArgs} args - Arguments to update one CommunityMember.
     * @example
     * // Update one CommunityMember
     * const communityMember = await prisma.communityMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommunityMemberUpdateArgs>(args: SelectSubset<T, CommunityMemberUpdateArgs<ExtArgs>>): Prisma__CommunityMemberClient<$Result.GetResult<Prisma.$CommunityMemberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CommunityMembers.
     * @param {CommunityMemberDeleteManyArgs} args - Arguments to filter CommunityMembers to delete.
     * @example
     * // Delete a few CommunityMembers
     * const { count } = await prisma.communityMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommunityMemberDeleteManyArgs>(args?: SelectSubset<T, CommunityMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityMembers
     * const communityMember = await prisma.communityMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommunityMemberUpdateManyArgs>(args: SelectSubset<T, CommunityMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommunityMembers and returns the data updated in the database.
     * @param {CommunityMemberUpdateManyAndReturnArgs} args - Arguments to update many CommunityMembers.
     * @example
     * // Update many CommunityMembers
     * const communityMember = await prisma.communityMember.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CommunityMembers and only return the `id`
     * const communityMemberWithIdOnly = await prisma.communityMember.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommunityMemberUpdateManyAndReturnArgs>(args: SelectSubset<T, CommunityMemberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommunityMemberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CommunityMember.
     * @param {CommunityMemberUpsertArgs} args - Arguments to update or create a CommunityMember.
     * @example
     * // Update or create a CommunityMember
     * const communityMember = await prisma.communityMember.upsert({
     *   create: {
     *     // ... data to create a CommunityMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityMember we want to update
     *   }
     * })
     */
    upsert<T extends CommunityMemberUpsertArgs>(args: SelectSubset<T, CommunityMemberUpsertArgs<ExtArgs>>): Prisma__CommunityMemberClient<$Result.GetResult<Prisma.$CommunityMemberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CommunityMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityMemberCountArgs} args - Arguments to filter CommunityMembers to count.
     * @example
     * // Count the number of CommunityMembers
     * const count = await prisma.communityMember.count({
     *   where: {
     *     // ... the filter for the CommunityMembers we want to count
     *   }
     * })
    **/
    count<T extends CommunityMemberCountArgs>(
      args?: Subset<T, CommunityMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommunityMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommunityMemberAggregateArgs>(args: Subset<T, CommunityMemberAggregateArgs>): Prisma.PrismaPromise<GetCommunityMemberAggregateType<T>>

    /**
     * Group by CommunityMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommunityMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityMemberGroupByArgs['orderBy'] }
        : { orderBy?: CommunityMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommunityMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommunityMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommunityMember model
   */
  readonly fields: CommunityMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    community<T extends CommunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunityDefaultArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommunityMember model
   */
  interface CommunityMemberFieldRefs {
    readonly id: FieldRef<"CommunityMember", 'String'>
    readonly userId: FieldRef<"CommunityMember", 'String'>
    readonly communityId: FieldRef<"CommunityMember", 'String'>
    readonly role: FieldRef<"CommunityMember", 'String'>
    readonly reputationPoints: FieldRef<"CommunityMember", 'Int'>
    readonly votingPower: FieldRef<"CommunityMember", 'Int'>
    readonly isActive: FieldRef<"CommunityMember", 'Boolean'>
    readonly joinedAt: FieldRef<"CommunityMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommunityMember findUnique
   */
  export type CommunityMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberInclude<ExtArgs> | null
    /**
     * Filter, which CommunityMember to fetch.
     */
    where: CommunityMemberWhereUniqueInput
  }

  /**
   * CommunityMember findUniqueOrThrow
   */
  export type CommunityMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberInclude<ExtArgs> | null
    /**
     * Filter, which CommunityMember to fetch.
     */
    where: CommunityMemberWhereUniqueInput
  }

  /**
   * CommunityMember findFirst
   */
  export type CommunityMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberInclude<ExtArgs> | null
    /**
     * Filter, which CommunityMember to fetch.
     */
    where?: CommunityMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityMembers to fetch.
     */
    orderBy?: CommunityMemberOrderByWithRelationInput | CommunityMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityMembers.
     */
    cursor?: CommunityMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityMembers.
     */
    distinct?: CommunityMemberScalarFieldEnum | CommunityMemberScalarFieldEnum[]
  }

  /**
   * CommunityMember findFirstOrThrow
   */
  export type CommunityMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberInclude<ExtArgs> | null
    /**
     * Filter, which CommunityMember to fetch.
     */
    where?: CommunityMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityMembers to fetch.
     */
    orderBy?: CommunityMemberOrderByWithRelationInput | CommunityMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommunityMembers.
     */
    cursor?: CommunityMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommunityMembers.
     */
    distinct?: CommunityMemberScalarFieldEnum | CommunityMemberScalarFieldEnum[]
  }

  /**
   * CommunityMember findMany
   */
  export type CommunityMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberInclude<ExtArgs> | null
    /**
     * Filter, which CommunityMembers to fetch.
     */
    where?: CommunityMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommunityMembers to fetch.
     */
    orderBy?: CommunityMemberOrderByWithRelationInput | CommunityMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommunityMembers.
     */
    cursor?: CommunityMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommunityMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommunityMembers.
     */
    skip?: number
    distinct?: CommunityMemberScalarFieldEnum | CommunityMemberScalarFieldEnum[]
  }

  /**
   * CommunityMember create
   */
  export type CommunityMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a CommunityMember.
     */
    data: XOR<CommunityMemberCreateInput, CommunityMemberUncheckedCreateInput>
  }

  /**
   * CommunityMember createMany
   */
  export type CommunityMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommunityMembers.
     */
    data: CommunityMemberCreateManyInput | CommunityMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommunityMember createManyAndReturn
   */
  export type CommunityMemberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * The data used to create many CommunityMembers.
     */
    data: CommunityMemberCreateManyInput | CommunityMemberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommunityMember update
   */
  export type CommunityMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a CommunityMember.
     */
    data: XOR<CommunityMemberUpdateInput, CommunityMemberUncheckedUpdateInput>
    /**
     * Choose, which CommunityMember to update.
     */
    where: CommunityMemberWhereUniqueInput
  }

  /**
   * CommunityMember updateMany
   */
  export type CommunityMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommunityMembers.
     */
    data: XOR<CommunityMemberUpdateManyMutationInput, CommunityMemberUncheckedUpdateManyInput>
    /**
     * Filter which CommunityMembers to update
     */
    where?: CommunityMemberWhereInput
    /**
     * Limit how many CommunityMembers to update.
     */
    limit?: number
  }

  /**
   * CommunityMember updateManyAndReturn
   */
  export type CommunityMemberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * The data used to update CommunityMembers.
     */
    data: XOR<CommunityMemberUpdateManyMutationInput, CommunityMemberUncheckedUpdateManyInput>
    /**
     * Filter which CommunityMembers to update
     */
    where?: CommunityMemberWhereInput
    /**
     * Limit how many CommunityMembers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommunityMember upsert
   */
  export type CommunityMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the CommunityMember to update in case it exists.
     */
    where: CommunityMemberWhereUniqueInput
    /**
     * In case the CommunityMember found by the `where` argument doesn't exist, create a new CommunityMember with this data.
     */
    create: XOR<CommunityMemberCreateInput, CommunityMemberUncheckedCreateInput>
    /**
     * In case the CommunityMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommunityMemberUpdateInput, CommunityMemberUncheckedUpdateInput>
  }

  /**
   * CommunityMember delete
   */
  export type CommunityMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberInclude<ExtArgs> | null
    /**
     * Filter which CommunityMember to delete.
     */
    where: CommunityMemberWhereUniqueInput
  }

  /**
   * CommunityMember deleteMany
   */
  export type CommunityMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommunityMembers to delete
     */
    where?: CommunityMemberWhereInput
    /**
     * Limit how many CommunityMembers to delete.
     */
    limit?: number
  }

  /**
   * CommunityMember without action
   */
  export type CommunityMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommunityMember
     */
    select?: CommunityMemberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommunityMember
     */
    omit?: CommunityMemberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityMemberInclude<ExtArgs> | null
  }


  /**
   * Model GovernanceProposal
   */

  export type AggregateGovernanceProposal = {
    _count: GovernanceProposalCountAggregateOutputType | null
    _avg: GovernanceProposalAvgAggregateOutputType | null
    _sum: GovernanceProposalSumAggregateOutputType | null
    _min: GovernanceProposalMinAggregateOutputType | null
    _max: GovernanceProposalMaxAggregateOutputType | null
  }

  export type GovernanceProposalAvgAggregateOutputType = {
    quorumRequired: number | null
    totalVotes: number | null
  }

  export type GovernanceProposalSumAggregateOutputType = {
    quorumRequired: number | null
    totalVotes: number | null
  }

  export type GovernanceProposalMinAggregateOutputType = {
    id: string | null
    communityId: string | null
    proposerId: string | null
    title: string | null
    description: string | null
    type: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    quorumRequired: number | null
    totalVotes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GovernanceProposalMaxAggregateOutputType = {
    id: string | null
    communityId: string | null
    proposerId: string | null
    title: string | null
    description: string | null
    type: string | null
    status: string | null
    startDate: Date | null
    endDate: Date | null
    quorumRequired: number | null
    totalVotes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GovernanceProposalCountAggregateOutputType = {
    id: number
    communityId: number
    proposerId: number
    title: number
    description: number
    type: number
    status: number
    startDate: number
    endDate: number
    quorumRequired: number
    totalVotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GovernanceProposalAvgAggregateInputType = {
    quorumRequired?: true
    totalVotes?: true
  }

  export type GovernanceProposalSumAggregateInputType = {
    quorumRequired?: true
    totalVotes?: true
  }

  export type GovernanceProposalMinAggregateInputType = {
    id?: true
    communityId?: true
    proposerId?: true
    title?: true
    description?: true
    type?: true
    status?: true
    startDate?: true
    endDate?: true
    quorumRequired?: true
    totalVotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GovernanceProposalMaxAggregateInputType = {
    id?: true
    communityId?: true
    proposerId?: true
    title?: true
    description?: true
    type?: true
    status?: true
    startDate?: true
    endDate?: true
    quorumRequired?: true
    totalVotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GovernanceProposalCountAggregateInputType = {
    id?: true
    communityId?: true
    proposerId?: true
    title?: true
    description?: true
    type?: true
    status?: true
    startDate?: true
    endDate?: true
    quorumRequired?: true
    totalVotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GovernanceProposalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GovernanceProposal to aggregate.
     */
    where?: GovernanceProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GovernanceProposals to fetch.
     */
    orderBy?: GovernanceProposalOrderByWithRelationInput | GovernanceProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GovernanceProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GovernanceProposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GovernanceProposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GovernanceProposals
    **/
    _count?: true | GovernanceProposalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GovernanceProposalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GovernanceProposalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GovernanceProposalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GovernanceProposalMaxAggregateInputType
  }

  export type GetGovernanceProposalAggregateType<T extends GovernanceProposalAggregateArgs> = {
        [P in keyof T & keyof AggregateGovernanceProposal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGovernanceProposal[P]>
      : GetScalarType<T[P], AggregateGovernanceProposal[P]>
  }




  export type GovernanceProposalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GovernanceProposalWhereInput
    orderBy?: GovernanceProposalOrderByWithAggregationInput | GovernanceProposalOrderByWithAggregationInput[]
    by: GovernanceProposalScalarFieldEnum[] | GovernanceProposalScalarFieldEnum
    having?: GovernanceProposalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GovernanceProposalCountAggregateInputType | true
    _avg?: GovernanceProposalAvgAggregateInputType
    _sum?: GovernanceProposalSumAggregateInputType
    _min?: GovernanceProposalMinAggregateInputType
    _max?: GovernanceProposalMaxAggregateInputType
  }

  export type GovernanceProposalGroupByOutputType = {
    id: string
    communityId: string
    proposerId: string
    title: string
    description: string
    type: string
    status: string
    startDate: Date
    endDate: Date
    quorumRequired: number
    totalVotes: number
    createdAt: Date
    updatedAt: Date
    _count: GovernanceProposalCountAggregateOutputType | null
    _avg: GovernanceProposalAvgAggregateOutputType | null
    _sum: GovernanceProposalSumAggregateOutputType | null
    _min: GovernanceProposalMinAggregateOutputType | null
    _max: GovernanceProposalMaxAggregateOutputType | null
  }

  type GetGovernanceProposalGroupByPayload<T extends GovernanceProposalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GovernanceProposalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GovernanceProposalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GovernanceProposalGroupByOutputType[P]>
            : GetScalarType<T[P], GovernanceProposalGroupByOutputType[P]>
        }
      >
    >


  export type GovernanceProposalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    communityId?: boolean
    proposerId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    quorumRequired?: boolean
    totalVotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    options?: boolean | GovernanceProposal$optionsArgs<ExtArgs>
    _count?: boolean | GovernanceProposalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["governanceProposal"]>

  export type GovernanceProposalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    communityId?: boolean
    proposerId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    quorumRequired?: boolean
    totalVotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    community?: boolean | CommunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["governanceProposal"]>

  export type GovernanceProposalSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    communityId?: boolean
    proposerId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    quorumRequired?: boolean
    totalVotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    community?: boolean | CommunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["governanceProposal"]>

  export type GovernanceProposalSelectScalar = {
    id?: boolean
    communityId?: boolean
    proposerId?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    quorumRequired?: boolean
    totalVotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GovernanceProposalOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "communityId" | "proposerId" | "title" | "description" | "type" | "status" | "startDate" | "endDate" | "quorumRequired" | "totalVotes" | "createdAt" | "updatedAt", ExtArgs["result"]["governanceProposal"]>
  export type GovernanceProposalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    community?: boolean | CommunityDefaultArgs<ExtArgs>
    options?: boolean | GovernanceProposal$optionsArgs<ExtArgs>
    _count?: boolean | GovernanceProposalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type GovernanceProposalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    community?: boolean | CommunityDefaultArgs<ExtArgs>
  }
  export type GovernanceProposalIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    community?: boolean | CommunityDefaultArgs<ExtArgs>
  }

  export type $GovernanceProposalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GovernanceProposal"
    objects: {
      community: Prisma.$CommunityPayload<ExtArgs>
      options: Prisma.$ProposalOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      communityId: string
      proposerId: string
      title: string
      description: string
      type: string
      status: string
      startDate: Date
      endDate: Date
      quorumRequired: number
      totalVotes: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["governanceProposal"]>
    composites: {}
  }

  type GovernanceProposalGetPayload<S extends boolean | null | undefined | GovernanceProposalDefaultArgs> = $Result.GetResult<Prisma.$GovernanceProposalPayload, S>

  type GovernanceProposalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GovernanceProposalFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GovernanceProposalCountAggregateInputType | true
    }

  export interface GovernanceProposalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GovernanceProposal'], meta: { name: 'GovernanceProposal' } }
    /**
     * Find zero or one GovernanceProposal that matches the filter.
     * @param {GovernanceProposalFindUniqueArgs} args - Arguments to find a GovernanceProposal
     * @example
     * // Get one GovernanceProposal
     * const governanceProposal = await prisma.governanceProposal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GovernanceProposalFindUniqueArgs>(args: SelectSubset<T, GovernanceProposalFindUniqueArgs<ExtArgs>>): Prisma__GovernanceProposalClient<$Result.GetResult<Prisma.$GovernanceProposalPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GovernanceProposal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GovernanceProposalFindUniqueOrThrowArgs} args - Arguments to find a GovernanceProposal
     * @example
     * // Get one GovernanceProposal
     * const governanceProposal = await prisma.governanceProposal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GovernanceProposalFindUniqueOrThrowArgs>(args: SelectSubset<T, GovernanceProposalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GovernanceProposalClient<$Result.GetResult<Prisma.$GovernanceProposalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GovernanceProposal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernanceProposalFindFirstArgs} args - Arguments to find a GovernanceProposal
     * @example
     * // Get one GovernanceProposal
     * const governanceProposal = await prisma.governanceProposal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GovernanceProposalFindFirstArgs>(args?: SelectSubset<T, GovernanceProposalFindFirstArgs<ExtArgs>>): Prisma__GovernanceProposalClient<$Result.GetResult<Prisma.$GovernanceProposalPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GovernanceProposal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernanceProposalFindFirstOrThrowArgs} args - Arguments to find a GovernanceProposal
     * @example
     * // Get one GovernanceProposal
     * const governanceProposal = await prisma.governanceProposal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GovernanceProposalFindFirstOrThrowArgs>(args?: SelectSubset<T, GovernanceProposalFindFirstOrThrowArgs<ExtArgs>>): Prisma__GovernanceProposalClient<$Result.GetResult<Prisma.$GovernanceProposalPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GovernanceProposals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernanceProposalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GovernanceProposals
     * const governanceProposals = await prisma.governanceProposal.findMany()
     * 
     * // Get first 10 GovernanceProposals
     * const governanceProposals = await prisma.governanceProposal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const governanceProposalWithIdOnly = await prisma.governanceProposal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GovernanceProposalFindManyArgs>(args?: SelectSubset<T, GovernanceProposalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GovernanceProposalPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GovernanceProposal.
     * @param {GovernanceProposalCreateArgs} args - Arguments to create a GovernanceProposal.
     * @example
     * // Create one GovernanceProposal
     * const GovernanceProposal = await prisma.governanceProposal.create({
     *   data: {
     *     // ... data to create a GovernanceProposal
     *   }
     * })
     * 
     */
    create<T extends GovernanceProposalCreateArgs>(args: SelectSubset<T, GovernanceProposalCreateArgs<ExtArgs>>): Prisma__GovernanceProposalClient<$Result.GetResult<Prisma.$GovernanceProposalPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GovernanceProposals.
     * @param {GovernanceProposalCreateManyArgs} args - Arguments to create many GovernanceProposals.
     * @example
     * // Create many GovernanceProposals
     * const governanceProposal = await prisma.governanceProposal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GovernanceProposalCreateManyArgs>(args?: SelectSubset<T, GovernanceProposalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GovernanceProposals and returns the data saved in the database.
     * @param {GovernanceProposalCreateManyAndReturnArgs} args - Arguments to create many GovernanceProposals.
     * @example
     * // Create many GovernanceProposals
     * const governanceProposal = await prisma.governanceProposal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GovernanceProposals and only return the `id`
     * const governanceProposalWithIdOnly = await prisma.governanceProposal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GovernanceProposalCreateManyAndReturnArgs>(args?: SelectSubset<T, GovernanceProposalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GovernanceProposalPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GovernanceProposal.
     * @param {GovernanceProposalDeleteArgs} args - Arguments to delete one GovernanceProposal.
     * @example
     * // Delete one GovernanceProposal
     * const GovernanceProposal = await prisma.governanceProposal.delete({
     *   where: {
     *     // ... filter to delete one GovernanceProposal
     *   }
     * })
     * 
     */
    delete<T extends GovernanceProposalDeleteArgs>(args: SelectSubset<T, GovernanceProposalDeleteArgs<ExtArgs>>): Prisma__GovernanceProposalClient<$Result.GetResult<Prisma.$GovernanceProposalPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GovernanceProposal.
     * @param {GovernanceProposalUpdateArgs} args - Arguments to update one GovernanceProposal.
     * @example
     * // Update one GovernanceProposal
     * const governanceProposal = await prisma.governanceProposal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GovernanceProposalUpdateArgs>(args: SelectSubset<T, GovernanceProposalUpdateArgs<ExtArgs>>): Prisma__GovernanceProposalClient<$Result.GetResult<Prisma.$GovernanceProposalPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GovernanceProposals.
     * @param {GovernanceProposalDeleteManyArgs} args - Arguments to filter GovernanceProposals to delete.
     * @example
     * // Delete a few GovernanceProposals
     * const { count } = await prisma.governanceProposal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GovernanceProposalDeleteManyArgs>(args?: SelectSubset<T, GovernanceProposalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GovernanceProposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernanceProposalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GovernanceProposals
     * const governanceProposal = await prisma.governanceProposal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GovernanceProposalUpdateManyArgs>(args: SelectSubset<T, GovernanceProposalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GovernanceProposals and returns the data updated in the database.
     * @param {GovernanceProposalUpdateManyAndReturnArgs} args - Arguments to update many GovernanceProposals.
     * @example
     * // Update many GovernanceProposals
     * const governanceProposal = await prisma.governanceProposal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GovernanceProposals and only return the `id`
     * const governanceProposalWithIdOnly = await prisma.governanceProposal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GovernanceProposalUpdateManyAndReturnArgs>(args: SelectSubset<T, GovernanceProposalUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GovernanceProposalPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GovernanceProposal.
     * @param {GovernanceProposalUpsertArgs} args - Arguments to update or create a GovernanceProposal.
     * @example
     * // Update or create a GovernanceProposal
     * const governanceProposal = await prisma.governanceProposal.upsert({
     *   create: {
     *     // ... data to create a GovernanceProposal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GovernanceProposal we want to update
     *   }
     * })
     */
    upsert<T extends GovernanceProposalUpsertArgs>(args: SelectSubset<T, GovernanceProposalUpsertArgs<ExtArgs>>): Prisma__GovernanceProposalClient<$Result.GetResult<Prisma.$GovernanceProposalPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GovernanceProposals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernanceProposalCountArgs} args - Arguments to filter GovernanceProposals to count.
     * @example
     * // Count the number of GovernanceProposals
     * const count = await prisma.governanceProposal.count({
     *   where: {
     *     // ... the filter for the GovernanceProposals we want to count
     *   }
     * })
    **/
    count<T extends GovernanceProposalCountArgs>(
      args?: Subset<T, GovernanceProposalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GovernanceProposalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GovernanceProposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernanceProposalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GovernanceProposalAggregateArgs>(args: Subset<T, GovernanceProposalAggregateArgs>): Prisma.PrismaPromise<GetGovernanceProposalAggregateType<T>>

    /**
     * Group by GovernanceProposal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernanceProposalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GovernanceProposalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GovernanceProposalGroupByArgs['orderBy'] }
        : { orderBy?: GovernanceProposalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GovernanceProposalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGovernanceProposalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GovernanceProposal model
   */
  readonly fields: GovernanceProposalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GovernanceProposal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GovernanceProposalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    community<T extends CommunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunityDefaultArgs<ExtArgs>>): Prisma__CommunityClient<$Result.GetResult<Prisma.$CommunityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    options<T extends GovernanceProposal$optionsArgs<ExtArgs> = {}>(args?: Subset<T, GovernanceProposal$optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GovernanceProposal model
   */
  interface GovernanceProposalFieldRefs {
    readonly id: FieldRef<"GovernanceProposal", 'String'>
    readonly communityId: FieldRef<"GovernanceProposal", 'String'>
    readonly proposerId: FieldRef<"GovernanceProposal", 'String'>
    readonly title: FieldRef<"GovernanceProposal", 'String'>
    readonly description: FieldRef<"GovernanceProposal", 'String'>
    readonly type: FieldRef<"GovernanceProposal", 'String'>
    readonly status: FieldRef<"GovernanceProposal", 'String'>
    readonly startDate: FieldRef<"GovernanceProposal", 'DateTime'>
    readonly endDate: FieldRef<"GovernanceProposal", 'DateTime'>
    readonly quorumRequired: FieldRef<"GovernanceProposal", 'Int'>
    readonly totalVotes: FieldRef<"GovernanceProposal", 'Int'>
    readonly createdAt: FieldRef<"GovernanceProposal", 'DateTime'>
    readonly updatedAt: FieldRef<"GovernanceProposal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GovernanceProposal findUnique
   */
  export type GovernanceProposalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposal
     */
    select?: GovernanceProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceProposal
     */
    omit?: GovernanceProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceProposalInclude<ExtArgs> | null
    /**
     * Filter, which GovernanceProposal to fetch.
     */
    where: GovernanceProposalWhereUniqueInput
  }

  /**
   * GovernanceProposal findUniqueOrThrow
   */
  export type GovernanceProposalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposal
     */
    select?: GovernanceProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceProposal
     */
    omit?: GovernanceProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceProposalInclude<ExtArgs> | null
    /**
     * Filter, which GovernanceProposal to fetch.
     */
    where: GovernanceProposalWhereUniqueInput
  }

  /**
   * GovernanceProposal findFirst
   */
  export type GovernanceProposalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposal
     */
    select?: GovernanceProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceProposal
     */
    omit?: GovernanceProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceProposalInclude<ExtArgs> | null
    /**
     * Filter, which GovernanceProposal to fetch.
     */
    where?: GovernanceProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GovernanceProposals to fetch.
     */
    orderBy?: GovernanceProposalOrderByWithRelationInput | GovernanceProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GovernanceProposals.
     */
    cursor?: GovernanceProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GovernanceProposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GovernanceProposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GovernanceProposals.
     */
    distinct?: GovernanceProposalScalarFieldEnum | GovernanceProposalScalarFieldEnum[]
  }

  /**
   * GovernanceProposal findFirstOrThrow
   */
  export type GovernanceProposalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposal
     */
    select?: GovernanceProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceProposal
     */
    omit?: GovernanceProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceProposalInclude<ExtArgs> | null
    /**
     * Filter, which GovernanceProposal to fetch.
     */
    where?: GovernanceProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GovernanceProposals to fetch.
     */
    orderBy?: GovernanceProposalOrderByWithRelationInput | GovernanceProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GovernanceProposals.
     */
    cursor?: GovernanceProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GovernanceProposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GovernanceProposals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GovernanceProposals.
     */
    distinct?: GovernanceProposalScalarFieldEnum | GovernanceProposalScalarFieldEnum[]
  }

  /**
   * GovernanceProposal findMany
   */
  export type GovernanceProposalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposal
     */
    select?: GovernanceProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceProposal
     */
    omit?: GovernanceProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceProposalInclude<ExtArgs> | null
    /**
     * Filter, which GovernanceProposals to fetch.
     */
    where?: GovernanceProposalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GovernanceProposals to fetch.
     */
    orderBy?: GovernanceProposalOrderByWithRelationInput | GovernanceProposalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GovernanceProposals.
     */
    cursor?: GovernanceProposalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GovernanceProposals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GovernanceProposals.
     */
    skip?: number
    distinct?: GovernanceProposalScalarFieldEnum | GovernanceProposalScalarFieldEnum[]
  }

  /**
   * GovernanceProposal create
   */
  export type GovernanceProposalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposal
     */
    select?: GovernanceProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceProposal
     */
    omit?: GovernanceProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceProposalInclude<ExtArgs> | null
    /**
     * The data needed to create a GovernanceProposal.
     */
    data: XOR<GovernanceProposalCreateInput, GovernanceProposalUncheckedCreateInput>
  }

  /**
   * GovernanceProposal createMany
   */
  export type GovernanceProposalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GovernanceProposals.
     */
    data: GovernanceProposalCreateManyInput | GovernanceProposalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GovernanceProposal createManyAndReturn
   */
  export type GovernanceProposalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposal
     */
    select?: GovernanceProposalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceProposal
     */
    omit?: GovernanceProposalOmit<ExtArgs> | null
    /**
     * The data used to create many GovernanceProposals.
     */
    data: GovernanceProposalCreateManyInput | GovernanceProposalCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceProposalIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GovernanceProposal update
   */
  export type GovernanceProposalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposal
     */
    select?: GovernanceProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceProposal
     */
    omit?: GovernanceProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceProposalInclude<ExtArgs> | null
    /**
     * The data needed to update a GovernanceProposal.
     */
    data: XOR<GovernanceProposalUpdateInput, GovernanceProposalUncheckedUpdateInput>
    /**
     * Choose, which GovernanceProposal to update.
     */
    where: GovernanceProposalWhereUniqueInput
  }

  /**
   * GovernanceProposal updateMany
   */
  export type GovernanceProposalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GovernanceProposals.
     */
    data: XOR<GovernanceProposalUpdateManyMutationInput, GovernanceProposalUncheckedUpdateManyInput>
    /**
     * Filter which GovernanceProposals to update
     */
    where?: GovernanceProposalWhereInput
    /**
     * Limit how many GovernanceProposals to update.
     */
    limit?: number
  }

  /**
   * GovernanceProposal updateManyAndReturn
   */
  export type GovernanceProposalUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposal
     */
    select?: GovernanceProposalSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceProposal
     */
    omit?: GovernanceProposalOmit<ExtArgs> | null
    /**
     * The data used to update GovernanceProposals.
     */
    data: XOR<GovernanceProposalUpdateManyMutationInput, GovernanceProposalUncheckedUpdateManyInput>
    /**
     * Filter which GovernanceProposals to update
     */
    where?: GovernanceProposalWhereInput
    /**
     * Limit how many GovernanceProposals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceProposalIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GovernanceProposal upsert
   */
  export type GovernanceProposalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposal
     */
    select?: GovernanceProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceProposal
     */
    omit?: GovernanceProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceProposalInclude<ExtArgs> | null
    /**
     * The filter to search for the GovernanceProposal to update in case it exists.
     */
    where: GovernanceProposalWhereUniqueInput
    /**
     * In case the GovernanceProposal found by the `where` argument doesn't exist, create a new GovernanceProposal with this data.
     */
    create: XOR<GovernanceProposalCreateInput, GovernanceProposalUncheckedCreateInput>
    /**
     * In case the GovernanceProposal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GovernanceProposalUpdateInput, GovernanceProposalUncheckedUpdateInput>
  }

  /**
   * GovernanceProposal delete
   */
  export type GovernanceProposalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposal
     */
    select?: GovernanceProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceProposal
     */
    omit?: GovernanceProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceProposalInclude<ExtArgs> | null
    /**
     * Filter which GovernanceProposal to delete.
     */
    where: GovernanceProposalWhereUniqueInput
  }

  /**
   * GovernanceProposal deleteMany
   */
  export type GovernanceProposalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GovernanceProposals to delete
     */
    where?: GovernanceProposalWhereInput
    /**
     * Limit how many GovernanceProposals to delete.
     */
    limit?: number
  }

  /**
   * GovernanceProposal.options
   */
  export type GovernanceProposal$optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOption
     */
    select?: ProposalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOption
     */
    omit?: ProposalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOptionInclude<ExtArgs> | null
    where?: ProposalOptionWhereInput
    orderBy?: ProposalOptionOrderByWithRelationInput | ProposalOptionOrderByWithRelationInput[]
    cursor?: ProposalOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProposalOptionScalarFieldEnum | ProposalOptionScalarFieldEnum[]
  }

  /**
   * GovernanceProposal without action
   */
  export type GovernanceProposalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernanceProposal
     */
    select?: GovernanceProposalSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernanceProposal
     */
    omit?: GovernanceProposalOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernanceProposalInclude<ExtArgs> | null
  }


  /**
   * Model ProposalOption
   */

  export type AggregateProposalOption = {
    _count: ProposalOptionCountAggregateOutputType | null
    _avg: ProposalOptionAvgAggregateOutputType | null
    _sum: ProposalOptionSumAggregateOutputType | null
    _min: ProposalOptionMinAggregateOutputType | null
    _max: ProposalOptionMaxAggregateOutputType | null
  }

  export type ProposalOptionAvgAggregateOutputType = {
    votes: number | null
  }

  export type ProposalOptionSumAggregateOutputType = {
    votes: number | null
  }

  export type ProposalOptionMinAggregateOutputType = {
    id: string | null
    proposalId: string | null
    text: string | null
    votes: number | null
  }

  export type ProposalOptionMaxAggregateOutputType = {
    id: string | null
    proposalId: string | null
    text: string | null
    votes: number | null
  }

  export type ProposalOptionCountAggregateOutputType = {
    id: number
    proposalId: number
    text: number
    votes: number
    _all: number
  }


  export type ProposalOptionAvgAggregateInputType = {
    votes?: true
  }

  export type ProposalOptionSumAggregateInputType = {
    votes?: true
  }

  export type ProposalOptionMinAggregateInputType = {
    id?: true
    proposalId?: true
    text?: true
    votes?: true
  }

  export type ProposalOptionMaxAggregateInputType = {
    id?: true
    proposalId?: true
    text?: true
    votes?: true
  }

  export type ProposalOptionCountAggregateInputType = {
    id?: true
    proposalId?: true
    text?: true
    votes?: true
    _all?: true
  }

  export type ProposalOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProposalOption to aggregate.
     */
    where?: ProposalOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalOptions to fetch.
     */
    orderBy?: ProposalOptionOrderByWithRelationInput | ProposalOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProposalOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProposalOptions
    **/
    _count?: true | ProposalOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProposalOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProposalOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProposalOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProposalOptionMaxAggregateInputType
  }

  export type GetProposalOptionAggregateType<T extends ProposalOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateProposalOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProposalOption[P]>
      : GetScalarType<T[P], AggregateProposalOption[P]>
  }




  export type ProposalOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProposalOptionWhereInput
    orderBy?: ProposalOptionOrderByWithAggregationInput | ProposalOptionOrderByWithAggregationInput[]
    by: ProposalOptionScalarFieldEnum[] | ProposalOptionScalarFieldEnum
    having?: ProposalOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProposalOptionCountAggregateInputType | true
    _avg?: ProposalOptionAvgAggregateInputType
    _sum?: ProposalOptionSumAggregateInputType
    _min?: ProposalOptionMinAggregateInputType
    _max?: ProposalOptionMaxAggregateInputType
  }

  export type ProposalOptionGroupByOutputType = {
    id: string
    proposalId: string
    text: string
    votes: number
    _count: ProposalOptionCountAggregateOutputType | null
    _avg: ProposalOptionAvgAggregateOutputType | null
    _sum: ProposalOptionSumAggregateOutputType | null
    _min: ProposalOptionMinAggregateOutputType | null
    _max: ProposalOptionMaxAggregateOutputType | null
  }

  type GetProposalOptionGroupByPayload<T extends ProposalOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProposalOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProposalOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProposalOptionGroupByOutputType[P]>
            : GetScalarType<T[P], ProposalOptionGroupByOutputType[P]>
        }
      >
    >


  export type ProposalOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proposalId?: boolean
    text?: boolean
    votes?: boolean
    proposal?: boolean | GovernanceProposalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proposalOption"]>

  export type ProposalOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proposalId?: boolean
    text?: boolean
    votes?: boolean
    proposal?: boolean | GovernanceProposalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proposalOption"]>

  export type ProposalOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    proposalId?: boolean
    text?: boolean
    votes?: boolean
    proposal?: boolean | GovernanceProposalDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proposalOption"]>

  export type ProposalOptionSelectScalar = {
    id?: boolean
    proposalId?: boolean
    text?: boolean
    votes?: boolean
  }

  export type ProposalOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "proposalId" | "text" | "votes", ExtArgs["result"]["proposalOption"]>
  export type ProposalOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposal?: boolean | GovernanceProposalDefaultArgs<ExtArgs>
  }
  export type ProposalOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposal?: boolean | GovernanceProposalDefaultArgs<ExtArgs>
  }
  export type ProposalOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proposal?: boolean | GovernanceProposalDefaultArgs<ExtArgs>
  }

  export type $ProposalOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProposalOption"
    objects: {
      proposal: Prisma.$GovernanceProposalPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      proposalId: string
      text: string
      votes: number
    }, ExtArgs["result"]["proposalOption"]>
    composites: {}
  }

  type ProposalOptionGetPayload<S extends boolean | null | undefined | ProposalOptionDefaultArgs> = $Result.GetResult<Prisma.$ProposalOptionPayload, S>

  type ProposalOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProposalOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProposalOptionCountAggregateInputType | true
    }

  export interface ProposalOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProposalOption'], meta: { name: 'ProposalOption' } }
    /**
     * Find zero or one ProposalOption that matches the filter.
     * @param {ProposalOptionFindUniqueArgs} args - Arguments to find a ProposalOption
     * @example
     * // Get one ProposalOption
     * const proposalOption = await prisma.proposalOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProposalOptionFindUniqueArgs>(args: SelectSubset<T, ProposalOptionFindUniqueArgs<ExtArgs>>): Prisma__ProposalOptionClient<$Result.GetResult<Prisma.$ProposalOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProposalOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProposalOptionFindUniqueOrThrowArgs} args - Arguments to find a ProposalOption
     * @example
     * // Get one ProposalOption
     * const proposalOption = await prisma.proposalOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProposalOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, ProposalOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProposalOptionClient<$Result.GetResult<Prisma.$ProposalOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProposalOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalOptionFindFirstArgs} args - Arguments to find a ProposalOption
     * @example
     * // Get one ProposalOption
     * const proposalOption = await prisma.proposalOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProposalOptionFindFirstArgs>(args?: SelectSubset<T, ProposalOptionFindFirstArgs<ExtArgs>>): Prisma__ProposalOptionClient<$Result.GetResult<Prisma.$ProposalOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProposalOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalOptionFindFirstOrThrowArgs} args - Arguments to find a ProposalOption
     * @example
     * // Get one ProposalOption
     * const proposalOption = await prisma.proposalOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProposalOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, ProposalOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProposalOptionClient<$Result.GetResult<Prisma.$ProposalOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProposalOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProposalOptions
     * const proposalOptions = await prisma.proposalOption.findMany()
     * 
     * // Get first 10 ProposalOptions
     * const proposalOptions = await prisma.proposalOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proposalOptionWithIdOnly = await prisma.proposalOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProposalOptionFindManyArgs>(args?: SelectSubset<T, ProposalOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProposalOption.
     * @param {ProposalOptionCreateArgs} args - Arguments to create a ProposalOption.
     * @example
     * // Create one ProposalOption
     * const ProposalOption = await prisma.proposalOption.create({
     *   data: {
     *     // ... data to create a ProposalOption
     *   }
     * })
     * 
     */
    create<T extends ProposalOptionCreateArgs>(args: SelectSubset<T, ProposalOptionCreateArgs<ExtArgs>>): Prisma__ProposalOptionClient<$Result.GetResult<Prisma.$ProposalOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProposalOptions.
     * @param {ProposalOptionCreateManyArgs} args - Arguments to create many ProposalOptions.
     * @example
     * // Create many ProposalOptions
     * const proposalOption = await prisma.proposalOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProposalOptionCreateManyArgs>(args?: SelectSubset<T, ProposalOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProposalOptions and returns the data saved in the database.
     * @param {ProposalOptionCreateManyAndReturnArgs} args - Arguments to create many ProposalOptions.
     * @example
     * // Create many ProposalOptions
     * const proposalOption = await prisma.proposalOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProposalOptions and only return the `id`
     * const proposalOptionWithIdOnly = await prisma.proposalOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProposalOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, ProposalOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProposalOption.
     * @param {ProposalOptionDeleteArgs} args - Arguments to delete one ProposalOption.
     * @example
     * // Delete one ProposalOption
     * const ProposalOption = await prisma.proposalOption.delete({
     *   where: {
     *     // ... filter to delete one ProposalOption
     *   }
     * })
     * 
     */
    delete<T extends ProposalOptionDeleteArgs>(args: SelectSubset<T, ProposalOptionDeleteArgs<ExtArgs>>): Prisma__ProposalOptionClient<$Result.GetResult<Prisma.$ProposalOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProposalOption.
     * @param {ProposalOptionUpdateArgs} args - Arguments to update one ProposalOption.
     * @example
     * // Update one ProposalOption
     * const proposalOption = await prisma.proposalOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProposalOptionUpdateArgs>(args: SelectSubset<T, ProposalOptionUpdateArgs<ExtArgs>>): Prisma__ProposalOptionClient<$Result.GetResult<Prisma.$ProposalOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProposalOptions.
     * @param {ProposalOptionDeleteManyArgs} args - Arguments to filter ProposalOptions to delete.
     * @example
     * // Delete a few ProposalOptions
     * const { count } = await prisma.proposalOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProposalOptionDeleteManyArgs>(args?: SelectSubset<T, ProposalOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProposalOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProposalOptions
     * const proposalOption = await prisma.proposalOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProposalOptionUpdateManyArgs>(args: SelectSubset<T, ProposalOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProposalOptions and returns the data updated in the database.
     * @param {ProposalOptionUpdateManyAndReturnArgs} args - Arguments to update many ProposalOptions.
     * @example
     * // Update many ProposalOptions
     * const proposalOption = await prisma.proposalOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProposalOptions and only return the `id`
     * const proposalOptionWithIdOnly = await prisma.proposalOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProposalOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, ProposalOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProposalOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProposalOption.
     * @param {ProposalOptionUpsertArgs} args - Arguments to update or create a ProposalOption.
     * @example
     * // Update or create a ProposalOption
     * const proposalOption = await prisma.proposalOption.upsert({
     *   create: {
     *     // ... data to create a ProposalOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProposalOption we want to update
     *   }
     * })
     */
    upsert<T extends ProposalOptionUpsertArgs>(args: SelectSubset<T, ProposalOptionUpsertArgs<ExtArgs>>): Prisma__ProposalOptionClient<$Result.GetResult<Prisma.$ProposalOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProposalOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalOptionCountArgs} args - Arguments to filter ProposalOptions to count.
     * @example
     * // Count the number of ProposalOptions
     * const count = await prisma.proposalOption.count({
     *   where: {
     *     // ... the filter for the ProposalOptions we want to count
     *   }
     * })
    **/
    count<T extends ProposalOptionCountArgs>(
      args?: Subset<T, ProposalOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProposalOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProposalOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProposalOptionAggregateArgs>(args: Subset<T, ProposalOptionAggregateArgs>): Prisma.PrismaPromise<GetProposalOptionAggregateType<T>>

    /**
     * Group by ProposalOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProposalOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProposalOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProposalOptionGroupByArgs['orderBy'] }
        : { orderBy?: ProposalOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProposalOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProposalOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProposalOption model
   */
  readonly fields: ProposalOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProposalOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProposalOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proposal<T extends GovernanceProposalDefaultArgs<ExtArgs> = {}>(args?: Subset<T, GovernanceProposalDefaultArgs<ExtArgs>>): Prisma__GovernanceProposalClient<$Result.GetResult<Prisma.$GovernanceProposalPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProposalOption model
   */
  interface ProposalOptionFieldRefs {
    readonly id: FieldRef<"ProposalOption", 'String'>
    readonly proposalId: FieldRef<"ProposalOption", 'String'>
    readonly text: FieldRef<"ProposalOption", 'String'>
    readonly votes: FieldRef<"ProposalOption", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProposalOption findUnique
   */
  export type ProposalOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOption
     */
    select?: ProposalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOption
     */
    omit?: ProposalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOptionInclude<ExtArgs> | null
    /**
     * Filter, which ProposalOption to fetch.
     */
    where: ProposalOptionWhereUniqueInput
  }

  /**
   * ProposalOption findUniqueOrThrow
   */
  export type ProposalOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOption
     */
    select?: ProposalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOption
     */
    omit?: ProposalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOptionInclude<ExtArgs> | null
    /**
     * Filter, which ProposalOption to fetch.
     */
    where: ProposalOptionWhereUniqueInput
  }

  /**
   * ProposalOption findFirst
   */
  export type ProposalOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOption
     */
    select?: ProposalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOption
     */
    omit?: ProposalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOptionInclude<ExtArgs> | null
    /**
     * Filter, which ProposalOption to fetch.
     */
    where?: ProposalOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalOptions to fetch.
     */
    orderBy?: ProposalOptionOrderByWithRelationInput | ProposalOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProposalOptions.
     */
    cursor?: ProposalOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProposalOptions.
     */
    distinct?: ProposalOptionScalarFieldEnum | ProposalOptionScalarFieldEnum[]
  }

  /**
   * ProposalOption findFirstOrThrow
   */
  export type ProposalOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOption
     */
    select?: ProposalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOption
     */
    omit?: ProposalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOptionInclude<ExtArgs> | null
    /**
     * Filter, which ProposalOption to fetch.
     */
    where?: ProposalOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalOptions to fetch.
     */
    orderBy?: ProposalOptionOrderByWithRelationInput | ProposalOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProposalOptions.
     */
    cursor?: ProposalOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProposalOptions.
     */
    distinct?: ProposalOptionScalarFieldEnum | ProposalOptionScalarFieldEnum[]
  }

  /**
   * ProposalOption findMany
   */
  export type ProposalOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOption
     */
    select?: ProposalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOption
     */
    omit?: ProposalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOptionInclude<ExtArgs> | null
    /**
     * Filter, which ProposalOptions to fetch.
     */
    where?: ProposalOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProposalOptions to fetch.
     */
    orderBy?: ProposalOptionOrderByWithRelationInput | ProposalOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProposalOptions.
     */
    cursor?: ProposalOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProposalOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProposalOptions.
     */
    skip?: number
    distinct?: ProposalOptionScalarFieldEnum | ProposalOptionScalarFieldEnum[]
  }

  /**
   * ProposalOption create
   */
  export type ProposalOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOption
     */
    select?: ProposalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOption
     */
    omit?: ProposalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a ProposalOption.
     */
    data: XOR<ProposalOptionCreateInput, ProposalOptionUncheckedCreateInput>
  }

  /**
   * ProposalOption createMany
   */
  export type ProposalOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProposalOptions.
     */
    data: ProposalOptionCreateManyInput | ProposalOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProposalOption createManyAndReturn
   */
  export type ProposalOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOption
     */
    select?: ProposalOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOption
     */
    omit?: ProposalOptionOmit<ExtArgs> | null
    /**
     * The data used to create many ProposalOptions.
     */
    data: ProposalOptionCreateManyInput | ProposalOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProposalOption update
   */
  export type ProposalOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOption
     */
    select?: ProposalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOption
     */
    omit?: ProposalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a ProposalOption.
     */
    data: XOR<ProposalOptionUpdateInput, ProposalOptionUncheckedUpdateInput>
    /**
     * Choose, which ProposalOption to update.
     */
    where: ProposalOptionWhereUniqueInput
  }

  /**
   * ProposalOption updateMany
   */
  export type ProposalOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProposalOptions.
     */
    data: XOR<ProposalOptionUpdateManyMutationInput, ProposalOptionUncheckedUpdateManyInput>
    /**
     * Filter which ProposalOptions to update
     */
    where?: ProposalOptionWhereInput
    /**
     * Limit how many ProposalOptions to update.
     */
    limit?: number
  }

  /**
   * ProposalOption updateManyAndReturn
   */
  export type ProposalOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOption
     */
    select?: ProposalOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOption
     */
    omit?: ProposalOptionOmit<ExtArgs> | null
    /**
     * The data used to update ProposalOptions.
     */
    data: XOR<ProposalOptionUpdateManyMutationInput, ProposalOptionUncheckedUpdateManyInput>
    /**
     * Filter which ProposalOptions to update
     */
    where?: ProposalOptionWhereInput
    /**
     * Limit how many ProposalOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProposalOption upsert
   */
  export type ProposalOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOption
     */
    select?: ProposalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOption
     */
    omit?: ProposalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the ProposalOption to update in case it exists.
     */
    where: ProposalOptionWhereUniqueInput
    /**
     * In case the ProposalOption found by the `where` argument doesn't exist, create a new ProposalOption with this data.
     */
    create: XOR<ProposalOptionCreateInput, ProposalOptionUncheckedCreateInput>
    /**
     * In case the ProposalOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProposalOptionUpdateInput, ProposalOptionUncheckedUpdateInput>
  }

  /**
   * ProposalOption delete
   */
  export type ProposalOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOption
     */
    select?: ProposalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOption
     */
    omit?: ProposalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOptionInclude<ExtArgs> | null
    /**
     * Filter which ProposalOption to delete.
     */
    where: ProposalOptionWhereUniqueInput
  }

  /**
   * ProposalOption deleteMany
   */
  export type ProposalOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProposalOptions to delete
     */
    where?: ProposalOptionWhereInput
    /**
     * Limit how many ProposalOptions to delete.
     */
    limit?: number
  }

  /**
   * ProposalOption without action
   */
  export type ProposalOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProposalOption
     */
    select?: ProposalOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProposalOption
     */
    omit?: ProposalOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProposalOptionInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    upvotes: number | null
    downvotes: number | null
  }

  export type CommentSumAggregateOutputType = {
    upvotes: number | null
    downvotes: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    content: string | null
    postId: string | null
    authorId: string | null
    parentId: string | null
    upvotes: number | null
    downvotes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    content: string | null
    postId: string | null
    authorId: string | null
    parentId: string | null
    upvotes: number | null
    downvotes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    content: number
    postId: number
    authorId: number
    parentId: number
    upvotes: number
    downvotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    upvotes?: true
    downvotes?: true
  }

  export type CommentSumAggregateInputType = {
    upvotes?: true
    downvotes?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    content?: true
    postId?: true
    authorId?: true
    parentId?: true
    upvotes?: true
    downvotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    content?: true
    postId?: true
    authorId?: true
    parentId?: true
    upvotes?: true
    downvotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    content?: true
    postId?: true
    authorId?: true
    parentId?: true
    upvotes?: true
    downvotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    content: string
    postId: string
    authorId: string
    parentId: string | null
    upvotes: number
    downvotes: number
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    postId?: boolean
    authorId?: boolean
    parentId?: boolean
    upvotes?: boolean
    downvotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | CommunityPostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    children?: boolean | Comment$childrenArgs<ExtArgs>
    votes?: boolean | Comment$votesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    postId?: boolean
    authorId?: boolean
    parentId?: boolean
    upvotes?: boolean
    downvotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | CommunityPostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    postId?: boolean
    authorId?: boolean
    parentId?: boolean
    upvotes?: boolean
    downvotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | CommunityPostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    content?: boolean
    postId?: boolean
    authorId?: boolean
    parentId?: boolean
    upvotes?: boolean
    downvotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "postId" | "authorId" | "parentId" | "upvotes" | "downvotes" | "createdAt" | "updatedAt", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | CommunityPostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
    children?: boolean | Comment$childrenArgs<ExtArgs>
    votes?: boolean | Comment$votesArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | CommunityPostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | CommunityPostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    parent?: boolean | Comment$parentArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      post: Prisma.$CommunityPostPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
      parent: Prisma.$CommentPayload<ExtArgs> | null
      children: Prisma.$CommentPayload<ExtArgs>[]
      votes: Prisma.$CommentVotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      postId: string
      authorId: string
      parentId: string | null
      upvotes: number
      downvotes: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends CommunityPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommunityPostDefaultArgs<ExtArgs>>): Prisma__CommunityPostClient<$Result.GetResult<Prisma.$CommunityPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends Comment$parentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$parentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Comment$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Comment$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    votes<T extends Comment$votesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly postId: FieldRef<"Comment", 'String'>
    readonly authorId: FieldRef<"Comment", 'String'>
    readonly parentId: FieldRef<"Comment", 'String'>
    readonly upvotes: FieldRef<"Comment", 'Int'>
    readonly downvotes: FieldRef<"Comment", 'Int'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment.parent
   */
  export type Comment$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Comment.children
   */
  export type Comment$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment.votes
   */
  export type Comment$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentVote
     */
    select?: CommentVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentVote
     */
    omit?: CommentVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentVoteInclude<ExtArgs> | null
    where?: CommentVoteWhereInput
    orderBy?: CommentVoteOrderByWithRelationInput | CommentVoteOrderByWithRelationInput[]
    cursor?: CommentVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentVoteScalarFieldEnum | CommentVoteScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model CommentVote
   */

  export type AggregateCommentVote = {
    _count: CommentVoteCountAggregateOutputType | null
    _min: CommentVoteMinAggregateOutputType | null
    _max: CommentVoteMaxAggregateOutputType | null
  }

  export type CommentVoteMinAggregateOutputType = {
    id: string | null
    commentId: string | null
    userId: string | null
    type: string | null
    createdAt: Date | null
  }

  export type CommentVoteMaxAggregateOutputType = {
    id: string | null
    commentId: string | null
    userId: string | null
    type: string | null
    createdAt: Date | null
  }

  export type CommentVoteCountAggregateOutputType = {
    id: number
    commentId: number
    userId: number
    type: number
    createdAt: number
    _all: number
  }


  export type CommentVoteMinAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
    type?: true
    createdAt?: true
  }

  export type CommentVoteMaxAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
    type?: true
    createdAt?: true
  }

  export type CommentVoteCountAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type CommentVoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentVote to aggregate.
     */
    where?: CommentVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentVotes to fetch.
     */
    orderBy?: CommentVoteOrderByWithRelationInput | CommentVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommentVotes
    **/
    _count?: true | CommentVoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentVoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentVoteMaxAggregateInputType
  }

  export type GetCommentVoteAggregateType<T extends CommentVoteAggregateArgs> = {
        [P in keyof T & keyof AggregateCommentVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommentVote[P]>
      : GetScalarType<T[P], AggregateCommentVote[P]>
  }




  export type CommentVoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentVoteWhereInput
    orderBy?: CommentVoteOrderByWithAggregationInput | CommentVoteOrderByWithAggregationInput[]
    by: CommentVoteScalarFieldEnum[] | CommentVoteScalarFieldEnum
    having?: CommentVoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentVoteCountAggregateInputType | true
    _min?: CommentVoteMinAggregateInputType
    _max?: CommentVoteMaxAggregateInputType
  }

  export type CommentVoteGroupByOutputType = {
    id: string
    commentId: string
    userId: string
    type: string
    createdAt: Date
    _count: CommentVoteCountAggregateOutputType | null
    _min: CommentVoteMinAggregateOutputType | null
    _max: CommentVoteMaxAggregateOutputType | null
  }

  type GetCommentVoteGroupByPayload<T extends CommentVoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentVoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentVoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentVoteGroupByOutputType[P]>
            : GetScalarType<T[P], CommentVoteGroupByOutputType[P]>
        }
      >
    >


  export type CommentVoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentVote"]>

  export type CommentVoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentVote"]>

  export type CommentVoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentVote"]>

  export type CommentVoteSelectScalar = {
    id?: boolean
    commentId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type CommentVoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "commentId" | "userId" | "type" | "createdAt", ExtArgs["result"]["commentVote"]>
  export type CommentVoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentVoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentVoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommentVotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommentVote"
    objects: {
      comment: Prisma.$CommentPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      commentId: string
      userId: string
      type: string
      createdAt: Date
    }, ExtArgs["result"]["commentVote"]>
    composites: {}
  }

  type CommentVoteGetPayload<S extends boolean | null | undefined | CommentVoteDefaultArgs> = $Result.GetResult<Prisma.$CommentVotePayload, S>

  type CommentVoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentVoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentVoteCountAggregateInputType | true
    }

  export interface CommentVoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommentVote'], meta: { name: 'CommentVote' } }
    /**
     * Find zero or one CommentVote that matches the filter.
     * @param {CommentVoteFindUniqueArgs} args - Arguments to find a CommentVote
     * @example
     * // Get one CommentVote
     * const commentVote = await prisma.commentVote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentVoteFindUniqueArgs>(args: SelectSubset<T, CommentVoteFindUniqueArgs<ExtArgs>>): Prisma__CommentVoteClient<$Result.GetResult<Prisma.$CommentVotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CommentVote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentVoteFindUniqueOrThrowArgs} args - Arguments to find a CommentVote
     * @example
     * // Get one CommentVote
     * const commentVote = await prisma.commentVote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentVoteFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentVoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentVoteClient<$Result.GetResult<Prisma.$CommentVotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommentVote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentVoteFindFirstArgs} args - Arguments to find a CommentVote
     * @example
     * // Get one CommentVote
     * const commentVote = await prisma.commentVote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentVoteFindFirstArgs>(args?: SelectSubset<T, CommentVoteFindFirstArgs<ExtArgs>>): Prisma__CommentVoteClient<$Result.GetResult<Prisma.$CommentVotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommentVote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentVoteFindFirstOrThrowArgs} args - Arguments to find a CommentVote
     * @example
     * // Get one CommentVote
     * const commentVote = await prisma.commentVote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentVoteFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentVoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentVoteClient<$Result.GetResult<Prisma.$CommentVotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommentVotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentVoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommentVotes
     * const commentVotes = await prisma.commentVote.findMany()
     * 
     * // Get first 10 CommentVotes
     * const commentVotes = await prisma.commentVote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentVoteWithIdOnly = await prisma.commentVote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentVoteFindManyArgs>(args?: SelectSubset<T, CommentVoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CommentVote.
     * @param {CommentVoteCreateArgs} args - Arguments to create a CommentVote.
     * @example
     * // Create one CommentVote
     * const CommentVote = await prisma.commentVote.create({
     *   data: {
     *     // ... data to create a CommentVote
     *   }
     * })
     * 
     */
    create<T extends CommentVoteCreateArgs>(args: SelectSubset<T, CommentVoteCreateArgs<ExtArgs>>): Prisma__CommentVoteClient<$Result.GetResult<Prisma.$CommentVotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CommentVotes.
     * @param {CommentVoteCreateManyArgs} args - Arguments to create many CommentVotes.
     * @example
     * // Create many CommentVotes
     * const commentVote = await prisma.commentVote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentVoteCreateManyArgs>(args?: SelectSubset<T, CommentVoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommentVotes and returns the data saved in the database.
     * @param {CommentVoteCreateManyAndReturnArgs} args - Arguments to create many CommentVotes.
     * @example
     * // Create many CommentVotes
     * const commentVote = await prisma.commentVote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommentVotes and only return the `id`
     * const commentVoteWithIdOnly = await prisma.commentVote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentVoteCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentVoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentVotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CommentVote.
     * @param {CommentVoteDeleteArgs} args - Arguments to delete one CommentVote.
     * @example
     * // Delete one CommentVote
     * const CommentVote = await prisma.commentVote.delete({
     *   where: {
     *     // ... filter to delete one CommentVote
     *   }
     * })
     * 
     */
    delete<T extends CommentVoteDeleteArgs>(args: SelectSubset<T, CommentVoteDeleteArgs<ExtArgs>>): Prisma__CommentVoteClient<$Result.GetResult<Prisma.$CommentVotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CommentVote.
     * @param {CommentVoteUpdateArgs} args - Arguments to update one CommentVote.
     * @example
     * // Update one CommentVote
     * const commentVote = await prisma.commentVote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentVoteUpdateArgs>(args: SelectSubset<T, CommentVoteUpdateArgs<ExtArgs>>): Prisma__CommentVoteClient<$Result.GetResult<Prisma.$CommentVotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CommentVotes.
     * @param {CommentVoteDeleteManyArgs} args - Arguments to filter CommentVotes to delete.
     * @example
     * // Delete a few CommentVotes
     * const { count } = await prisma.commentVote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentVoteDeleteManyArgs>(args?: SelectSubset<T, CommentVoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentVoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommentVotes
     * const commentVote = await prisma.commentVote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentVoteUpdateManyArgs>(args: SelectSubset<T, CommentVoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentVotes and returns the data updated in the database.
     * @param {CommentVoteUpdateManyAndReturnArgs} args - Arguments to update many CommentVotes.
     * @example
     * // Update many CommentVotes
     * const commentVote = await prisma.commentVote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CommentVotes and only return the `id`
     * const commentVoteWithIdOnly = await prisma.commentVote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentVoteUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentVoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentVotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CommentVote.
     * @param {CommentVoteUpsertArgs} args - Arguments to update or create a CommentVote.
     * @example
     * // Update or create a CommentVote
     * const commentVote = await prisma.commentVote.upsert({
     *   create: {
     *     // ... data to create a CommentVote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommentVote we want to update
     *   }
     * })
     */
    upsert<T extends CommentVoteUpsertArgs>(args: SelectSubset<T, CommentVoteUpsertArgs<ExtArgs>>): Prisma__CommentVoteClient<$Result.GetResult<Prisma.$CommentVotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CommentVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentVoteCountArgs} args - Arguments to filter CommentVotes to count.
     * @example
     * // Count the number of CommentVotes
     * const count = await prisma.commentVote.count({
     *   where: {
     *     // ... the filter for the CommentVotes we want to count
     *   }
     * })
    **/
    count<T extends CommentVoteCountArgs>(
      args?: Subset<T, CommentVoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentVoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommentVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentVoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentVoteAggregateArgs>(args: Subset<T, CommentVoteAggregateArgs>): Prisma.PrismaPromise<GetCommentVoteAggregateType<T>>

    /**
     * Group by CommentVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentVoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentVoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentVoteGroupByArgs['orderBy'] }
        : { orderBy?: CommentVoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentVoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentVoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommentVote model
   */
  readonly fields: CommentVoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommentVote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentVoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comment<T extends CommentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommentDefaultArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommentVote model
   */
  interface CommentVoteFieldRefs {
    readonly id: FieldRef<"CommentVote", 'String'>
    readonly commentId: FieldRef<"CommentVote", 'String'>
    readonly userId: FieldRef<"CommentVote", 'String'>
    readonly type: FieldRef<"CommentVote", 'String'>
    readonly createdAt: FieldRef<"CommentVote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommentVote findUnique
   */
  export type CommentVoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentVote
     */
    select?: CommentVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentVote
     */
    omit?: CommentVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentVoteInclude<ExtArgs> | null
    /**
     * Filter, which CommentVote to fetch.
     */
    where: CommentVoteWhereUniqueInput
  }

  /**
   * CommentVote findUniqueOrThrow
   */
  export type CommentVoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentVote
     */
    select?: CommentVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentVote
     */
    omit?: CommentVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentVoteInclude<ExtArgs> | null
    /**
     * Filter, which CommentVote to fetch.
     */
    where: CommentVoteWhereUniqueInput
  }

  /**
   * CommentVote findFirst
   */
  export type CommentVoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentVote
     */
    select?: CommentVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentVote
     */
    omit?: CommentVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentVoteInclude<ExtArgs> | null
    /**
     * Filter, which CommentVote to fetch.
     */
    where?: CommentVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentVotes to fetch.
     */
    orderBy?: CommentVoteOrderByWithRelationInput | CommentVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentVotes.
     */
    cursor?: CommentVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentVotes.
     */
    distinct?: CommentVoteScalarFieldEnum | CommentVoteScalarFieldEnum[]
  }

  /**
   * CommentVote findFirstOrThrow
   */
  export type CommentVoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentVote
     */
    select?: CommentVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentVote
     */
    omit?: CommentVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentVoteInclude<ExtArgs> | null
    /**
     * Filter, which CommentVote to fetch.
     */
    where?: CommentVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentVotes to fetch.
     */
    orderBy?: CommentVoteOrderByWithRelationInput | CommentVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentVotes.
     */
    cursor?: CommentVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentVotes.
     */
    distinct?: CommentVoteScalarFieldEnum | CommentVoteScalarFieldEnum[]
  }

  /**
   * CommentVote findMany
   */
  export type CommentVoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentVote
     */
    select?: CommentVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentVote
     */
    omit?: CommentVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentVoteInclude<ExtArgs> | null
    /**
     * Filter, which CommentVotes to fetch.
     */
    where?: CommentVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentVotes to fetch.
     */
    orderBy?: CommentVoteOrderByWithRelationInput | CommentVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommentVotes.
     */
    cursor?: CommentVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentVotes.
     */
    skip?: number
    distinct?: CommentVoteScalarFieldEnum | CommentVoteScalarFieldEnum[]
  }

  /**
   * CommentVote create
   */
  export type CommentVoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentVote
     */
    select?: CommentVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentVote
     */
    omit?: CommentVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentVoteInclude<ExtArgs> | null
    /**
     * The data needed to create a CommentVote.
     */
    data: XOR<CommentVoteCreateInput, CommentVoteUncheckedCreateInput>
  }

  /**
   * CommentVote createMany
   */
  export type CommentVoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommentVotes.
     */
    data: CommentVoteCreateManyInput | CommentVoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommentVote createManyAndReturn
   */
  export type CommentVoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentVote
     */
    select?: CommentVoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommentVote
     */
    omit?: CommentVoteOmit<ExtArgs> | null
    /**
     * The data used to create many CommentVotes.
     */
    data: CommentVoteCreateManyInput | CommentVoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentVoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommentVote update
   */
  export type CommentVoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentVote
     */
    select?: CommentVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentVote
     */
    omit?: CommentVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentVoteInclude<ExtArgs> | null
    /**
     * The data needed to update a CommentVote.
     */
    data: XOR<CommentVoteUpdateInput, CommentVoteUncheckedUpdateInput>
    /**
     * Choose, which CommentVote to update.
     */
    where: CommentVoteWhereUniqueInput
  }

  /**
   * CommentVote updateMany
   */
  export type CommentVoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommentVotes.
     */
    data: XOR<CommentVoteUpdateManyMutationInput, CommentVoteUncheckedUpdateManyInput>
    /**
     * Filter which CommentVotes to update
     */
    where?: CommentVoteWhereInput
    /**
     * Limit how many CommentVotes to update.
     */
    limit?: number
  }

  /**
   * CommentVote updateManyAndReturn
   */
  export type CommentVoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentVote
     */
    select?: CommentVoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommentVote
     */
    omit?: CommentVoteOmit<ExtArgs> | null
    /**
     * The data used to update CommentVotes.
     */
    data: XOR<CommentVoteUpdateManyMutationInput, CommentVoteUncheckedUpdateManyInput>
    /**
     * Filter which CommentVotes to update
     */
    where?: CommentVoteWhereInput
    /**
     * Limit how many CommentVotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentVoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommentVote upsert
   */
  export type CommentVoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentVote
     */
    select?: CommentVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentVote
     */
    omit?: CommentVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentVoteInclude<ExtArgs> | null
    /**
     * The filter to search for the CommentVote to update in case it exists.
     */
    where: CommentVoteWhereUniqueInput
    /**
     * In case the CommentVote found by the `where` argument doesn't exist, create a new CommentVote with this data.
     */
    create: XOR<CommentVoteCreateInput, CommentVoteUncheckedCreateInput>
    /**
     * In case the CommentVote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentVoteUpdateInput, CommentVoteUncheckedUpdateInput>
  }

  /**
   * CommentVote delete
   */
  export type CommentVoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentVote
     */
    select?: CommentVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentVote
     */
    omit?: CommentVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentVoteInclude<ExtArgs> | null
    /**
     * Filter which CommentVote to delete.
     */
    where: CommentVoteWhereUniqueInput
  }

  /**
   * CommentVote deleteMany
   */
  export type CommentVoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentVotes to delete
     */
    where?: CommentVoteWhereInput
    /**
     * Limit how many CommentVotes to delete.
     */
    limit?: number
  }

  /**
   * CommentVote without action
   */
  export type CommentVoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentVote
     */
    select?: CommentVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentVote
     */
    omit?: CommentVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentVoteInclude<ExtArgs> | null
  }


  /**
   * Model Quiz
   */

  export type AggregateQuiz = {
    _count: QuizCountAggregateOutputType | null
    _avg: QuizAvgAggregateOutputType | null
    _sum: QuizSumAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  export type QuizAvgAggregateOutputType = {
    duration: number | null
    questionCount: number | null
  }

  export type QuizSumAggregateOutputType = {
    duration: number | null
    questionCount: number | null
  }

  export type QuizMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    artistId: string | null
    artistName: string | null
    type: string | null
    status: string | null
    duration: number | null
    questionCount: number | null
    startTime: Date | null
    endTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    artistId: string | null
    artistName: string | null
    type: string | null
    status: string | null
    duration: number | null
    questionCount: number | null
    startTime: Date | null
    endTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizCountAggregateOutputType = {
    id: number
    eventId: number
    artistId: number
    artistName: number
    type: number
    status: number
    duration: number
    questionCount: number
    startTime: number
    endTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuizAvgAggregateInputType = {
    duration?: true
    questionCount?: true
  }

  export type QuizSumAggregateInputType = {
    duration?: true
    questionCount?: true
  }

  export type QuizMinAggregateInputType = {
    id?: true
    eventId?: true
    artistId?: true
    artistName?: true
    type?: true
    status?: true
    duration?: true
    questionCount?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizMaxAggregateInputType = {
    id?: true
    eventId?: true
    artistId?: true
    artistName?: true
    type?: true
    status?: true
    duration?: true
    questionCount?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizCountAggregateInputType = {
    id?: true
    eventId?: true
    artistId?: true
    artistName?: true
    type?: true
    status?: true
    duration?: true
    questionCount?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuizAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quiz to aggregate.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Quizzes
    **/
    _count?: true | QuizCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizMaxAggregateInputType
  }

  export type GetQuizAggregateType<T extends QuizAggregateArgs> = {
        [P in keyof T & keyof AggregateQuiz]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuiz[P]>
      : GetScalarType<T[P], AggregateQuiz[P]>
  }




  export type QuizGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizWhereInput
    orderBy?: QuizOrderByWithAggregationInput | QuizOrderByWithAggregationInput[]
    by: QuizScalarFieldEnum[] | QuizScalarFieldEnum
    having?: QuizScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizCountAggregateInputType | true
    _avg?: QuizAvgAggregateInputType
    _sum?: QuizSumAggregateInputType
    _min?: QuizMinAggregateInputType
    _max?: QuizMaxAggregateInputType
  }

  export type QuizGroupByOutputType = {
    id: string
    eventId: string | null
    artistId: string
    artistName: string
    type: string
    status: string
    duration: number
    questionCount: number
    startTime: Date | null
    endTime: Date | null
    createdAt: Date
    updatedAt: Date
    _count: QuizCountAggregateOutputType | null
    _avg: QuizAvgAggregateOutputType | null
    _sum: QuizSumAggregateOutputType | null
    _min: QuizMinAggregateOutputType | null
    _max: QuizMaxAggregateOutputType | null
  }

  type GetQuizGroupByPayload<T extends QuizGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizGroupByOutputType[P]>
            : GetScalarType<T[P], QuizGroupByOutputType[P]>
        }
      >
    >


  export type QuizSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    artistId?: boolean
    artistName?: boolean
    type?: boolean
    status?: boolean
    duration?: boolean
    questionCount?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    questions?: boolean | Quiz$questionsArgs<ExtArgs>
    attempts?: boolean | Quiz$attemptsArgs<ExtArgs>
    _count?: boolean | QuizCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    artistId?: boolean
    artistName?: boolean
    type?: boolean
    status?: boolean
    duration?: boolean
    questionCount?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    artistId?: boolean
    artistName?: boolean
    type?: boolean
    status?: boolean
    duration?: boolean
    questionCount?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["quiz"]>

  export type QuizSelectScalar = {
    id?: boolean
    eventId?: boolean
    artistId?: boolean
    artistName?: boolean
    type?: boolean
    status?: boolean
    duration?: boolean
    questionCount?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuizOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "eventId" | "artistId" | "artistName" | "type" | "status" | "duration" | "questionCount" | "startTime" | "endTime" | "createdAt" | "updatedAt", ExtArgs["result"]["quiz"]>
  export type QuizInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | Quiz$questionsArgs<ExtArgs>
    attempts?: boolean | Quiz$attemptsArgs<ExtArgs>
    _count?: boolean | QuizCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type QuizIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $QuizPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Quiz"
    objects: {
      questions: Prisma.$QuizQuestionPayload<ExtArgs>[]
      attempts: Prisma.$QuizAttemptPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string | null
      artistId: string
      artistName: string
      type: string
      status: string
      duration: number
      questionCount: number
      startTime: Date | null
      endTime: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quiz"]>
    composites: {}
  }

  type QuizGetPayload<S extends boolean | null | undefined | QuizDefaultArgs> = $Result.GetResult<Prisma.$QuizPayload, S>

  type QuizCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizCountAggregateInputType | true
    }

  export interface QuizDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Quiz'], meta: { name: 'Quiz' } }
    /**
     * Find zero or one Quiz that matches the filter.
     * @param {QuizFindUniqueArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizFindUniqueArgs>(args: SelectSubset<T, QuizFindUniqueArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Quiz that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizFindUniqueOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quiz that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindFirstArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizFindFirstArgs>(args?: SelectSubset<T, QuizFindFirstArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Quiz that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindFirstOrThrowArgs} args - Arguments to find a Quiz
     * @example
     * // Get one Quiz
     * const quiz = await prisma.quiz.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Quizzes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Quizzes
     * const quizzes = await prisma.quiz.findMany()
     * 
     * // Get first 10 Quizzes
     * const quizzes = await prisma.quiz.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizWithIdOnly = await prisma.quiz.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizFindManyArgs>(args?: SelectSubset<T, QuizFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Quiz.
     * @param {QuizCreateArgs} args - Arguments to create a Quiz.
     * @example
     * // Create one Quiz
     * const Quiz = await prisma.quiz.create({
     *   data: {
     *     // ... data to create a Quiz
     *   }
     * })
     * 
     */
    create<T extends QuizCreateArgs>(args: SelectSubset<T, QuizCreateArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Quizzes.
     * @param {QuizCreateManyArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quiz = await prisma.quiz.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizCreateManyArgs>(args?: SelectSubset<T, QuizCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Quizzes and returns the data saved in the database.
     * @param {QuizCreateManyAndReturnArgs} args - Arguments to create many Quizzes.
     * @example
     * // Create many Quizzes
     * const quiz = await prisma.quiz.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Quizzes and only return the `id`
     * const quizWithIdOnly = await prisma.quiz.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Quiz.
     * @param {QuizDeleteArgs} args - Arguments to delete one Quiz.
     * @example
     * // Delete one Quiz
     * const Quiz = await prisma.quiz.delete({
     *   where: {
     *     // ... filter to delete one Quiz
     *   }
     * })
     * 
     */
    delete<T extends QuizDeleteArgs>(args: SelectSubset<T, QuizDeleteArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Quiz.
     * @param {QuizUpdateArgs} args - Arguments to update one Quiz.
     * @example
     * // Update one Quiz
     * const quiz = await prisma.quiz.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizUpdateArgs>(args: SelectSubset<T, QuizUpdateArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Quizzes.
     * @param {QuizDeleteManyArgs} args - Arguments to filter Quizzes to delete.
     * @example
     * // Delete a few Quizzes
     * const { count } = await prisma.quiz.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizDeleteManyArgs>(args?: SelectSubset<T, QuizDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Quizzes
     * const quiz = await prisma.quiz.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizUpdateManyArgs>(args: SelectSubset<T, QuizUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Quizzes and returns the data updated in the database.
     * @param {QuizUpdateManyAndReturnArgs} args - Arguments to update many Quizzes.
     * @example
     * // Update many Quizzes
     * const quiz = await prisma.quiz.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Quizzes and only return the `id`
     * const quizWithIdOnly = await prisma.quiz.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Quiz.
     * @param {QuizUpsertArgs} args - Arguments to update or create a Quiz.
     * @example
     * // Update or create a Quiz
     * const quiz = await prisma.quiz.upsert({
     *   create: {
     *     // ... data to create a Quiz
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Quiz we want to update
     *   }
     * })
     */
    upsert<T extends QuizUpsertArgs>(args: SelectSubset<T, QuizUpsertArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Quizzes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizCountArgs} args - Arguments to filter Quizzes to count.
     * @example
     * // Count the number of Quizzes
     * const count = await prisma.quiz.count({
     *   where: {
     *     // ... the filter for the Quizzes we want to count
     *   }
     * })
    **/
    count<T extends QuizCountArgs>(
      args?: Subset<T, QuizCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAggregateArgs>(args: Subset<T, QuizAggregateArgs>): Prisma.PrismaPromise<GetQuizAggregateType<T>>

    /**
     * Group by Quiz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizGroupByArgs['orderBy'] }
        : { orderBy?: QuizGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Quiz model
   */
  readonly fields: QuizFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Quiz.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questions<T extends Quiz$questionsArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attempts<T extends Quiz$attemptsArgs<ExtArgs> = {}>(args?: Subset<T, Quiz$attemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Quiz model
   */
  interface QuizFieldRefs {
    readonly id: FieldRef<"Quiz", 'String'>
    readonly eventId: FieldRef<"Quiz", 'String'>
    readonly artistId: FieldRef<"Quiz", 'String'>
    readonly artistName: FieldRef<"Quiz", 'String'>
    readonly type: FieldRef<"Quiz", 'String'>
    readonly status: FieldRef<"Quiz", 'String'>
    readonly duration: FieldRef<"Quiz", 'Int'>
    readonly questionCount: FieldRef<"Quiz", 'Int'>
    readonly startTime: FieldRef<"Quiz", 'DateTime'>
    readonly endTime: FieldRef<"Quiz", 'DateTime'>
    readonly createdAt: FieldRef<"Quiz", 'DateTime'>
    readonly updatedAt: FieldRef<"Quiz", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Quiz findUnique
   */
  export type QuizFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz findUniqueOrThrow
   */
  export type QuizFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz findFirst
   */
  export type QuizFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz findFirstOrThrow
   */
  export type QuizFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quiz to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Quizzes.
     */
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz findMany
   */
  export type QuizFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter, which Quizzes to fetch.
     */
    where?: QuizWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Quizzes to fetch.
     */
    orderBy?: QuizOrderByWithRelationInput | QuizOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Quizzes.
     */
    cursor?: QuizWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Quizzes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Quizzes.
     */
    skip?: number
    distinct?: QuizScalarFieldEnum | QuizScalarFieldEnum[]
  }

  /**
   * Quiz create
   */
  export type QuizCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The data needed to create a Quiz.
     */
    data: XOR<QuizCreateInput, QuizUncheckedCreateInput>
  }

  /**
   * Quiz createMany
   */
  export type QuizCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Quizzes.
     */
    data: QuizCreateManyInput | QuizCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quiz createManyAndReturn
   */
  export type QuizCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * The data used to create many Quizzes.
     */
    data: QuizCreateManyInput | QuizCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Quiz update
   */
  export type QuizUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The data needed to update a Quiz.
     */
    data: XOR<QuizUpdateInput, QuizUncheckedUpdateInput>
    /**
     * Choose, which Quiz to update.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz updateMany
   */
  export type QuizUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Quizzes.
     */
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyInput>
    /**
     * Filter which Quizzes to update
     */
    where?: QuizWhereInput
    /**
     * Limit how many Quizzes to update.
     */
    limit?: number
  }

  /**
   * Quiz updateManyAndReturn
   */
  export type QuizUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * The data used to update Quizzes.
     */
    data: XOR<QuizUpdateManyMutationInput, QuizUncheckedUpdateManyInput>
    /**
     * Filter which Quizzes to update
     */
    where?: QuizWhereInput
    /**
     * Limit how many Quizzes to update.
     */
    limit?: number
  }

  /**
   * Quiz upsert
   */
  export type QuizUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * The filter to search for the Quiz to update in case it exists.
     */
    where: QuizWhereUniqueInput
    /**
     * In case the Quiz found by the `where` argument doesn't exist, create a new Quiz with this data.
     */
    create: XOR<QuizCreateInput, QuizUncheckedCreateInput>
    /**
     * In case the Quiz was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizUpdateInput, QuizUncheckedUpdateInput>
  }

  /**
   * Quiz delete
   */
  export type QuizDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
    /**
     * Filter which Quiz to delete.
     */
    where: QuizWhereUniqueInput
  }

  /**
   * Quiz deleteMany
   */
  export type QuizDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Quizzes to delete
     */
    where?: QuizWhereInput
    /**
     * Limit how many Quizzes to delete.
     */
    limit?: number
  }

  /**
   * Quiz.questions
   */
  export type Quiz$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    where?: QuizQuestionWhereInput
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    cursor?: QuizQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * Quiz.attempts
   */
  export type Quiz$attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    where?: QuizAttemptWhereInput
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    cursor?: QuizAttemptWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * Quiz without action
   */
  export type QuizDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Quiz
     */
    select?: QuizSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Quiz
     */
    omit?: QuizOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizInclude<ExtArgs> | null
  }


  /**
   * Model QuizQuestion
   */

  export type AggregateQuizQuestion = {
    _count: QuizQuestionCountAggregateOutputType | null
    _avg: QuizQuestionAvgAggregateOutputType | null
    _sum: QuizQuestionSumAggregateOutputType | null
    _min: QuizQuestionMinAggregateOutputType | null
    _max: QuizQuestionMaxAggregateOutputType | null
  }

  export type QuizQuestionAvgAggregateOutputType = {
    timeLimit: number | null
    orderIndex: number | null
  }

  export type QuizQuestionSumAggregateOutputType = {
    timeLimit: number | null
    orderIndex: number | null
  }

  export type QuizQuestionMinAggregateOutputType = {
    id: string | null
    quizId: string | null
    question: string | null
    type: string | null
    correctAnswer: string | null
    imageUrl: string | null
    timeLimit: number | null
    difficulty: string | null
    orderIndex: number | null
    createdAt: Date | null
  }

  export type QuizQuestionMaxAggregateOutputType = {
    id: string | null
    quizId: string | null
    question: string | null
    type: string | null
    correctAnswer: string | null
    imageUrl: string | null
    timeLimit: number | null
    difficulty: string | null
    orderIndex: number | null
    createdAt: Date | null
  }

  export type QuizQuestionCountAggregateOutputType = {
    id: number
    quizId: number
    question: number
    type: number
    options: number
    correctAnswer: number
    imageUrl: number
    timeLimit: number
    difficulty: number
    orderIndex: number
    createdAt: number
    _all: number
  }


  export type QuizQuestionAvgAggregateInputType = {
    timeLimit?: true
    orderIndex?: true
  }

  export type QuizQuestionSumAggregateInputType = {
    timeLimit?: true
    orderIndex?: true
  }

  export type QuizQuestionMinAggregateInputType = {
    id?: true
    quizId?: true
    question?: true
    type?: true
    correctAnswer?: true
    imageUrl?: true
    timeLimit?: true
    difficulty?: true
    orderIndex?: true
    createdAt?: true
  }

  export type QuizQuestionMaxAggregateInputType = {
    id?: true
    quizId?: true
    question?: true
    type?: true
    correctAnswer?: true
    imageUrl?: true
    timeLimit?: true
    difficulty?: true
    orderIndex?: true
    createdAt?: true
  }

  export type QuizQuestionCountAggregateInputType = {
    id?: true
    quizId?: true
    question?: true
    type?: true
    options?: true
    correctAnswer?: true
    imageUrl?: true
    timeLimit?: true
    difficulty?: true
    orderIndex?: true
    createdAt?: true
    _all?: true
  }

  export type QuizQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestion to aggregate.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizQuestions
    **/
    _count?: true | QuizQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizQuestionMaxAggregateInputType
  }

  export type GetQuizQuestionAggregateType<T extends QuizQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizQuestion[P]>
      : GetScalarType<T[P], AggregateQuizQuestion[P]>
  }




  export type QuizQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizQuestionWhereInput
    orderBy?: QuizQuestionOrderByWithAggregationInput | QuizQuestionOrderByWithAggregationInput[]
    by: QuizQuestionScalarFieldEnum[] | QuizQuestionScalarFieldEnum
    having?: QuizQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizQuestionCountAggregateInputType | true
    _avg?: QuizQuestionAvgAggregateInputType
    _sum?: QuizQuestionSumAggregateInputType
    _min?: QuizQuestionMinAggregateInputType
    _max?: QuizQuestionMaxAggregateInputType
  }

  export type QuizQuestionGroupByOutputType = {
    id: string
    quizId: string
    question: string
    type: string
    options: string[]
    correctAnswer: string
    imageUrl: string | null
    timeLimit: number
    difficulty: string
    orderIndex: number
    createdAt: Date
    _count: QuizQuestionCountAggregateOutputType | null
    _avg: QuizQuestionAvgAggregateOutputType | null
    _sum: QuizQuestionSumAggregateOutputType | null
    _min: QuizQuestionMinAggregateOutputType | null
    _max: QuizQuestionMaxAggregateOutputType | null
  }

  type GetQuizQuestionGroupByPayload<T extends QuizQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuizQuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuizQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    question?: boolean
    type?: boolean
    options?: boolean
    correctAnswer?: boolean
    imageUrl?: boolean
    timeLimit?: boolean
    difficulty?: boolean
    orderIndex?: boolean
    createdAt?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    question?: boolean
    type?: boolean
    options?: boolean
    correctAnswer?: boolean
    imageUrl?: boolean
    timeLimit?: boolean
    difficulty?: boolean
    orderIndex?: boolean
    createdAt?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    question?: boolean
    type?: boolean
    options?: boolean
    correctAnswer?: boolean
    imageUrl?: boolean
    timeLimit?: boolean
    difficulty?: boolean
    orderIndex?: boolean
    createdAt?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizQuestion"]>

  export type QuizQuestionSelectScalar = {
    id?: boolean
    quizId?: boolean
    question?: boolean
    type?: boolean
    options?: boolean
    correctAnswer?: boolean
    imageUrl?: boolean
    timeLimit?: boolean
    difficulty?: boolean
    orderIndex?: boolean
    createdAt?: boolean
  }

  export type QuizQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quizId" | "question" | "type" | "options" | "correctAnswer" | "imageUrl" | "timeLimit" | "difficulty" | "orderIndex" | "createdAt", ExtArgs["result"]["quizQuestion"]>
  export type QuizQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }
  export type QuizQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }
  export type QuizQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
  }

  export type $QuizQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizQuestion"
    objects: {
      quiz: Prisma.$QuizPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quizId: string
      question: string
      type: string
      options: string[]
      correctAnswer: string
      imageUrl: string | null
      timeLimit: number
      difficulty: string
      orderIndex: number
      createdAt: Date
    }, ExtArgs["result"]["quizQuestion"]>
    composites: {}
  }

  type QuizQuestionGetPayload<S extends boolean | null | undefined | QuizQuestionDefaultArgs> = $Result.GetResult<Prisma.$QuizQuestionPayload, S>

  type QuizQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizQuestionCountAggregateInputType | true
    }

  export interface QuizQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizQuestion'], meta: { name: 'QuizQuestion' } }
    /**
     * Find zero or one QuizQuestion that matches the filter.
     * @param {QuizQuestionFindUniqueArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizQuestionFindUniqueArgs>(args: SelectSubset<T, QuizQuestionFindUniqueArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizQuestionFindUniqueOrThrowArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindFirstArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizQuestionFindFirstArgs>(args?: SelectSubset<T, QuizQuestionFindFirstArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindFirstOrThrowArgs} args - Arguments to find a QuizQuestion
     * @example
     * // Get one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizQuestions
     * const quizQuestions = await prisma.quizQuestion.findMany()
     * 
     * // Get first 10 QuizQuestions
     * const quizQuestions = await prisma.quizQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizQuestionFindManyArgs>(args?: SelectSubset<T, QuizQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizQuestion.
     * @param {QuizQuestionCreateArgs} args - Arguments to create a QuizQuestion.
     * @example
     * // Create one QuizQuestion
     * const QuizQuestion = await prisma.quizQuestion.create({
     *   data: {
     *     // ... data to create a QuizQuestion
     *   }
     * })
     * 
     */
    create<T extends QuizQuestionCreateArgs>(args: SelectSubset<T, QuizQuestionCreateArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizQuestions.
     * @param {QuizQuestionCreateManyArgs} args - Arguments to create many QuizQuestions.
     * @example
     * // Create many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizQuestionCreateManyArgs>(args?: SelectSubset<T, QuizQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizQuestions and returns the data saved in the database.
     * @param {QuizQuestionCreateManyAndReturnArgs} args - Arguments to create many QuizQuestions.
     * @example
     * // Create many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizQuestions and only return the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizQuestion.
     * @param {QuizQuestionDeleteArgs} args - Arguments to delete one QuizQuestion.
     * @example
     * // Delete one QuizQuestion
     * const QuizQuestion = await prisma.quizQuestion.delete({
     *   where: {
     *     // ... filter to delete one QuizQuestion
     *   }
     * })
     * 
     */
    delete<T extends QuizQuestionDeleteArgs>(args: SelectSubset<T, QuizQuestionDeleteArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizQuestion.
     * @param {QuizQuestionUpdateArgs} args - Arguments to update one QuizQuestion.
     * @example
     * // Update one QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizQuestionUpdateArgs>(args: SelectSubset<T, QuizQuestionUpdateArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizQuestions.
     * @param {QuizQuestionDeleteManyArgs} args - Arguments to filter QuizQuestions to delete.
     * @example
     * // Delete a few QuizQuestions
     * const { count } = await prisma.quizQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizQuestionDeleteManyArgs>(args?: SelectSubset<T, QuizQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizQuestionUpdateManyArgs>(args: SelectSubset<T, QuizQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizQuestions and returns the data updated in the database.
     * @param {QuizQuestionUpdateManyAndReturnArgs} args - Arguments to update many QuizQuestions.
     * @example
     * // Update many QuizQuestions
     * const quizQuestion = await prisma.quizQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizQuestions and only return the `id`
     * const quizQuestionWithIdOnly = await prisma.quizQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizQuestion.
     * @param {QuizQuestionUpsertArgs} args - Arguments to update or create a QuizQuestion.
     * @example
     * // Update or create a QuizQuestion
     * const quizQuestion = await prisma.quizQuestion.upsert({
     *   create: {
     *     // ... data to create a QuizQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizQuestion we want to update
     *   }
     * })
     */
    upsert<T extends QuizQuestionUpsertArgs>(args: SelectSubset<T, QuizQuestionUpsertArgs<ExtArgs>>): Prisma__QuizQuestionClient<$Result.GetResult<Prisma.$QuizQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionCountArgs} args - Arguments to filter QuizQuestions to count.
     * @example
     * // Count the number of QuizQuestions
     * const count = await prisma.quizQuestion.count({
     *   where: {
     *     // ... the filter for the QuizQuestions we want to count
     *   }
     * })
    **/
    count<T extends QuizQuestionCountArgs>(
      args?: Subset<T, QuizQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizQuestionAggregateArgs>(args: Subset<T, QuizQuestionAggregateArgs>): Prisma.PrismaPromise<GetQuizQuestionAggregateType<T>>

    /**
     * Group by QuizQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizQuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuizQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizQuestion model
   */
  readonly fields: QuizQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quiz<T extends QuizDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizDefaultArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizQuestion model
   */
  interface QuizQuestionFieldRefs {
    readonly id: FieldRef<"QuizQuestion", 'String'>
    readonly quizId: FieldRef<"QuizQuestion", 'String'>
    readonly question: FieldRef<"QuizQuestion", 'String'>
    readonly type: FieldRef<"QuizQuestion", 'String'>
    readonly options: FieldRef<"QuizQuestion", 'String[]'>
    readonly correctAnswer: FieldRef<"QuizQuestion", 'String'>
    readonly imageUrl: FieldRef<"QuizQuestion", 'String'>
    readonly timeLimit: FieldRef<"QuizQuestion", 'Int'>
    readonly difficulty: FieldRef<"QuizQuestion", 'String'>
    readonly orderIndex: FieldRef<"QuizQuestion", 'Int'>
    readonly createdAt: FieldRef<"QuizQuestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizQuestion findUnique
   */
  export type QuizQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion findUniqueOrThrow
   */
  export type QuizQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion findFirst
   */
  export type QuizQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestions.
     */
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion findFirstOrThrow
   */
  export type QuizQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestion to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizQuestions.
     */
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion findMany
   */
  export type QuizQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuizQuestions to fetch.
     */
    where?: QuizQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizQuestions to fetch.
     */
    orderBy?: QuizQuestionOrderByWithRelationInput | QuizQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizQuestions.
     */
    cursor?: QuizQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizQuestions.
     */
    skip?: number
    distinct?: QuizQuestionScalarFieldEnum | QuizQuestionScalarFieldEnum[]
  }

  /**
   * QuizQuestion create
   */
  export type QuizQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizQuestion.
     */
    data: XOR<QuizQuestionCreateInput, QuizQuestionUncheckedCreateInput>
  }

  /**
   * QuizQuestion createMany
   */
  export type QuizQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizQuestions.
     */
    data: QuizQuestionCreateManyInput | QuizQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizQuestion createManyAndReturn
   */
  export type QuizQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many QuizQuestions.
     */
    data: QuizQuestionCreateManyInput | QuizQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizQuestion update
   */
  export type QuizQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizQuestion.
     */
    data: XOR<QuizQuestionUpdateInput, QuizQuestionUncheckedUpdateInput>
    /**
     * Choose, which QuizQuestion to update.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion updateMany
   */
  export type QuizQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizQuestions.
     */
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestions to update
     */
    where?: QuizQuestionWhereInput
    /**
     * Limit how many QuizQuestions to update.
     */
    limit?: number
  }

  /**
   * QuizQuestion updateManyAndReturn
   */
  export type QuizQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * The data used to update QuizQuestions.
     */
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuizQuestions to update
     */
    where?: QuizQuestionWhereInput
    /**
     * Limit how many QuizQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizQuestion upsert
   */
  export type QuizQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizQuestion to update in case it exists.
     */
    where: QuizQuestionWhereUniqueInput
    /**
     * In case the QuizQuestion found by the `where` argument doesn't exist, create a new QuizQuestion with this data.
     */
    create: XOR<QuizQuestionCreateInput, QuizQuestionUncheckedCreateInput>
    /**
     * In case the QuizQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizQuestionUpdateInput, QuizQuestionUncheckedUpdateInput>
  }

  /**
   * QuizQuestion delete
   */
  export type QuizQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
    /**
     * Filter which QuizQuestion to delete.
     */
    where: QuizQuestionWhereUniqueInput
  }

  /**
   * QuizQuestion deleteMany
   */
  export type QuizQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizQuestions to delete
     */
    where?: QuizQuestionWhereInput
    /**
     * Limit how many QuizQuestions to delete.
     */
    limit?: number
  }

  /**
   * QuizQuestion without action
   */
  export type QuizQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizQuestion
     */
    select?: QuizQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizQuestion
     */
    omit?: QuizQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizQuestionInclude<ExtArgs> | null
  }


  /**
   * Model QuizAttempt
   */

  export type AggregateQuizAttempt = {
    _count: QuizAttemptCountAggregateOutputType | null
    _avg: QuizAttemptAvgAggregateOutputType | null
    _sum: QuizAttemptSumAggregateOutputType | null
    _min: QuizAttemptMinAggregateOutputType | null
    _max: QuizAttemptMaxAggregateOutputType | null
  }

  export type QuizAttemptAvgAggregateOutputType = {
    correctAnswers: number | null
    totalQuestions: number | null
    avgResponseTime: number | null
    responseTimeStdDev: number | null
    streak: number | null
    maxStreak: number | null
    finalScore: number | null
    speedScore: number | null
    accuracyScore: number | null
    consistencyScore: number | null
    rank: number | null
  }

  export type QuizAttemptSumAggregateOutputType = {
    correctAnswers: number | null
    totalQuestions: number | null
    avgResponseTime: number | null
    responseTimeStdDev: number | null
    streak: number | null
    maxStreak: number | null
    finalScore: number | null
    speedScore: number | null
    accuracyScore: number | null
    consistencyScore: number | null
    rank: number | null
  }

  export type QuizAttemptMinAggregateOutputType = {
    id: string | null
    quizId: string | null
    userId: string | null
    correctAnswers: number | null
    totalQuestions: number | null
    avgResponseTime: number | null
    responseTimeStdDev: number | null
    streak: number | null
    maxStreak: number | null
    finalScore: number | null
    speedScore: number | null
    accuracyScore: number | null
    consistencyScore: number | null
    rank: number | null
    status: string | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type QuizAttemptMaxAggregateOutputType = {
    id: string | null
    quizId: string | null
    userId: string | null
    correctAnswers: number | null
    totalQuestions: number | null
    avgResponseTime: number | null
    responseTimeStdDev: number | null
    streak: number | null
    maxStreak: number | null
    finalScore: number | null
    speedScore: number | null
    accuracyScore: number | null
    consistencyScore: number | null
    rank: number | null
    status: string | null
    startedAt: Date | null
    completedAt: Date | null
  }

  export type QuizAttemptCountAggregateOutputType = {
    id: number
    quizId: number
    userId: number
    correctAnswers: number
    totalQuestions: number
    avgResponseTime: number
    responseTimeStdDev: number
    streak: number
    maxStreak: number
    finalScore: number
    speedScore: number
    accuracyScore: number
    consistencyScore: number
    rank: number
    status: number
    startedAt: number
    completedAt: number
    _all: number
  }


  export type QuizAttemptAvgAggregateInputType = {
    correctAnswers?: true
    totalQuestions?: true
    avgResponseTime?: true
    responseTimeStdDev?: true
    streak?: true
    maxStreak?: true
    finalScore?: true
    speedScore?: true
    accuracyScore?: true
    consistencyScore?: true
    rank?: true
  }

  export type QuizAttemptSumAggregateInputType = {
    correctAnswers?: true
    totalQuestions?: true
    avgResponseTime?: true
    responseTimeStdDev?: true
    streak?: true
    maxStreak?: true
    finalScore?: true
    speedScore?: true
    accuracyScore?: true
    consistencyScore?: true
    rank?: true
  }

  export type QuizAttemptMinAggregateInputType = {
    id?: true
    quizId?: true
    userId?: true
    correctAnswers?: true
    totalQuestions?: true
    avgResponseTime?: true
    responseTimeStdDev?: true
    streak?: true
    maxStreak?: true
    finalScore?: true
    speedScore?: true
    accuracyScore?: true
    consistencyScore?: true
    rank?: true
    status?: true
    startedAt?: true
    completedAt?: true
  }

  export type QuizAttemptMaxAggregateInputType = {
    id?: true
    quizId?: true
    userId?: true
    correctAnswers?: true
    totalQuestions?: true
    avgResponseTime?: true
    responseTimeStdDev?: true
    streak?: true
    maxStreak?: true
    finalScore?: true
    speedScore?: true
    accuracyScore?: true
    consistencyScore?: true
    rank?: true
    status?: true
    startedAt?: true
    completedAt?: true
  }

  export type QuizAttemptCountAggregateInputType = {
    id?: true
    quizId?: true
    userId?: true
    correctAnswers?: true
    totalQuestions?: true
    avgResponseTime?: true
    responseTimeStdDev?: true
    streak?: true
    maxStreak?: true
    finalScore?: true
    speedScore?: true
    accuracyScore?: true
    consistencyScore?: true
    rank?: true
    status?: true
    startedAt?: true
    completedAt?: true
    _all?: true
  }

  export type QuizAttemptAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizAttempt to aggregate.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizAttempts
    **/
    _count?: true | QuizAttemptCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizAttemptAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizAttemptSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizAttemptMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizAttemptMaxAggregateInputType
  }

  export type GetQuizAttemptAggregateType<T extends QuizAttemptAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizAttempt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizAttempt[P]>
      : GetScalarType<T[P], AggregateQuizAttempt[P]>
  }




  export type QuizAttemptGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizAttemptWhereInput
    orderBy?: QuizAttemptOrderByWithAggregationInput | QuizAttemptOrderByWithAggregationInput[]
    by: QuizAttemptScalarFieldEnum[] | QuizAttemptScalarFieldEnum
    having?: QuizAttemptScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizAttemptCountAggregateInputType | true
    _avg?: QuizAttemptAvgAggregateInputType
    _sum?: QuizAttemptSumAggregateInputType
    _min?: QuizAttemptMinAggregateInputType
    _max?: QuizAttemptMaxAggregateInputType
  }

  export type QuizAttemptGroupByOutputType = {
    id: string
    quizId: string
    userId: string
    correctAnswers: number
    totalQuestions: number
    avgResponseTime: number
    responseTimeStdDev: number
    streak: number
    maxStreak: number
    finalScore: number
    speedScore: number
    accuracyScore: number
    consistencyScore: number
    rank: number | null
    status: string
    startedAt: Date
    completedAt: Date | null
    _count: QuizAttemptCountAggregateOutputType | null
    _avg: QuizAttemptAvgAggregateOutputType | null
    _sum: QuizAttemptSumAggregateOutputType | null
    _min: QuizAttemptMinAggregateOutputType | null
    _max: QuizAttemptMaxAggregateOutputType | null
  }

  type GetQuizAttemptGroupByPayload<T extends QuizAttemptGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizAttemptGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizAttemptGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizAttemptGroupByOutputType[P]>
            : GetScalarType<T[P], QuizAttemptGroupByOutputType[P]>
        }
      >
    >


  export type QuizAttemptSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    userId?: boolean
    correctAnswers?: boolean
    totalQuestions?: boolean
    avgResponseTime?: boolean
    responseTimeStdDev?: boolean
    streak?: boolean
    maxStreak?: boolean
    finalScore?: boolean
    speedScore?: boolean
    accuracyScore?: boolean
    consistencyScore?: boolean
    rank?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    responses?: boolean | QuizAttempt$responsesArgs<ExtArgs>
    _count?: boolean | QuizAttemptCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAttempt"]>

  export type QuizAttemptSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    userId?: boolean
    correctAnswers?: boolean
    totalQuestions?: boolean
    avgResponseTime?: boolean
    responseTimeStdDev?: boolean
    streak?: boolean
    maxStreak?: boolean
    finalScore?: boolean
    speedScore?: boolean
    accuracyScore?: boolean
    consistencyScore?: boolean
    rank?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAttempt"]>

  export type QuizAttemptSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quizId?: boolean
    userId?: boolean
    correctAnswers?: boolean
    totalQuestions?: boolean
    avgResponseTime?: boolean
    responseTimeStdDev?: boolean
    streak?: boolean
    maxStreak?: boolean
    finalScore?: boolean
    speedScore?: boolean
    accuracyScore?: boolean
    consistencyScore?: boolean
    rank?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizAttempt"]>

  export type QuizAttemptSelectScalar = {
    id?: boolean
    quizId?: boolean
    userId?: boolean
    correctAnswers?: boolean
    totalQuestions?: boolean
    avgResponseTime?: boolean
    responseTimeStdDev?: boolean
    streak?: boolean
    maxStreak?: boolean
    finalScore?: boolean
    speedScore?: boolean
    accuracyScore?: boolean
    consistencyScore?: boolean
    rank?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
  }

  export type QuizAttemptOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "quizId" | "userId" | "correctAnswers" | "totalQuestions" | "avgResponseTime" | "responseTimeStdDev" | "streak" | "maxStreak" | "finalScore" | "speedScore" | "accuracyScore" | "consistencyScore" | "rank" | "status" | "startedAt" | "completedAt", ExtArgs["result"]["quizAttempt"]>
  export type QuizAttemptInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    responses?: boolean | QuizAttempt$responsesArgs<ExtArgs>
    _count?: boolean | QuizAttemptCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuizAttemptIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type QuizAttemptIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    quiz?: boolean | QuizDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $QuizAttemptPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizAttempt"
    objects: {
      quiz: Prisma.$QuizPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      responses: Prisma.$QuizResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      quizId: string
      userId: string
      correctAnswers: number
      totalQuestions: number
      avgResponseTime: number
      responseTimeStdDev: number
      streak: number
      maxStreak: number
      finalScore: number
      speedScore: number
      accuracyScore: number
      consistencyScore: number
      rank: number | null
      status: string
      startedAt: Date
      completedAt: Date | null
    }, ExtArgs["result"]["quizAttempt"]>
    composites: {}
  }

  type QuizAttemptGetPayload<S extends boolean | null | undefined | QuizAttemptDefaultArgs> = $Result.GetResult<Prisma.$QuizAttemptPayload, S>

  type QuizAttemptCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizAttemptFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizAttemptCountAggregateInputType | true
    }

  export interface QuizAttemptDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizAttempt'], meta: { name: 'QuizAttempt' } }
    /**
     * Find zero or one QuizAttempt that matches the filter.
     * @param {QuizAttemptFindUniqueArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizAttemptFindUniqueArgs>(args: SelectSubset<T, QuizAttemptFindUniqueArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizAttempt that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizAttemptFindUniqueOrThrowArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizAttemptFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizAttemptFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizAttempt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptFindFirstArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizAttemptFindFirstArgs>(args?: SelectSubset<T, QuizAttemptFindFirstArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizAttempt that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptFindFirstOrThrowArgs} args - Arguments to find a QuizAttempt
     * @example
     * // Get one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizAttemptFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizAttemptFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizAttempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizAttempts
     * const quizAttempts = await prisma.quizAttempt.findMany()
     * 
     * // Get first 10 QuizAttempts
     * const quizAttempts = await prisma.quizAttempt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizAttemptWithIdOnly = await prisma.quizAttempt.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizAttemptFindManyArgs>(args?: SelectSubset<T, QuizAttemptFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizAttempt.
     * @param {QuizAttemptCreateArgs} args - Arguments to create a QuizAttempt.
     * @example
     * // Create one QuizAttempt
     * const QuizAttempt = await prisma.quizAttempt.create({
     *   data: {
     *     // ... data to create a QuizAttempt
     *   }
     * })
     * 
     */
    create<T extends QuizAttemptCreateArgs>(args: SelectSubset<T, QuizAttemptCreateArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizAttempts.
     * @param {QuizAttemptCreateManyArgs} args - Arguments to create many QuizAttempts.
     * @example
     * // Create many QuizAttempts
     * const quizAttempt = await prisma.quizAttempt.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizAttemptCreateManyArgs>(args?: SelectSubset<T, QuizAttemptCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizAttempts and returns the data saved in the database.
     * @param {QuizAttemptCreateManyAndReturnArgs} args - Arguments to create many QuizAttempts.
     * @example
     * // Create many QuizAttempts
     * const quizAttempt = await prisma.quizAttempt.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizAttempts and only return the `id`
     * const quizAttemptWithIdOnly = await prisma.quizAttempt.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizAttemptCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizAttemptCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizAttempt.
     * @param {QuizAttemptDeleteArgs} args - Arguments to delete one QuizAttempt.
     * @example
     * // Delete one QuizAttempt
     * const QuizAttempt = await prisma.quizAttempt.delete({
     *   where: {
     *     // ... filter to delete one QuizAttempt
     *   }
     * })
     * 
     */
    delete<T extends QuizAttemptDeleteArgs>(args: SelectSubset<T, QuizAttemptDeleteArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizAttempt.
     * @param {QuizAttemptUpdateArgs} args - Arguments to update one QuizAttempt.
     * @example
     * // Update one QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizAttemptUpdateArgs>(args: SelectSubset<T, QuizAttemptUpdateArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizAttempts.
     * @param {QuizAttemptDeleteManyArgs} args - Arguments to filter QuizAttempts to delete.
     * @example
     * // Delete a few QuizAttempts
     * const { count } = await prisma.quizAttempt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizAttemptDeleteManyArgs>(args?: SelectSubset<T, QuizAttemptDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizAttempts
     * const quizAttempt = await prisma.quizAttempt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizAttemptUpdateManyArgs>(args: SelectSubset<T, QuizAttemptUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizAttempts and returns the data updated in the database.
     * @param {QuizAttemptUpdateManyAndReturnArgs} args - Arguments to update many QuizAttempts.
     * @example
     * // Update many QuizAttempts
     * const quizAttempt = await prisma.quizAttempt.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizAttempts and only return the `id`
     * const quizAttemptWithIdOnly = await prisma.quizAttempt.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizAttemptUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizAttemptUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizAttempt.
     * @param {QuizAttemptUpsertArgs} args - Arguments to update or create a QuizAttempt.
     * @example
     * // Update or create a QuizAttempt
     * const quizAttempt = await prisma.quizAttempt.upsert({
     *   create: {
     *     // ... data to create a QuizAttempt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizAttempt we want to update
     *   }
     * })
     */
    upsert<T extends QuizAttemptUpsertArgs>(args: SelectSubset<T, QuizAttemptUpsertArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizAttempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptCountArgs} args - Arguments to filter QuizAttempts to count.
     * @example
     * // Count the number of QuizAttempts
     * const count = await prisma.quizAttempt.count({
     *   where: {
     *     // ... the filter for the QuizAttempts we want to count
     *   }
     * })
    **/
    count<T extends QuizAttemptCountArgs>(
      args?: Subset<T, QuizAttemptCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizAttemptCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizAttemptAggregateArgs>(args: Subset<T, QuizAttemptAggregateArgs>): Prisma.PrismaPromise<GetQuizAttemptAggregateType<T>>

    /**
     * Group by QuizAttempt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizAttemptGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizAttemptGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizAttemptGroupByArgs['orderBy'] }
        : { orderBy?: QuizAttemptGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizAttemptGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizAttemptGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizAttempt model
   */
  readonly fields: QuizAttemptFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizAttempt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizAttemptClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    quiz<T extends QuizDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizDefaultArgs<ExtArgs>>): Prisma__QuizClient<$Result.GetResult<Prisma.$QuizPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    responses<T extends QuizAttempt$responsesArgs<ExtArgs> = {}>(args?: Subset<T, QuizAttempt$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizAttempt model
   */
  interface QuizAttemptFieldRefs {
    readonly id: FieldRef<"QuizAttempt", 'String'>
    readonly quizId: FieldRef<"QuizAttempt", 'String'>
    readonly userId: FieldRef<"QuizAttempt", 'String'>
    readonly correctAnswers: FieldRef<"QuizAttempt", 'Int'>
    readonly totalQuestions: FieldRef<"QuizAttempt", 'Int'>
    readonly avgResponseTime: FieldRef<"QuizAttempt", 'Float'>
    readonly responseTimeStdDev: FieldRef<"QuizAttempt", 'Float'>
    readonly streak: FieldRef<"QuizAttempt", 'Int'>
    readonly maxStreak: FieldRef<"QuizAttempt", 'Int'>
    readonly finalScore: FieldRef<"QuizAttempt", 'Float'>
    readonly speedScore: FieldRef<"QuizAttempt", 'Float'>
    readonly accuracyScore: FieldRef<"QuizAttempt", 'Float'>
    readonly consistencyScore: FieldRef<"QuizAttempt", 'Float'>
    readonly rank: FieldRef<"QuizAttempt", 'Int'>
    readonly status: FieldRef<"QuizAttempt", 'String'>
    readonly startedAt: FieldRef<"QuizAttempt", 'DateTime'>
    readonly completedAt: FieldRef<"QuizAttempt", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizAttempt findUnique
   */
  export type QuizAttemptFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt findUniqueOrThrow
   */
  export type QuizAttemptFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt findFirst
   */
  export type QuizAttemptFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizAttempts.
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizAttempts.
     */
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * QuizAttempt findFirstOrThrow
   */
  export type QuizAttemptFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempt to fetch.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizAttempts.
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizAttempts.
     */
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * QuizAttempt findMany
   */
  export type QuizAttemptFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter, which QuizAttempts to fetch.
     */
    where?: QuizAttemptWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizAttempts to fetch.
     */
    orderBy?: QuizAttemptOrderByWithRelationInput | QuizAttemptOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizAttempts.
     */
    cursor?: QuizAttemptWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizAttempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizAttempts.
     */
    skip?: number
    distinct?: QuizAttemptScalarFieldEnum | QuizAttemptScalarFieldEnum[]
  }

  /**
   * QuizAttempt create
   */
  export type QuizAttemptCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizAttempt.
     */
    data: XOR<QuizAttemptCreateInput, QuizAttemptUncheckedCreateInput>
  }

  /**
   * QuizAttempt createMany
   */
  export type QuizAttemptCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizAttempts.
     */
    data: QuizAttemptCreateManyInput | QuizAttemptCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizAttempt createManyAndReturn
   */
  export type QuizAttemptCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * The data used to create many QuizAttempts.
     */
    data: QuizAttemptCreateManyInput | QuizAttemptCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizAttempt update
   */
  export type QuizAttemptUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizAttempt.
     */
    data: XOR<QuizAttemptUpdateInput, QuizAttemptUncheckedUpdateInput>
    /**
     * Choose, which QuizAttempt to update.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt updateMany
   */
  export type QuizAttemptUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizAttempts.
     */
    data: XOR<QuizAttemptUpdateManyMutationInput, QuizAttemptUncheckedUpdateManyInput>
    /**
     * Filter which QuizAttempts to update
     */
    where?: QuizAttemptWhereInput
    /**
     * Limit how many QuizAttempts to update.
     */
    limit?: number
  }

  /**
   * QuizAttempt updateManyAndReturn
   */
  export type QuizAttemptUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * The data used to update QuizAttempts.
     */
    data: XOR<QuizAttemptUpdateManyMutationInput, QuizAttemptUncheckedUpdateManyInput>
    /**
     * Filter which QuizAttempts to update
     */
    where?: QuizAttemptWhereInput
    /**
     * Limit how many QuizAttempts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizAttempt upsert
   */
  export type QuizAttemptUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizAttempt to update in case it exists.
     */
    where: QuizAttemptWhereUniqueInput
    /**
     * In case the QuizAttempt found by the `where` argument doesn't exist, create a new QuizAttempt with this data.
     */
    create: XOR<QuizAttemptCreateInput, QuizAttemptUncheckedCreateInput>
    /**
     * In case the QuizAttempt was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizAttemptUpdateInput, QuizAttemptUncheckedUpdateInput>
  }

  /**
   * QuizAttempt delete
   */
  export type QuizAttemptDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
    /**
     * Filter which QuizAttempt to delete.
     */
    where: QuizAttemptWhereUniqueInput
  }

  /**
   * QuizAttempt deleteMany
   */
  export type QuizAttemptDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizAttempts to delete
     */
    where?: QuizAttemptWhereInput
    /**
     * Limit how many QuizAttempts to delete.
     */
    limit?: number
  }

  /**
   * QuizAttempt.responses
   */
  export type QuizAttempt$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResponse
     */
    select?: QuizResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResponse
     */
    omit?: QuizResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResponseInclude<ExtArgs> | null
    where?: QuizResponseWhereInput
    orderBy?: QuizResponseOrderByWithRelationInput | QuizResponseOrderByWithRelationInput[]
    cursor?: QuizResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuizResponseScalarFieldEnum | QuizResponseScalarFieldEnum[]
  }

  /**
   * QuizAttempt without action
   */
  export type QuizAttemptDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizAttempt
     */
    select?: QuizAttemptSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizAttempt
     */
    omit?: QuizAttemptOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizAttemptInclude<ExtArgs> | null
  }


  /**
   * Model QuizResponse
   */

  export type AggregateQuizResponse = {
    _count: QuizResponseCountAggregateOutputType | null
    _avg: QuizResponseAvgAggregateOutputType | null
    _sum: QuizResponseSumAggregateOutputType | null
    _min: QuizResponseMinAggregateOutputType | null
    _max: QuizResponseMaxAggregateOutputType | null
  }

  export type QuizResponseAvgAggregateOutputType = {
    responseTime: number | null
  }

  export type QuizResponseSumAggregateOutputType = {
    responseTime: number | null
  }

  export type QuizResponseMinAggregateOutputType = {
    id: string | null
    attemptId: string | null
    questionId: string | null
    answer: string | null
    isCorrect: boolean | null
    responseTime: number | null
    answeredAt: Date | null
  }

  export type QuizResponseMaxAggregateOutputType = {
    id: string | null
    attemptId: string | null
    questionId: string | null
    answer: string | null
    isCorrect: boolean | null
    responseTime: number | null
    answeredAt: Date | null
  }

  export type QuizResponseCountAggregateOutputType = {
    id: number
    attemptId: number
    questionId: number
    answer: number
    isCorrect: number
    responseTime: number
    answeredAt: number
    _all: number
  }


  export type QuizResponseAvgAggregateInputType = {
    responseTime?: true
  }

  export type QuizResponseSumAggregateInputType = {
    responseTime?: true
  }

  export type QuizResponseMinAggregateInputType = {
    id?: true
    attemptId?: true
    questionId?: true
    answer?: true
    isCorrect?: true
    responseTime?: true
    answeredAt?: true
  }

  export type QuizResponseMaxAggregateInputType = {
    id?: true
    attemptId?: true
    questionId?: true
    answer?: true
    isCorrect?: true
    responseTime?: true
    answeredAt?: true
  }

  export type QuizResponseCountAggregateInputType = {
    id?: true
    attemptId?: true
    questionId?: true
    answer?: true
    isCorrect?: true
    responseTime?: true
    answeredAt?: true
    _all?: true
  }

  export type QuizResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizResponse to aggregate.
     */
    where?: QuizResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizResponses to fetch.
     */
    orderBy?: QuizResponseOrderByWithRelationInput | QuizResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizResponses
    **/
    _count?: true | QuizResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizResponseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizResponseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizResponseMaxAggregateInputType
  }

  export type GetQuizResponseAggregateType<T extends QuizResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizResponse[P]>
      : GetScalarType<T[P], AggregateQuizResponse[P]>
  }




  export type QuizResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizResponseWhereInput
    orderBy?: QuizResponseOrderByWithAggregationInput | QuizResponseOrderByWithAggregationInput[]
    by: QuizResponseScalarFieldEnum[] | QuizResponseScalarFieldEnum
    having?: QuizResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizResponseCountAggregateInputType | true
    _avg?: QuizResponseAvgAggregateInputType
    _sum?: QuizResponseSumAggregateInputType
    _min?: QuizResponseMinAggregateInputType
    _max?: QuizResponseMaxAggregateInputType
  }

  export type QuizResponseGroupByOutputType = {
    id: string
    attemptId: string
    questionId: string
    answer: string
    isCorrect: boolean
    responseTime: number
    answeredAt: Date
    _count: QuizResponseCountAggregateOutputType | null
    _avg: QuizResponseAvgAggregateOutputType | null
    _sum: QuizResponseSumAggregateOutputType | null
    _min: QuizResponseMinAggregateOutputType | null
    _max: QuizResponseMaxAggregateOutputType | null
  }

  type GetQuizResponseGroupByPayload<T extends QuizResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizResponseGroupByOutputType[P]>
            : GetScalarType<T[P], QuizResponseGroupByOutputType[P]>
        }
      >
    >


  export type QuizResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attemptId?: boolean
    questionId?: boolean
    answer?: boolean
    isCorrect?: boolean
    responseTime?: boolean
    answeredAt?: boolean
    attempt?: boolean | QuizAttemptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizResponse"]>

  export type QuizResponseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attemptId?: boolean
    questionId?: boolean
    answer?: boolean
    isCorrect?: boolean
    responseTime?: boolean
    answeredAt?: boolean
    attempt?: boolean | QuizAttemptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizResponse"]>

  export type QuizResponseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attemptId?: boolean
    questionId?: boolean
    answer?: boolean
    isCorrect?: boolean
    responseTime?: boolean
    answeredAt?: boolean
    attempt?: boolean | QuizAttemptDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["quizResponse"]>

  export type QuizResponseSelectScalar = {
    id?: boolean
    attemptId?: boolean
    questionId?: boolean
    answer?: boolean
    isCorrect?: boolean
    responseTime?: boolean
    answeredAt?: boolean
  }

  export type QuizResponseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "attemptId" | "questionId" | "answer" | "isCorrect" | "responseTime" | "answeredAt", ExtArgs["result"]["quizResponse"]>
  export type QuizResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt?: boolean | QuizAttemptDefaultArgs<ExtArgs>
  }
  export type QuizResponseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt?: boolean | QuizAttemptDefaultArgs<ExtArgs>
  }
  export type QuizResponseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attempt?: boolean | QuizAttemptDefaultArgs<ExtArgs>
  }

  export type $QuizResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizResponse"
    objects: {
      attempt: Prisma.$QuizAttemptPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      attemptId: string
      questionId: string
      answer: string
      isCorrect: boolean
      responseTime: number
      answeredAt: Date
    }, ExtArgs["result"]["quizResponse"]>
    composites: {}
  }

  type QuizResponseGetPayload<S extends boolean | null | undefined | QuizResponseDefaultArgs> = $Result.GetResult<Prisma.$QuizResponsePayload, S>

  type QuizResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizResponseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizResponseCountAggregateInputType | true
    }

  export interface QuizResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizResponse'], meta: { name: 'QuizResponse' } }
    /**
     * Find zero or one QuizResponse that matches the filter.
     * @param {QuizResponseFindUniqueArgs} args - Arguments to find a QuizResponse
     * @example
     * // Get one QuizResponse
     * const quizResponse = await prisma.quizResponse.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizResponseFindUniqueArgs>(args: SelectSubset<T, QuizResponseFindUniqueArgs<ExtArgs>>): Prisma__QuizResponseClient<$Result.GetResult<Prisma.$QuizResponsePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizResponse that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizResponseFindUniqueOrThrowArgs} args - Arguments to find a QuizResponse
     * @example
     * // Get one QuizResponse
     * const quizResponse = await prisma.quizResponse.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizResponseFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizResponseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizResponseClient<$Result.GetResult<Prisma.$QuizResponsePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizResponse that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResponseFindFirstArgs} args - Arguments to find a QuizResponse
     * @example
     * // Get one QuizResponse
     * const quizResponse = await prisma.quizResponse.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizResponseFindFirstArgs>(args?: SelectSubset<T, QuizResponseFindFirstArgs<ExtArgs>>): Prisma__QuizResponseClient<$Result.GetResult<Prisma.$QuizResponsePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizResponse that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResponseFindFirstOrThrowArgs} args - Arguments to find a QuizResponse
     * @example
     * // Get one QuizResponse
     * const quizResponse = await prisma.quizResponse.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizResponseFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizResponseFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizResponseClient<$Result.GetResult<Prisma.$QuizResponsePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizResponses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResponseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizResponses
     * const quizResponses = await prisma.quizResponse.findMany()
     * 
     * // Get first 10 QuizResponses
     * const quizResponses = await prisma.quizResponse.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizResponseWithIdOnly = await prisma.quizResponse.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizResponseFindManyArgs>(args?: SelectSubset<T, QuizResponseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizResponsePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizResponse.
     * @param {QuizResponseCreateArgs} args - Arguments to create a QuizResponse.
     * @example
     * // Create one QuizResponse
     * const QuizResponse = await prisma.quizResponse.create({
     *   data: {
     *     // ... data to create a QuizResponse
     *   }
     * })
     * 
     */
    create<T extends QuizResponseCreateArgs>(args: SelectSubset<T, QuizResponseCreateArgs<ExtArgs>>): Prisma__QuizResponseClient<$Result.GetResult<Prisma.$QuizResponsePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizResponses.
     * @param {QuizResponseCreateManyArgs} args - Arguments to create many QuizResponses.
     * @example
     * // Create many QuizResponses
     * const quizResponse = await prisma.quizResponse.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizResponseCreateManyArgs>(args?: SelectSubset<T, QuizResponseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizResponses and returns the data saved in the database.
     * @param {QuizResponseCreateManyAndReturnArgs} args - Arguments to create many QuizResponses.
     * @example
     * // Create many QuizResponses
     * const quizResponse = await prisma.quizResponse.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizResponses and only return the `id`
     * const quizResponseWithIdOnly = await prisma.quizResponse.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizResponseCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizResponseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizResponsePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizResponse.
     * @param {QuizResponseDeleteArgs} args - Arguments to delete one QuizResponse.
     * @example
     * // Delete one QuizResponse
     * const QuizResponse = await prisma.quizResponse.delete({
     *   where: {
     *     // ... filter to delete one QuizResponse
     *   }
     * })
     * 
     */
    delete<T extends QuizResponseDeleteArgs>(args: SelectSubset<T, QuizResponseDeleteArgs<ExtArgs>>): Prisma__QuizResponseClient<$Result.GetResult<Prisma.$QuizResponsePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizResponse.
     * @param {QuizResponseUpdateArgs} args - Arguments to update one QuizResponse.
     * @example
     * // Update one QuizResponse
     * const quizResponse = await prisma.quizResponse.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizResponseUpdateArgs>(args: SelectSubset<T, QuizResponseUpdateArgs<ExtArgs>>): Prisma__QuizResponseClient<$Result.GetResult<Prisma.$QuizResponsePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizResponses.
     * @param {QuizResponseDeleteManyArgs} args - Arguments to filter QuizResponses to delete.
     * @example
     * // Delete a few QuizResponses
     * const { count } = await prisma.quizResponse.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizResponseDeleteManyArgs>(args?: SelectSubset<T, QuizResponseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizResponses
     * const quizResponse = await prisma.quizResponse.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizResponseUpdateManyArgs>(args: SelectSubset<T, QuizResponseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizResponses and returns the data updated in the database.
     * @param {QuizResponseUpdateManyAndReturnArgs} args - Arguments to update many QuizResponses.
     * @example
     * // Update many QuizResponses
     * const quizResponse = await prisma.quizResponse.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizResponses and only return the `id`
     * const quizResponseWithIdOnly = await prisma.quizResponse.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizResponseUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizResponseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizResponsePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizResponse.
     * @param {QuizResponseUpsertArgs} args - Arguments to update or create a QuizResponse.
     * @example
     * // Update or create a QuizResponse
     * const quizResponse = await prisma.quizResponse.upsert({
     *   create: {
     *     // ... data to create a QuizResponse
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizResponse we want to update
     *   }
     * })
     */
    upsert<T extends QuizResponseUpsertArgs>(args: SelectSubset<T, QuizResponseUpsertArgs<ExtArgs>>): Prisma__QuizResponseClient<$Result.GetResult<Prisma.$QuizResponsePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizResponses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResponseCountArgs} args - Arguments to filter QuizResponses to count.
     * @example
     * // Count the number of QuizResponses
     * const count = await prisma.quizResponse.count({
     *   where: {
     *     // ... the filter for the QuizResponses we want to count
     *   }
     * })
    **/
    count<T extends QuizResponseCountArgs>(
      args?: Subset<T, QuizResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizResponseAggregateArgs>(args: Subset<T, QuizResponseAggregateArgs>): Prisma.PrismaPromise<GetQuizResponseAggregateType<T>>

    /**
     * Group by QuizResponse.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizResponseGroupByArgs['orderBy'] }
        : { orderBy?: QuizResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizResponse model
   */
  readonly fields: QuizResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizResponse.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attempt<T extends QuizAttemptDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuizAttemptDefaultArgs<ExtArgs>>): Prisma__QuizAttemptClient<$Result.GetResult<Prisma.$QuizAttemptPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizResponse model
   */
  interface QuizResponseFieldRefs {
    readonly id: FieldRef<"QuizResponse", 'String'>
    readonly attemptId: FieldRef<"QuizResponse", 'String'>
    readonly questionId: FieldRef<"QuizResponse", 'String'>
    readonly answer: FieldRef<"QuizResponse", 'String'>
    readonly isCorrect: FieldRef<"QuizResponse", 'Boolean'>
    readonly responseTime: FieldRef<"QuizResponse", 'Int'>
    readonly answeredAt: FieldRef<"QuizResponse", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizResponse findUnique
   */
  export type QuizResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResponse
     */
    select?: QuizResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResponse
     */
    omit?: QuizResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResponseInclude<ExtArgs> | null
    /**
     * Filter, which QuizResponse to fetch.
     */
    where: QuizResponseWhereUniqueInput
  }

  /**
   * QuizResponse findUniqueOrThrow
   */
  export type QuizResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResponse
     */
    select?: QuizResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResponse
     */
    omit?: QuizResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResponseInclude<ExtArgs> | null
    /**
     * Filter, which QuizResponse to fetch.
     */
    where: QuizResponseWhereUniqueInput
  }

  /**
   * QuizResponse findFirst
   */
  export type QuizResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResponse
     */
    select?: QuizResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResponse
     */
    omit?: QuizResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResponseInclude<ExtArgs> | null
    /**
     * Filter, which QuizResponse to fetch.
     */
    where?: QuizResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizResponses to fetch.
     */
    orderBy?: QuizResponseOrderByWithRelationInput | QuizResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizResponses.
     */
    cursor?: QuizResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizResponses.
     */
    distinct?: QuizResponseScalarFieldEnum | QuizResponseScalarFieldEnum[]
  }

  /**
   * QuizResponse findFirstOrThrow
   */
  export type QuizResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResponse
     */
    select?: QuizResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResponse
     */
    omit?: QuizResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResponseInclude<ExtArgs> | null
    /**
     * Filter, which QuizResponse to fetch.
     */
    where?: QuizResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizResponses to fetch.
     */
    orderBy?: QuizResponseOrderByWithRelationInput | QuizResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizResponses.
     */
    cursor?: QuizResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizResponses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizResponses.
     */
    distinct?: QuizResponseScalarFieldEnum | QuizResponseScalarFieldEnum[]
  }

  /**
   * QuizResponse findMany
   */
  export type QuizResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResponse
     */
    select?: QuizResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResponse
     */
    omit?: QuizResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResponseInclude<ExtArgs> | null
    /**
     * Filter, which QuizResponses to fetch.
     */
    where?: QuizResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizResponses to fetch.
     */
    orderBy?: QuizResponseOrderByWithRelationInput | QuizResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizResponses.
     */
    cursor?: QuizResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizResponses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizResponses.
     */
    skip?: number
    distinct?: QuizResponseScalarFieldEnum | QuizResponseScalarFieldEnum[]
  }

  /**
   * QuizResponse create
   */
  export type QuizResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResponse
     */
    select?: QuizResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResponse
     */
    omit?: QuizResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a QuizResponse.
     */
    data: XOR<QuizResponseCreateInput, QuizResponseUncheckedCreateInput>
  }

  /**
   * QuizResponse createMany
   */
  export type QuizResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizResponses.
     */
    data: QuizResponseCreateManyInput | QuizResponseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizResponse createManyAndReturn
   */
  export type QuizResponseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResponse
     */
    select?: QuizResponseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResponse
     */
    omit?: QuizResponseOmit<ExtArgs> | null
    /**
     * The data used to create many QuizResponses.
     */
    data: QuizResponseCreateManyInput | QuizResponseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResponseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizResponse update
   */
  export type QuizResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResponse
     */
    select?: QuizResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResponse
     */
    omit?: QuizResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a QuizResponse.
     */
    data: XOR<QuizResponseUpdateInput, QuizResponseUncheckedUpdateInput>
    /**
     * Choose, which QuizResponse to update.
     */
    where: QuizResponseWhereUniqueInput
  }

  /**
   * QuizResponse updateMany
   */
  export type QuizResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizResponses.
     */
    data: XOR<QuizResponseUpdateManyMutationInput, QuizResponseUncheckedUpdateManyInput>
    /**
     * Filter which QuizResponses to update
     */
    where?: QuizResponseWhereInput
    /**
     * Limit how many QuizResponses to update.
     */
    limit?: number
  }

  /**
   * QuizResponse updateManyAndReturn
   */
  export type QuizResponseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResponse
     */
    select?: QuizResponseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResponse
     */
    omit?: QuizResponseOmit<ExtArgs> | null
    /**
     * The data used to update QuizResponses.
     */
    data: XOR<QuizResponseUpdateManyMutationInput, QuizResponseUncheckedUpdateManyInput>
    /**
     * Filter which QuizResponses to update
     */
    where?: QuizResponseWhereInput
    /**
     * Limit how many QuizResponses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResponseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuizResponse upsert
   */
  export type QuizResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResponse
     */
    select?: QuizResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResponse
     */
    omit?: QuizResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the QuizResponse to update in case it exists.
     */
    where: QuizResponseWhereUniqueInput
    /**
     * In case the QuizResponse found by the `where` argument doesn't exist, create a new QuizResponse with this data.
     */
    create: XOR<QuizResponseCreateInput, QuizResponseUncheckedCreateInput>
    /**
     * In case the QuizResponse was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizResponseUpdateInput, QuizResponseUncheckedUpdateInput>
  }

  /**
   * QuizResponse delete
   */
  export type QuizResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResponse
     */
    select?: QuizResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResponse
     */
    omit?: QuizResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResponseInclude<ExtArgs> | null
    /**
     * Filter which QuizResponse to delete.
     */
    where: QuizResponseWhereUniqueInput
  }

  /**
   * QuizResponse deleteMany
   */
  export type QuizResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizResponses to delete
     */
    where?: QuizResponseWhereInput
    /**
     * Limit how many QuizResponses to delete.
     */
    limit?: number
  }

  /**
   * QuizResponse without action
   */
  export type QuizResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizResponse
     */
    select?: QuizResponseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizResponse
     */
    omit?: QuizResponseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuizResponseInclude<ExtArgs> | null
  }


  /**
   * Model FanIQBadge
   */

  export type AggregateFanIQBadge = {
    _count: FanIQBadgeCountAggregateOutputType | null
    _min: FanIQBadgeMinAggregateOutputType | null
    _max: FanIQBadgeMaxAggregateOutputType | null
  }

  export type FanIQBadgeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tier: string | null
    artistId: string | null
    artistName: string | null
    tokenId: string | null
    txHash: string | null
    earnedAt: Date | null
  }

  export type FanIQBadgeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tier: string | null
    artistId: string | null
    artistName: string | null
    tokenId: string | null
    txHash: string | null
    earnedAt: Date | null
  }

  export type FanIQBadgeCountAggregateOutputType = {
    id: number
    userId: number
    tier: number
    artistId: number
    artistName: number
    tokenId: number
    txHash: number
    earnedAt: number
    _all: number
  }


  export type FanIQBadgeMinAggregateInputType = {
    id?: true
    userId?: true
    tier?: true
    artistId?: true
    artistName?: true
    tokenId?: true
    txHash?: true
    earnedAt?: true
  }

  export type FanIQBadgeMaxAggregateInputType = {
    id?: true
    userId?: true
    tier?: true
    artistId?: true
    artistName?: true
    tokenId?: true
    txHash?: true
    earnedAt?: true
  }

  export type FanIQBadgeCountAggregateInputType = {
    id?: true
    userId?: true
    tier?: true
    artistId?: true
    artistName?: true
    tokenId?: true
    txHash?: true
    earnedAt?: true
    _all?: true
  }

  export type FanIQBadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FanIQBadge to aggregate.
     */
    where?: FanIQBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FanIQBadges to fetch.
     */
    orderBy?: FanIQBadgeOrderByWithRelationInput | FanIQBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FanIQBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FanIQBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FanIQBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FanIQBadges
    **/
    _count?: true | FanIQBadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FanIQBadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FanIQBadgeMaxAggregateInputType
  }

  export type GetFanIQBadgeAggregateType<T extends FanIQBadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateFanIQBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFanIQBadge[P]>
      : GetScalarType<T[P], AggregateFanIQBadge[P]>
  }




  export type FanIQBadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FanIQBadgeWhereInput
    orderBy?: FanIQBadgeOrderByWithAggregationInput | FanIQBadgeOrderByWithAggregationInput[]
    by: FanIQBadgeScalarFieldEnum[] | FanIQBadgeScalarFieldEnum
    having?: FanIQBadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FanIQBadgeCountAggregateInputType | true
    _min?: FanIQBadgeMinAggregateInputType
    _max?: FanIQBadgeMaxAggregateInputType
  }

  export type FanIQBadgeGroupByOutputType = {
    id: string
    userId: string
    tier: string
    artistId: string
    artistName: string
    tokenId: string | null
    txHash: string | null
    earnedAt: Date
    _count: FanIQBadgeCountAggregateOutputType | null
    _min: FanIQBadgeMinAggregateOutputType | null
    _max: FanIQBadgeMaxAggregateOutputType | null
  }

  type GetFanIQBadgeGroupByPayload<T extends FanIQBadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FanIQBadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FanIQBadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FanIQBadgeGroupByOutputType[P]>
            : GetScalarType<T[P], FanIQBadgeGroupByOutputType[P]>
        }
      >
    >


  export type FanIQBadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tier?: boolean
    artistId?: boolean
    artistName?: boolean
    tokenId?: boolean
    txHash?: boolean
    earnedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fanIQBadge"]>

  export type FanIQBadgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tier?: boolean
    artistId?: boolean
    artistName?: boolean
    tokenId?: boolean
    txHash?: boolean
    earnedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fanIQBadge"]>

  export type FanIQBadgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tier?: boolean
    artistId?: boolean
    artistName?: boolean
    tokenId?: boolean
    txHash?: boolean
    earnedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fanIQBadge"]>

  export type FanIQBadgeSelectScalar = {
    id?: boolean
    userId?: boolean
    tier?: boolean
    artistId?: boolean
    artistName?: boolean
    tokenId?: boolean
    txHash?: boolean
    earnedAt?: boolean
  }

  export type FanIQBadgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "tier" | "artistId" | "artistName" | "tokenId" | "txHash" | "earnedAt", ExtArgs["result"]["fanIQBadge"]>
  export type FanIQBadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FanIQBadgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FanIQBadgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FanIQBadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FanIQBadge"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tier: string
      artistId: string
      artistName: string
      tokenId: string | null
      txHash: string | null
      earnedAt: Date
    }, ExtArgs["result"]["fanIQBadge"]>
    composites: {}
  }

  type FanIQBadgeGetPayload<S extends boolean | null | undefined | FanIQBadgeDefaultArgs> = $Result.GetResult<Prisma.$FanIQBadgePayload, S>

  type FanIQBadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FanIQBadgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FanIQBadgeCountAggregateInputType | true
    }

  export interface FanIQBadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FanIQBadge'], meta: { name: 'FanIQBadge' } }
    /**
     * Find zero or one FanIQBadge that matches the filter.
     * @param {FanIQBadgeFindUniqueArgs} args - Arguments to find a FanIQBadge
     * @example
     * // Get one FanIQBadge
     * const fanIQBadge = await prisma.fanIQBadge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FanIQBadgeFindUniqueArgs>(args: SelectSubset<T, FanIQBadgeFindUniqueArgs<ExtArgs>>): Prisma__FanIQBadgeClient<$Result.GetResult<Prisma.$FanIQBadgePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FanIQBadge that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FanIQBadgeFindUniqueOrThrowArgs} args - Arguments to find a FanIQBadge
     * @example
     * // Get one FanIQBadge
     * const fanIQBadge = await prisma.fanIQBadge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FanIQBadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, FanIQBadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FanIQBadgeClient<$Result.GetResult<Prisma.$FanIQBadgePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FanIQBadge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FanIQBadgeFindFirstArgs} args - Arguments to find a FanIQBadge
     * @example
     * // Get one FanIQBadge
     * const fanIQBadge = await prisma.fanIQBadge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FanIQBadgeFindFirstArgs>(args?: SelectSubset<T, FanIQBadgeFindFirstArgs<ExtArgs>>): Prisma__FanIQBadgeClient<$Result.GetResult<Prisma.$FanIQBadgePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FanIQBadge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FanIQBadgeFindFirstOrThrowArgs} args - Arguments to find a FanIQBadge
     * @example
     * // Get one FanIQBadge
     * const fanIQBadge = await prisma.fanIQBadge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FanIQBadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, FanIQBadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__FanIQBadgeClient<$Result.GetResult<Prisma.$FanIQBadgePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FanIQBadges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FanIQBadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FanIQBadges
     * const fanIQBadges = await prisma.fanIQBadge.findMany()
     * 
     * // Get first 10 FanIQBadges
     * const fanIQBadges = await prisma.fanIQBadge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fanIQBadgeWithIdOnly = await prisma.fanIQBadge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FanIQBadgeFindManyArgs>(args?: SelectSubset<T, FanIQBadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FanIQBadgePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FanIQBadge.
     * @param {FanIQBadgeCreateArgs} args - Arguments to create a FanIQBadge.
     * @example
     * // Create one FanIQBadge
     * const FanIQBadge = await prisma.fanIQBadge.create({
     *   data: {
     *     // ... data to create a FanIQBadge
     *   }
     * })
     * 
     */
    create<T extends FanIQBadgeCreateArgs>(args: SelectSubset<T, FanIQBadgeCreateArgs<ExtArgs>>): Prisma__FanIQBadgeClient<$Result.GetResult<Prisma.$FanIQBadgePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FanIQBadges.
     * @param {FanIQBadgeCreateManyArgs} args - Arguments to create many FanIQBadges.
     * @example
     * // Create many FanIQBadges
     * const fanIQBadge = await prisma.fanIQBadge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FanIQBadgeCreateManyArgs>(args?: SelectSubset<T, FanIQBadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FanIQBadges and returns the data saved in the database.
     * @param {FanIQBadgeCreateManyAndReturnArgs} args - Arguments to create many FanIQBadges.
     * @example
     * // Create many FanIQBadges
     * const fanIQBadge = await prisma.fanIQBadge.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FanIQBadges and only return the `id`
     * const fanIQBadgeWithIdOnly = await prisma.fanIQBadge.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FanIQBadgeCreateManyAndReturnArgs>(args?: SelectSubset<T, FanIQBadgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FanIQBadgePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FanIQBadge.
     * @param {FanIQBadgeDeleteArgs} args - Arguments to delete one FanIQBadge.
     * @example
     * // Delete one FanIQBadge
     * const FanIQBadge = await prisma.fanIQBadge.delete({
     *   where: {
     *     // ... filter to delete one FanIQBadge
     *   }
     * })
     * 
     */
    delete<T extends FanIQBadgeDeleteArgs>(args: SelectSubset<T, FanIQBadgeDeleteArgs<ExtArgs>>): Prisma__FanIQBadgeClient<$Result.GetResult<Prisma.$FanIQBadgePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FanIQBadge.
     * @param {FanIQBadgeUpdateArgs} args - Arguments to update one FanIQBadge.
     * @example
     * // Update one FanIQBadge
     * const fanIQBadge = await prisma.fanIQBadge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FanIQBadgeUpdateArgs>(args: SelectSubset<T, FanIQBadgeUpdateArgs<ExtArgs>>): Prisma__FanIQBadgeClient<$Result.GetResult<Prisma.$FanIQBadgePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FanIQBadges.
     * @param {FanIQBadgeDeleteManyArgs} args - Arguments to filter FanIQBadges to delete.
     * @example
     * // Delete a few FanIQBadges
     * const { count } = await prisma.fanIQBadge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FanIQBadgeDeleteManyArgs>(args?: SelectSubset<T, FanIQBadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FanIQBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FanIQBadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FanIQBadges
     * const fanIQBadge = await prisma.fanIQBadge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FanIQBadgeUpdateManyArgs>(args: SelectSubset<T, FanIQBadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FanIQBadges and returns the data updated in the database.
     * @param {FanIQBadgeUpdateManyAndReturnArgs} args - Arguments to update many FanIQBadges.
     * @example
     * // Update many FanIQBadges
     * const fanIQBadge = await prisma.fanIQBadge.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FanIQBadges and only return the `id`
     * const fanIQBadgeWithIdOnly = await prisma.fanIQBadge.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FanIQBadgeUpdateManyAndReturnArgs>(args: SelectSubset<T, FanIQBadgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FanIQBadgePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FanIQBadge.
     * @param {FanIQBadgeUpsertArgs} args - Arguments to update or create a FanIQBadge.
     * @example
     * // Update or create a FanIQBadge
     * const fanIQBadge = await prisma.fanIQBadge.upsert({
     *   create: {
     *     // ... data to create a FanIQBadge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FanIQBadge we want to update
     *   }
     * })
     */
    upsert<T extends FanIQBadgeUpsertArgs>(args: SelectSubset<T, FanIQBadgeUpsertArgs<ExtArgs>>): Prisma__FanIQBadgeClient<$Result.GetResult<Prisma.$FanIQBadgePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FanIQBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FanIQBadgeCountArgs} args - Arguments to filter FanIQBadges to count.
     * @example
     * // Count the number of FanIQBadges
     * const count = await prisma.fanIQBadge.count({
     *   where: {
     *     // ... the filter for the FanIQBadges we want to count
     *   }
     * })
    **/
    count<T extends FanIQBadgeCountArgs>(
      args?: Subset<T, FanIQBadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FanIQBadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FanIQBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FanIQBadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FanIQBadgeAggregateArgs>(args: Subset<T, FanIQBadgeAggregateArgs>): Prisma.PrismaPromise<GetFanIQBadgeAggregateType<T>>

    /**
     * Group by FanIQBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FanIQBadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FanIQBadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FanIQBadgeGroupByArgs['orderBy'] }
        : { orderBy?: FanIQBadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FanIQBadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFanIQBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FanIQBadge model
   */
  readonly fields: FanIQBadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FanIQBadge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FanIQBadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FanIQBadge model
   */
  interface FanIQBadgeFieldRefs {
    readonly id: FieldRef<"FanIQBadge", 'String'>
    readonly userId: FieldRef<"FanIQBadge", 'String'>
    readonly tier: FieldRef<"FanIQBadge", 'String'>
    readonly artistId: FieldRef<"FanIQBadge", 'String'>
    readonly artistName: FieldRef<"FanIQBadge", 'String'>
    readonly tokenId: FieldRef<"FanIQBadge", 'String'>
    readonly txHash: FieldRef<"FanIQBadge", 'String'>
    readonly earnedAt: FieldRef<"FanIQBadge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FanIQBadge findUnique
   */
  export type FanIQBadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FanIQBadge
     */
    select?: FanIQBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FanIQBadge
     */
    omit?: FanIQBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanIQBadgeInclude<ExtArgs> | null
    /**
     * Filter, which FanIQBadge to fetch.
     */
    where: FanIQBadgeWhereUniqueInput
  }

  /**
   * FanIQBadge findUniqueOrThrow
   */
  export type FanIQBadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FanIQBadge
     */
    select?: FanIQBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FanIQBadge
     */
    omit?: FanIQBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanIQBadgeInclude<ExtArgs> | null
    /**
     * Filter, which FanIQBadge to fetch.
     */
    where: FanIQBadgeWhereUniqueInput
  }

  /**
   * FanIQBadge findFirst
   */
  export type FanIQBadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FanIQBadge
     */
    select?: FanIQBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FanIQBadge
     */
    omit?: FanIQBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanIQBadgeInclude<ExtArgs> | null
    /**
     * Filter, which FanIQBadge to fetch.
     */
    where?: FanIQBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FanIQBadges to fetch.
     */
    orderBy?: FanIQBadgeOrderByWithRelationInput | FanIQBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FanIQBadges.
     */
    cursor?: FanIQBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FanIQBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FanIQBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FanIQBadges.
     */
    distinct?: FanIQBadgeScalarFieldEnum | FanIQBadgeScalarFieldEnum[]
  }

  /**
   * FanIQBadge findFirstOrThrow
   */
  export type FanIQBadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FanIQBadge
     */
    select?: FanIQBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FanIQBadge
     */
    omit?: FanIQBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanIQBadgeInclude<ExtArgs> | null
    /**
     * Filter, which FanIQBadge to fetch.
     */
    where?: FanIQBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FanIQBadges to fetch.
     */
    orderBy?: FanIQBadgeOrderByWithRelationInput | FanIQBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FanIQBadges.
     */
    cursor?: FanIQBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FanIQBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FanIQBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FanIQBadges.
     */
    distinct?: FanIQBadgeScalarFieldEnum | FanIQBadgeScalarFieldEnum[]
  }

  /**
   * FanIQBadge findMany
   */
  export type FanIQBadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FanIQBadge
     */
    select?: FanIQBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FanIQBadge
     */
    omit?: FanIQBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanIQBadgeInclude<ExtArgs> | null
    /**
     * Filter, which FanIQBadges to fetch.
     */
    where?: FanIQBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FanIQBadges to fetch.
     */
    orderBy?: FanIQBadgeOrderByWithRelationInput | FanIQBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FanIQBadges.
     */
    cursor?: FanIQBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FanIQBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FanIQBadges.
     */
    skip?: number
    distinct?: FanIQBadgeScalarFieldEnum | FanIQBadgeScalarFieldEnum[]
  }

  /**
   * FanIQBadge create
   */
  export type FanIQBadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FanIQBadge
     */
    select?: FanIQBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FanIQBadge
     */
    omit?: FanIQBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanIQBadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a FanIQBadge.
     */
    data: XOR<FanIQBadgeCreateInput, FanIQBadgeUncheckedCreateInput>
  }

  /**
   * FanIQBadge createMany
   */
  export type FanIQBadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FanIQBadges.
     */
    data: FanIQBadgeCreateManyInput | FanIQBadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FanIQBadge createManyAndReturn
   */
  export type FanIQBadgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FanIQBadge
     */
    select?: FanIQBadgeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FanIQBadge
     */
    omit?: FanIQBadgeOmit<ExtArgs> | null
    /**
     * The data used to create many FanIQBadges.
     */
    data: FanIQBadgeCreateManyInput | FanIQBadgeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanIQBadgeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FanIQBadge update
   */
  export type FanIQBadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FanIQBadge
     */
    select?: FanIQBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FanIQBadge
     */
    omit?: FanIQBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanIQBadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a FanIQBadge.
     */
    data: XOR<FanIQBadgeUpdateInput, FanIQBadgeUncheckedUpdateInput>
    /**
     * Choose, which FanIQBadge to update.
     */
    where: FanIQBadgeWhereUniqueInput
  }

  /**
   * FanIQBadge updateMany
   */
  export type FanIQBadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FanIQBadges.
     */
    data: XOR<FanIQBadgeUpdateManyMutationInput, FanIQBadgeUncheckedUpdateManyInput>
    /**
     * Filter which FanIQBadges to update
     */
    where?: FanIQBadgeWhereInput
    /**
     * Limit how many FanIQBadges to update.
     */
    limit?: number
  }

  /**
   * FanIQBadge updateManyAndReturn
   */
  export type FanIQBadgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FanIQBadge
     */
    select?: FanIQBadgeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FanIQBadge
     */
    omit?: FanIQBadgeOmit<ExtArgs> | null
    /**
     * The data used to update FanIQBadges.
     */
    data: XOR<FanIQBadgeUpdateManyMutationInput, FanIQBadgeUncheckedUpdateManyInput>
    /**
     * Filter which FanIQBadges to update
     */
    where?: FanIQBadgeWhereInput
    /**
     * Limit how many FanIQBadges to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanIQBadgeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FanIQBadge upsert
   */
  export type FanIQBadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FanIQBadge
     */
    select?: FanIQBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FanIQBadge
     */
    omit?: FanIQBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanIQBadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the FanIQBadge to update in case it exists.
     */
    where: FanIQBadgeWhereUniqueInput
    /**
     * In case the FanIQBadge found by the `where` argument doesn't exist, create a new FanIQBadge with this data.
     */
    create: XOR<FanIQBadgeCreateInput, FanIQBadgeUncheckedCreateInput>
    /**
     * In case the FanIQBadge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FanIQBadgeUpdateInput, FanIQBadgeUncheckedUpdateInput>
  }

  /**
   * FanIQBadge delete
   */
  export type FanIQBadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FanIQBadge
     */
    select?: FanIQBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FanIQBadge
     */
    omit?: FanIQBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanIQBadgeInclude<ExtArgs> | null
    /**
     * Filter which FanIQBadge to delete.
     */
    where: FanIQBadgeWhereUniqueInput
  }

  /**
   * FanIQBadge deleteMany
   */
  export type FanIQBadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FanIQBadges to delete
     */
    where?: FanIQBadgeWhereInput
    /**
     * Limit how many FanIQBadges to delete.
     */
    limit?: number
  }

  /**
   * FanIQBadge without action
   */
  export type FanIQBadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FanIQBadge
     */
    select?: FanIQBadgeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FanIQBadge
     */
    omit?: FanIQBadgeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FanIQBadgeInclude<ExtArgs> | null
  }


  /**
   * Model QuizUserStats
   */

  export type AggregateQuizUserStats = {
    _count: QuizUserStatsCountAggregateOutputType | null
    _avg: QuizUserStatsAvgAggregateOutputType | null
    _sum: QuizUserStatsSumAggregateOutputType | null
    _min: QuizUserStatsMinAggregateOutputType | null
    _max: QuizUserStatsMaxAggregateOutputType | null
  }

  export type QuizUserStatsAvgAggregateOutputType = {
    attemptCount: number | null
    totalScore: number | null
    averageScore: number | null
    bestScore: number | null
    bestAccuracy: number | null
    bestSpeed: number | null
    lastScore: number | null
  }

  export type QuizUserStatsSumAggregateOutputType = {
    attemptCount: number | null
    totalScore: number | null
    averageScore: number | null
    bestScore: number | null
    bestAccuracy: number | null
    bestSpeed: number | null
    lastScore: number | null
  }

  export type QuizUserStatsMinAggregateOutputType = {
    id: string | null
    visitorId: string | null
    artistName: string | null
    attemptCount: number | null
    totalScore: number | null
    averageScore: number | null
    bestScore: number | null
    bestAccuracy: number | null
    bestSpeed: number | null
    lastScore: number | null
    lastPlayedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizUserStatsMaxAggregateOutputType = {
    id: string | null
    visitorId: string | null
    artistName: string | null
    attemptCount: number | null
    totalScore: number | null
    averageScore: number | null
    bestScore: number | null
    bestAccuracy: number | null
    bestSpeed: number | null
    lastScore: number | null
    lastPlayedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuizUserStatsCountAggregateOutputType = {
    id: number
    visitorId: number
    artistName: number
    attemptCount: number
    totalScore: number
    averageScore: number
    bestScore: number
    bestAccuracy: number
    bestSpeed: number
    lastScore: number
    lastPlayedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuizUserStatsAvgAggregateInputType = {
    attemptCount?: true
    totalScore?: true
    averageScore?: true
    bestScore?: true
    bestAccuracy?: true
    bestSpeed?: true
    lastScore?: true
  }

  export type QuizUserStatsSumAggregateInputType = {
    attemptCount?: true
    totalScore?: true
    averageScore?: true
    bestScore?: true
    bestAccuracy?: true
    bestSpeed?: true
    lastScore?: true
  }

  export type QuizUserStatsMinAggregateInputType = {
    id?: true
    visitorId?: true
    artistName?: true
    attemptCount?: true
    totalScore?: true
    averageScore?: true
    bestScore?: true
    bestAccuracy?: true
    bestSpeed?: true
    lastScore?: true
    lastPlayedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizUserStatsMaxAggregateInputType = {
    id?: true
    visitorId?: true
    artistName?: true
    attemptCount?: true
    totalScore?: true
    averageScore?: true
    bestScore?: true
    bestAccuracy?: true
    bestSpeed?: true
    lastScore?: true
    lastPlayedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuizUserStatsCountAggregateInputType = {
    id?: true
    visitorId?: true
    artistName?: true
    attemptCount?: true
    totalScore?: true
    averageScore?: true
    bestScore?: true
    bestAccuracy?: true
    bestSpeed?: true
    lastScore?: true
    lastPlayedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuizUserStatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizUserStats to aggregate.
     */
    where?: QuizUserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizUserStats to fetch.
     */
    orderBy?: QuizUserStatsOrderByWithRelationInput | QuizUserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuizUserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizUserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizUserStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuizUserStats
    **/
    _count?: true | QuizUserStatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuizUserStatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuizUserStatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuizUserStatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuizUserStatsMaxAggregateInputType
  }

  export type GetQuizUserStatsAggregateType<T extends QuizUserStatsAggregateArgs> = {
        [P in keyof T & keyof AggregateQuizUserStats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuizUserStats[P]>
      : GetScalarType<T[P], AggregateQuizUserStats[P]>
  }




  export type QuizUserStatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuizUserStatsWhereInput
    orderBy?: QuizUserStatsOrderByWithAggregationInput | QuizUserStatsOrderByWithAggregationInput[]
    by: QuizUserStatsScalarFieldEnum[] | QuizUserStatsScalarFieldEnum
    having?: QuizUserStatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuizUserStatsCountAggregateInputType | true
    _avg?: QuizUserStatsAvgAggregateInputType
    _sum?: QuizUserStatsSumAggregateInputType
    _min?: QuizUserStatsMinAggregateInputType
    _max?: QuizUserStatsMaxAggregateInputType
  }

  export type QuizUserStatsGroupByOutputType = {
    id: string
    visitorId: string
    artistName: string
    attemptCount: number
    totalScore: number
    averageScore: number
    bestScore: number
    bestAccuracy: number
    bestSpeed: number
    lastScore: number
    lastPlayedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: QuizUserStatsCountAggregateOutputType | null
    _avg: QuizUserStatsAvgAggregateOutputType | null
    _sum: QuizUserStatsSumAggregateOutputType | null
    _min: QuizUserStatsMinAggregateOutputType | null
    _max: QuizUserStatsMaxAggregateOutputType | null
  }

  type GetQuizUserStatsGroupByPayload<T extends QuizUserStatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuizUserStatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuizUserStatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuizUserStatsGroupByOutputType[P]>
            : GetScalarType<T[P], QuizUserStatsGroupByOutputType[P]>
        }
      >
    >


  export type QuizUserStatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitorId?: boolean
    artistName?: boolean
    attemptCount?: boolean
    totalScore?: boolean
    averageScore?: boolean
    bestScore?: boolean
    bestAccuracy?: boolean
    bestSpeed?: boolean
    lastScore?: boolean
    lastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["quizUserStats"]>

  export type QuizUserStatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitorId?: boolean
    artistName?: boolean
    attemptCount?: boolean
    totalScore?: boolean
    averageScore?: boolean
    bestScore?: boolean
    bestAccuracy?: boolean
    bestSpeed?: boolean
    lastScore?: boolean
    lastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["quizUserStats"]>

  export type QuizUserStatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    visitorId?: boolean
    artistName?: boolean
    attemptCount?: boolean
    totalScore?: boolean
    averageScore?: boolean
    bestScore?: boolean
    bestAccuracy?: boolean
    bestSpeed?: boolean
    lastScore?: boolean
    lastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["quizUserStats"]>

  export type QuizUserStatsSelectScalar = {
    id?: boolean
    visitorId?: boolean
    artistName?: boolean
    attemptCount?: boolean
    totalScore?: boolean
    averageScore?: boolean
    bestScore?: boolean
    bestAccuracy?: boolean
    bestSpeed?: boolean
    lastScore?: boolean
    lastPlayedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuizUserStatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "visitorId" | "artistName" | "attemptCount" | "totalScore" | "averageScore" | "bestScore" | "bestAccuracy" | "bestSpeed" | "lastScore" | "lastPlayedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["quizUserStats"]>

  export type $QuizUserStatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuizUserStats"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      visitorId: string
      artistName: string
      attemptCount: number
      totalScore: number
      averageScore: number
      bestScore: number
      bestAccuracy: number
      bestSpeed: number
      lastScore: number
      lastPlayedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["quizUserStats"]>
    composites: {}
  }

  type QuizUserStatsGetPayload<S extends boolean | null | undefined | QuizUserStatsDefaultArgs> = $Result.GetResult<Prisma.$QuizUserStatsPayload, S>

  type QuizUserStatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuizUserStatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuizUserStatsCountAggregateInputType | true
    }

  export interface QuizUserStatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuizUserStats'], meta: { name: 'QuizUserStats' } }
    /**
     * Find zero or one QuizUserStats that matches the filter.
     * @param {QuizUserStatsFindUniqueArgs} args - Arguments to find a QuizUserStats
     * @example
     * // Get one QuizUserStats
     * const quizUserStats = await prisma.quizUserStats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuizUserStatsFindUniqueArgs>(args: SelectSubset<T, QuizUserStatsFindUniqueArgs<ExtArgs>>): Prisma__QuizUserStatsClient<$Result.GetResult<Prisma.$QuizUserStatsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuizUserStats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuizUserStatsFindUniqueOrThrowArgs} args - Arguments to find a QuizUserStats
     * @example
     * // Get one QuizUserStats
     * const quizUserStats = await prisma.quizUserStats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuizUserStatsFindUniqueOrThrowArgs>(args: SelectSubset<T, QuizUserStatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuizUserStatsClient<$Result.GetResult<Prisma.$QuizUserStatsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizUserStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizUserStatsFindFirstArgs} args - Arguments to find a QuizUserStats
     * @example
     * // Get one QuizUserStats
     * const quizUserStats = await prisma.quizUserStats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuizUserStatsFindFirstArgs>(args?: SelectSubset<T, QuizUserStatsFindFirstArgs<ExtArgs>>): Prisma__QuizUserStatsClient<$Result.GetResult<Prisma.$QuizUserStatsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuizUserStats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizUserStatsFindFirstOrThrowArgs} args - Arguments to find a QuizUserStats
     * @example
     * // Get one QuizUserStats
     * const quizUserStats = await prisma.quizUserStats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuizUserStatsFindFirstOrThrowArgs>(args?: SelectSubset<T, QuizUserStatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuizUserStatsClient<$Result.GetResult<Prisma.$QuizUserStatsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuizUserStats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizUserStatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuizUserStats
     * const quizUserStats = await prisma.quizUserStats.findMany()
     * 
     * // Get first 10 QuizUserStats
     * const quizUserStats = await prisma.quizUserStats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const quizUserStatsWithIdOnly = await prisma.quizUserStats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuizUserStatsFindManyArgs>(args?: SelectSubset<T, QuizUserStatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizUserStatsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuizUserStats.
     * @param {QuizUserStatsCreateArgs} args - Arguments to create a QuizUserStats.
     * @example
     * // Create one QuizUserStats
     * const QuizUserStats = await prisma.quizUserStats.create({
     *   data: {
     *     // ... data to create a QuizUserStats
     *   }
     * })
     * 
     */
    create<T extends QuizUserStatsCreateArgs>(args: SelectSubset<T, QuizUserStatsCreateArgs<ExtArgs>>): Prisma__QuizUserStatsClient<$Result.GetResult<Prisma.$QuizUserStatsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuizUserStats.
     * @param {QuizUserStatsCreateManyArgs} args - Arguments to create many QuizUserStats.
     * @example
     * // Create many QuizUserStats
     * const quizUserStats = await prisma.quizUserStats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuizUserStatsCreateManyArgs>(args?: SelectSubset<T, QuizUserStatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuizUserStats and returns the data saved in the database.
     * @param {QuizUserStatsCreateManyAndReturnArgs} args - Arguments to create many QuizUserStats.
     * @example
     * // Create many QuizUserStats
     * const quizUserStats = await prisma.quizUserStats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuizUserStats and only return the `id`
     * const quizUserStatsWithIdOnly = await prisma.quizUserStats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuizUserStatsCreateManyAndReturnArgs>(args?: SelectSubset<T, QuizUserStatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizUserStatsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuizUserStats.
     * @param {QuizUserStatsDeleteArgs} args - Arguments to delete one QuizUserStats.
     * @example
     * // Delete one QuizUserStats
     * const QuizUserStats = await prisma.quizUserStats.delete({
     *   where: {
     *     // ... filter to delete one QuizUserStats
     *   }
     * })
     * 
     */
    delete<T extends QuizUserStatsDeleteArgs>(args: SelectSubset<T, QuizUserStatsDeleteArgs<ExtArgs>>): Prisma__QuizUserStatsClient<$Result.GetResult<Prisma.$QuizUserStatsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuizUserStats.
     * @param {QuizUserStatsUpdateArgs} args - Arguments to update one QuizUserStats.
     * @example
     * // Update one QuizUserStats
     * const quizUserStats = await prisma.quizUserStats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuizUserStatsUpdateArgs>(args: SelectSubset<T, QuizUserStatsUpdateArgs<ExtArgs>>): Prisma__QuizUserStatsClient<$Result.GetResult<Prisma.$QuizUserStatsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuizUserStats.
     * @param {QuizUserStatsDeleteManyArgs} args - Arguments to filter QuizUserStats to delete.
     * @example
     * // Delete a few QuizUserStats
     * const { count } = await prisma.quizUserStats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuizUserStatsDeleteManyArgs>(args?: SelectSubset<T, QuizUserStatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizUserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizUserStatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuizUserStats
     * const quizUserStats = await prisma.quizUserStats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuizUserStatsUpdateManyArgs>(args: SelectSubset<T, QuizUserStatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuizUserStats and returns the data updated in the database.
     * @param {QuizUserStatsUpdateManyAndReturnArgs} args - Arguments to update many QuizUserStats.
     * @example
     * // Update many QuizUserStats
     * const quizUserStats = await prisma.quizUserStats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuizUserStats and only return the `id`
     * const quizUserStatsWithIdOnly = await prisma.quizUserStats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuizUserStatsUpdateManyAndReturnArgs>(args: SelectSubset<T, QuizUserStatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuizUserStatsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuizUserStats.
     * @param {QuizUserStatsUpsertArgs} args - Arguments to update or create a QuizUserStats.
     * @example
     * // Update or create a QuizUserStats
     * const quizUserStats = await prisma.quizUserStats.upsert({
     *   create: {
     *     // ... data to create a QuizUserStats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuizUserStats we want to update
     *   }
     * })
     */
    upsert<T extends QuizUserStatsUpsertArgs>(args: SelectSubset<T, QuizUserStatsUpsertArgs<ExtArgs>>): Prisma__QuizUserStatsClient<$Result.GetResult<Prisma.$QuizUserStatsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuizUserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizUserStatsCountArgs} args - Arguments to filter QuizUserStats to count.
     * @example
     * // Count the number of QuizUserStats
     * const count = await prisma.quizUserStats.count({
     *   where: {
     *     // ... the filter for the QuizUserStats we want to count
     *   }
     * })
    **/
    count<T extends QuizUserStatsCountArgs>(
      args?: Subset<T, QuizUserStatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuizUserStatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuizUserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizUserStatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuizUserStatsAggregateArgs>(args: Subset<T, QuizUserStatsAggregateArgs>): Prisma.PrismaPromise<GetQuizUserStatsAggregateType<T>>

    /**
     * Group by QuizUserStats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuizUserStatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuizUserStatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuizUserStatsGroupByArgs['orderBy'] }
        : { orderBy?: QuizUserStatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuizUserStatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuizUserStatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuizUserStats model
   */
  readonly fields: QuizUserStatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuizUserStats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuizUserStatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuizUserStats model
   */
  interface QuizUserStatsFieldRefs {
    readonly id: FieldRef<"QuizUserStats", 'String'>
    readonly visitorId: FieldRef<"QuizUserStats", 'String'>
    readonly artistName: FieldRef<"QuizUserStats", 'String'>
    readonly attemptCount: FieldRef<"QuizUserStats", 'Int'>
    readonly totalScore: FieldRef<"QuizUserStats", 'Float'>
    readonly averageScore: FieldRef<"QuizUserStats", 'Float'>
    readonly bestScore: FieldRef<"QuizUserStats", 'Float'>
    readonly bestAccuracy: FieldRef<"QuizUserStats", 'Float'>
    readonly bestSpeed: FieldRef<"QuizUserStats", 'Float'>
    readonly lastScore: FieldRef<"QuizUserStats", 'Float'>
    readonly lastPlayedAt: FieldRef<"QuizUserStats", 'DateTime'>
    readonly createdAt: FieldRef<"QuizUserStats", 'DateTime'>
    readonly updatedAt: FieldRef<"QuizUserStats", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuizUserStats findUnique
   */
  export type QuizUserStatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizUserStats
     */
    select?: QuizUserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizUserStats
     */
    omit?: QuizUserStatsOmit<ExtArgs> | null
    /**
     * Filter, which QuizUserStats to fetch.
     */
    where: QuizUserStatsWhereUniqueInput
  }

  /**
   * QuizUserStats findUniqueOrThrow
   */
  export type QuizUserStatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizUserStats
     */
    select?: QuizUserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizUserStats
     */
    omit?: QuizUserStatsOmit<ExtArgs> | null
    /**
     * Filter, which QuizUserStats to fetch.
     */
    where: QuizUserStatsWhereUniqueInput
  }

  /**
   * QuizUserStats findFirst
   */
  export type QuizUserStatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizUserStats
     */
    select?: QuizUserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizUserStats
     */
    omit?: QuizUserStatsOmit<ExtArgs> | null
    /**
     * Filter, which QuizUserStats to fetch.
     */
    where?: QuizUserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizUserStats to fetch.
     */
    orderBy?: QuizUserStatsOrderByWithRelationInput | QuizUserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizUserStats.
     */
    cursor?: QuizUserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizUserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizUserStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizUserStats.
     */
    distinct?: QuizUserStatsScalarFieldEnum | QuizUserStatsScalarFieldEnum[]
  }

  /**
   * QuizUserStats findFirstOrThrow
   */
  export type QuizUserStatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizUserStats
     */
    select?: QuizUserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizUserStats
     */
    omit?: QuizUserStatsOmit<ExtArgs> | null
    /**
     * Filter, which QuizUserStats to fetch.
     */
    where?: QuizUserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizUserStats to fetch.
     */
    orderBy?: QuizUserStatsOrderByWithRelationInput | QuizUserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuizUserStats.
     */
    cursor?: QuizUserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizUserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizUserStats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuizUserStats.
     */
    distinct?: QuizUserStatsScalarFieldEnum | QuizUserStatsScalarFieldEnum[]
  }

  /**
   * QuizUserStats findMany
   */
  export type QuizUserStatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizUserStats
     */
    select?: QuizUserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizUserStats
     */
    omit?: QuizUserStatsOmit<ExtArgs> | null
    /**
     * Filter, which QuizUserStats to fetch.
     */
    where?: QuizUserStatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuizUserStats to fetch.
     */
    orderBy?: QuizUserStatsOrderByWithRelationInput | QuizUserStatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuizUserStats.
     */
    cursor?: QuizUserStatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuizUserStats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuizUserStats.
     */
    skip?: number
    distinct?: QuizUserStatsScalarFieldEnum | QuizUserStatsScalarFieldEnum[]
  }

  /**
   * QuizUserStats create
   */
  export type QuizUserStatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizUserStats
     */
    select?: QuizUserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizUserStats
     */
    omit?: QuizUserStatsOmit<ExtArgs> | null
    /**
     * The data needed to create a QuizUserStats.
     */
    data: XOR<QuizUserStatsCreateInput, QuizUserStatsUncheckedCreateInput>
  }

  /**
   * QuizUserStats createMany
   */
  export type QuizUserStatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuizUserStats.
     */
    data: QuizUserStatsCreateManyInput | QuizUserStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizUserStats createManyAndReturn
   */
  export type QuizUserStatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizUserStats
     */
    select?: QuizUserStatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizUserStats
     */
    omit?: QuizUserStatsOmit<ExtArgs> | null
    /**
     * The data used to create many QuizUserStats.
     */
    data: QuizUserStatsCreateManyInput | QuizUserStatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuizUserStats update
   */
  export type QuizUserStatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizUserStats
     */
    select?: QuizUserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizUserStats
     */
    omit?: QuizUserStatsOmit<ExtArgs> | null
    /**
     * The data needed to update a QuizUserStats.
     */
    data: XOR<QuizUserStatsUpdateInput, QuizUserStatsUncheckedUpdateInput>
    /**
     * Choose, which QuizUserStats to update.
     */
    where: QuizUserStatsWhereUniqueInput
  }

  /**
   * QuizUserStats updateMany
   */
  export type QuizUserStatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuizUserStats.
     */
    data: XOR<QuizUserStatsUpdateManyMutationInput, QuizUserStatsUncheckedUpdateManyInput>
    /**
     * Filter which QuizUserStats to update
     */
    where?: QuizUserStatsWhereInput
    /**
     * Limit how many QuizUserStats to update.
     */
    limit?: number
  }

  /**
   * QuizUserStats updateManyAndReturn
   */
  export type QuizUserStatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizUserStats
     */
    select?: QuizUserStatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuizUserStats
     */
    omit?: QuizUserStatsOmit<ExtArgs> | null
    /**
     * The data used to update QuizUserStats.
     */
    data: XOR<QuizUserStatsUpdateManyMutationInput, QuizUserStatsUncheckedUpdateManyInput>
    /**
     * Filter which QuizUserStats to update
     */
    where?: QuizUserStatsWhereInput
    /**
     * Limit how many QuizUserStats to update.
     */
    limit?: number
  }

  /**
   * QuizUserStats upsert
   */
  export type QuizUserStatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizUserStats
     */
    select?: QuizUserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizUserStats
     */
    omit?: QuizUserStatsOmit<ExtArgs> | null
    /**
     * The filter to search for the QuizUserStats to update in case it exists.
     */
    where: QuizUserStatsWhereUniqueInput
    /**
     * In case the QuizUserStats found by the `where` argument doesn't exist, create a new QuizUserStats with this data.
     */
    create: XOR<QuizUserStatsCreateInput, QuizUserStatsUncheckedCreateInput>
    /**
     * In case the QuizUserStats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuizUserStatsUpdateInput, QuizUserStatsUncheckedUpdateInput>
  }

  /**
   * QuizUserStats delete
   */
  export type QuizUserStatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizUserStats
     */
    select?: QuizUserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizUserStats
     */
    omit?: QuizUserStatsOmit<ExtArgs> | null
    /**
     * Filter which QuizUserStats to delete.
     */
    where: QuizUserStatsWhereUniqueInput
  }

  /**
   * QuizUserStats deleteMany
   */
  export type QuizUserStatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuizUserStats to delete
     */
    where?: QuizUserStatsWhereInput
    /**
     * Limit how many QuizUserStats to delete.
     */
    limit?: number
  }

  /**
   * QuizUserStats without action
   */
  export type QuizUserStatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuizUserStats
     */
    select?: QuizUserStatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuizUserStats
     */
    omit?: QuizUserStatsOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    auth0Id: 'auth0Id',
    email: 'email',
    name: 'name',
    avatar: 'avatar',
    fandomScore: 'fandomScore',
    walletAddress: 'walletAddress',
    solanaWalletAddress: 'solanaWalletAddress',
    spotifyConnected: 'spotifyConnected',
    eventsAttended: 'eventsAttended',
    vouchesGiven: 'vouchesGiven',
    vouchesReceived: 'vouchesReceived',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    artist: 'artist',
    artistImage: 'artistImage',
    venue: 'venue',
    location: 'location',
    date: 'date',
    time: 'time',
    image: 'image',
    description: 'description',
    category: 'category',
    status: 'status',
    totalTickets: 'totalTickets',
    soldTickets: 'soldTickets',
    resaleEnabled: 'resaleEnabled',
    resaleCap: 'resaleCap',
    artistRoyalty: 'artistRoyalty',
    minFandomScore: 'minFandomScore',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const EventReminderScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type EventReminderScalarFieldEnum = (typeof EventReminderScalarFieldEnum)[keyof typeof EventReminderScalarFieldEnum]


  export const TicketTierScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    name: 'name',
    price: 'price',
    currency: 'currency',
    description: 'description',
    available: 'available',
    total: 'total',
    benefits: 'benefits'
  };

  export type TicketTierScalarFieldEnum = (typeof TicketTierScalarFieldEnum)[keyof typeof TicketTierScalarFieldEnum]


  export const TicketScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    tierId: 'tierId',
    ownerId: 'ownerId',
    originalPrice: 'originalPrice',
    currentPrice: 'currentPrice',
    purchaseDate: 'purchaseDate',
    status: 'status',
    qrCode: 'qrCode',
    tokenId: 'tokenId',
    txHash: 'txHash',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TicketScalarFieldEnum = (typeof TicketScalarFieldEnum)[keyof typeof TicketScalarFieldEnum]


  export const CommunityScalarFieldEnum: {
    id: 'id',
    name: 'name',
    artistId: 'artistId',
    artistName: 'artistName',
    artistImage: 'artistImage',
    description: 'description',
    memberCount: 'memberCount',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommunityScalarFieldEnum = (typeof CommunityScalarFieldEnum)[keyof typeof CommunityScalarFieldEnum]


  export const CommunityPostScalarFieldEnum: {
    id: 'id',
    communityId: 'communityId',
    authorId: 'authorId',
    title: 'title',
    content: 'content',
    type: 'type',
    images: 'images',
    upvotes: 'upvotes',
    downvotes: 'downvotes',
    commentCount: 'commentCount',
    isPinned: 'isPinned',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommunityPostScalarFieldEnum = (typeof CommunityPostScalarFieldEnum)[keyof typeof CommunityPostScalarFieldEnum]


  export const PostVoteScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type PostVoteScalarFieldEnum = (typeof PostVoteScalarFieldEnum)[keyof typeof PostVoteScalarFieldEnum]


  export const CommunityMemberScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    communityId: 'communityId',
    role: 'role',
    reputationPoints: 'reputationPoints',
    votingPower: 'votingPower',
    isActive: 'isActive',
    joinedAt: 'joinedAt'
  };

  export type CommunityMemberScalarFieldEnum = (typeof CommunityMemberScalarFieldEnum)[keyof typeof CommunityMemberScalarFieldEnum]


  export const GovernanceProposalScalarFieldEnum: {
    id: 'id',
    communityId: 'communityId',
    proposerId: 'proposerId',
    title: 'title',
    description: 'description',
    type: 'type',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    quorumRequired: 'quorumRequired',
    totalVotes: 'totalVotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GovernanceProposalScalarFieldEnum = (typeof GovernanceProposalScalarFieldEnum)[keyof typeof GovernanceProposalScalarFieldEnum]


  export const ProposalOptionScalarFieldEnum: {
    id: 'id',
    proposalId: 'proposalId',
    text: 'text',
    votes: 'votes'
  };

  export type ProposalOptionScalarFieldEnum = (typeof ProposalOptionScalarFieldEnum)[keyof typeof ProposalOptionScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    content: 'content',
    postId: 'postId',
    authorId: 'authorId',
    parentId: 'parentId',
    upvotes: 'upvotes',
    downvotes: 'downvotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const CommentVoteScalarFieldEnum: {
    id: 'id',
    commentId: 'commentId',
    userId: 'userId',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type CommentVoteScalarFieldEnum = (typeof CommentVoteScalarFieldEnum)[keyof typeof CommentVoteScalarFieldEnum]


  export const QuizScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    artistId: 'artistId',
    artistName: 'artistName',
    type: 'type',
    status: 'status',
    duration: 'duration',
    questionCount: 'questionCount',
    startTime: 'startTime',
    endTime: 'endTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuizScalarFieldEnum = (typeof QuizScalarFieldEnum)[keyof typeof QuizScalarFieldEnum]


  export const QuizQuestionScalarFieldEnum: {
    id: 'id',
    quizId: 'quizId',
    question: 'question',
    type: 'type',
    options: 'options',
    correctAnswer: 'correctAnswer',
    imageUrl: 'imageUrl',
    timeLimit: 'timeLimit',
    difficulty: 'difficulty',
    orderIndex: 'orderIndex',
    createdAt: 'createdAt'
  };

  export type QuizQuestionScalarFieldEnum = (typeof QuizQuestionScalarFieldEnum)[keyof typeof QuizQuestionScalarFieldEnum]


  export const QuizAttemptScalarFieldEnum: {
    id: 'id',
    quizId: 'quizId',
    userId: 'userId',
    correctAnswers: 'correctAnswers',
    totalQuestions: 'totalQuestions',
    avgResponseTime: 'avgResponseTime',
    responseTimeStdDev: 'responseTimeStdDev',
    streak: 'streak',
    maxStreak: 'maxStreak',
    finalScore: 'finalScore',
    speedScore: 'speedScore',
    accuracyScore: 'accuracyScore',
    consistencyScore: 'consistencyScore',
    rank: 'rank',
    status: 'status',
    startedAt: 'startedAt',
    completedAt: 'completedAt'
  };

  export type QuizAttemptScalarFieldEnum = (typeof QuizAttemptScalarFieldEnum)[keyof typeof QuizAttemptScalarFieldEnum]


  export const QuizResponseScalarFieldEnum: {
    id: 'id',
    attemptId: 'attemptId',
    questionId: 'questionId',
    answer: 'answer',
    isCorrect: 'isCorrect',
    responseTime: 'responseTime',
    answeredAt: 'answeredAt'
  };

  export type QuizResponseScalarFieldEnum = (typeof QuizResponseScalarFieldEnum)[keyof typeof QuizResponseScalarFieldEnum]


  export const FanIQBadgeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tier: 'tier',
    artistId: 'artistId',
    artistName: 'artistName',
    tokenId: 'tokenId',
    txHash: 'txHash',
    earnedAt: 'earnedAt'
  };

  export type FanIQBadgeScalarFieldEnum = (typeof FanIQBadgeScalarFieldEnum)[keyof typeof FanIQBadgeScalarFieldEnum]


  export const QuizUserStatsScalarFieldEnum: {
    id: 'id',
    visitorId: 'visitorId',
    artistName: 'artistName',
    attemptCount: 'attemptCount',
    totalScore: 'totalScore',
    averageScore: 'averageScore',
    bestScore: 'bestScore',
    bestAccuracy: 'bestAccuracy',
    bestSpeed: 'bestSpeed',
    lastScore: 'lastScore',
    lastPlayedAt: 'lastPlayedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuizUserStatsScalarFieldEnum = (typeof QuizUserStatsScalarFieldEnum)[keyof typeof QuizUserStatsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    auth0Id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    fandomScore?: IntFilter<"User"> | number
    walletAddress?: StringNullableFilter<"User"> | string | null
    solanaWalletAddress?: StringNullableFilter<"User"> | string | null
    spotifyConnected?: BoolFilter<"User"> | boolean
    eventsAttended?: IntFilter<"User"> | number
    vouchesGiven?: IntFilter<"User"> | number
    vouchesReceived?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tickets?: TicketListRelationFilter
    posts?: CommunityPostListRelationFilter
    memberships?: CommunityMemberListRelationFilter
    postVotes?: PostVoteListRelationFilter
    comments?: CommentListRelationFilter
    commentVotes?: CommentVoteListRelationFilter
    reminders?: EventReminderListRelationFilter
    quizAttempts?: QuizAttemptListRelationFilter
    fanIQBadges?: FanIQBadgeListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    auth0Id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrderInput | SortOrder
    fandomScore?: SortOrder
    walletAddress?: SortOrderInput | SortOrder
    solanaWalletAddress?: SortOrderInput | SortOrder
    spotifyConnected?: SortOrder
    eventsAttended?: SortOrder
    vouchesGiven?: SortOrder
    vouchesReceived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tickets?: TicketOrderByRelationAggregateInput
    posts?: CommunityPostOrderByRelationAggregateInput
    memberships?: CommunityMemberOrderByRelationAggregateInput
    postVotes?: PostVoteOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    commentVotes?: CommentVoteOrderByRelationAggregateInput
    reminders?: EventReminderOrderByRelationAggregateInput
    quizAttempts?: QuizAttemptOrderByRelationAggregateInput
    fanIQBadges?: FanIQBadgeOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    auth0Id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    avatar?: StringNullableFilter<"User"> | string | null
    fandomScore?: IntFilter<"User"> | number
    walletAddress?: StringNullableFilter<"User"> | string | null
    solanaWalletAddress?: StringNullableFilter<"User"> | string | null
    spotifyConnected?: BoolFilter<"User"> | boolean
    eventsAttended?: IntFilter<"User"> | number
    vouchesGiven?: IntFilter<"User"> | number
    vouchesReceived?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tickets?: TicketListRelationFilter
    posts?: CommunityPostListRelationFilter
    memberships?: CommunityMemberListRelationFilter
    postVotes?: PostVoteListRelationFilter
    comments?: CommentListRelationFilter
    commentVotes?: CommentVoteListRelationFilter
    reminders?: EventReminderListRelationFilter
    quizAttempts?: QuizAttemptListRelationFilter
    fanIQBadges?: FanIQBadgeListRelationFilter
  }, "id" | "auth0Id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    auth0Id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrderInput | SortOrder
    fandomScore?: SortOrder
    walletAddress?: SortOrderInput | SortOrder
    solanaWalletAddress?: SortOrderInput | SortOrder
    spotifyConnected?: SortOrder
    eventsAttended?: SortOrder
    vouchesGiven?: SortOrder
    vouchesReceived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    auth0Id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    fandomScore?: IntWithAggregatesFilter<"User"> | number
    walletAddress?: StringNullableWithAggregatesFilter<"User"> | string | null
    solanaWalletAddress?: StringNullableWithAggregatesFilter<"User"> | string | null
    spotifyConnected?: BoolWithAggregatesFilter<"User"> | boolean
    eventsAttended?: IntWithAggregatesFilter<"User"> | number
    vouchesGiven?: IntWithAggregatesFilter<"User"> | number
    vouchesReceived?: IntWithAggregatesFilter<"User"> | number
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    artist?: StringFilter<"Event"> | string
    artistImage?: StringFilter<"Event"> | string
    venue?: StringFilter<"Event"> | string
    location?: StringFilter<"Event"> | string
    date?: DateTimeFilter<"Event"> | Date | string
    time?: StringFilter<"Event"> | string
    image?: StringFilter<"Event"> | string
    description?: StringFilter<"Event"> | string
    category?: StringFilter<"Event"> | string
    status?: StringFilter<"Event"> | string
    totalTickets?: IntFilter<"Event"> | number
    soldTickets?: IntFilter<"Event"> | number
    resaleEnabled?: BoolFilter<"Event"> | boolean
    resaleCap?: IntNullableFilter<"Event"> | number | null
    artistRoyalty?: IntFilter<"Event"> | number
    minFandomScore?: IntNullableFilter<"Event"> | number | null
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    ticketTiers?: TicketTierListRelationFilter
    tickets?: TicketListRelationFilter
    reminders?: EventReminderListRelationFilter
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    artist?: SortOrder
    artistImage?: SortOrder
    venue?: SortOrder
    location?: SortOrder
    date?: SortOrder
    time?: SortOrder
    image?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    totalTickets?: SortOrder
    soldTickets?: SortOrder
    resaleEnabled?: SortOrder
    resaleCap?: SortOrderInput | SortOrder
    artistRoyalty?: SortOrder
    minFandomScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ticketTiers?: TicketTierOrderByRelationAggregateInput
    tickets?: TicketOrderByRelationAggregateInput
    reminders?: EventReminderOrderByRelationAggregateInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    title?: StringFilter<"Event"> | string
    artist?: StringFilter<"Event"> | string
    artistImage?: StringFilter<"Event"> | string
    venue?: StringFilter<"Event"> | string
    location?: StringFilter<"Event"> | string
    date?: DateTimeFilter<"Event"> | Date | string
    time?: StringFilter<"Event"> | string
    image?: StringFilter<"Event"> | string
    description?: StringFilter<"Event"> | string
    category?: StringFilter<"Event"> | string
    status?: StringFilter<"Event"> | string
    totalTickets?: IntFilter<"Event"> | number
    soldTickets?: IntFilter<"Event"> | number
    resaleEnabled?: BoolFilter<"Event"> | boolean
    resaleCap?: IntNullableFilter<"Event"> | number | null
    artistRoyalty?: IntFilter<"Event"> | number
    minFandomScore?: IntNullableFilter<"Event"> | number | null
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    ticketTiers?: TicketTierListRelationFilter
    tickets?: TicketListRelationFilter
    reminders?: EventReminderListRelationFilter
  }, "id">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    artist?: SortOrder
    artistImage?: SortOrder
    venue?: SortOrder
    location?: SortOrder
    date?: SortOrder
    time?: SortOrder
    image?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    totalTickets?: SortOrder
    soldTickets?: SortOrder
    resaleEnabled?: SortOrder
    resaleCap?: SortOrderInput | SortOrder
    artistRoyalty?: SortOrder
    minFandomScore?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _avg?: EventAvgOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
    _sum?: EventSumOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    title?: StringWithAggregatesFilter<"Event"> | string
    artist?: StringWithAggregatesFilter<"Event"> | string
    artistImage?: StringWithAggregatesFilter<"Event"> | string
    venue?: StringWithAggregatesFilter<"Event"> | string
    location?: StringWithAggregatesFilter<"Event"> | string
    date?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    time?: StringWithAggregatesFilter<"Event"> | string
    image?: StringWithAggregatesFilter<"Event"> | string
    description?: StringWithAggregatesFilter<"Event"> | string
    category?: StringWithAggregatesFilter<"Event"> | string
    status?: StringWithAggregatesFilter<"Event"> | string
    totalTickets?: IntWithAggregatesFilter<"Event"> | number
    soldTickets?: IntWithAggregatesFilter<"Event"> | number
    resaleEnabled?: BoolWithAggregatesFilter<"Event"> | boolean
    resaleCap?: IntNullableWithAggregatesFilter<"Event"> | number | null
    artistRoyalty?: IntWithAggregatesFilter<"Event"> | number
    minFandomScore?: IntNullableWithAggregatesFilter<"Event"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
  }

  export type EventReminderWhereInput = {
    AND?: EventReminderWhereInput | EventReminderWhereInput[]
    OR?: EventReminderWhereInput[]
    NOT?: EventReminderWhereInput | EventReminderWhereInput[]
    id?: StringFilter<"EventReminder"> | string
    eventId?: StringFilter<"EventReminder"> | string
    userId?: StringFilter<"EventReminder"> | string
    createdAt?: DateTimeFilter<"EventReminder"> | Date | string
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EventReminderOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    event?: EventOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type EventReminderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    eventId_userId?: EventReminderEventIdUserIdCompoundUniqueInput
    AND?: EventReminderWhereInput | EventReminderWhereInput[]
    OR?: EventReminderWhereInput[]
    NOT?: EventReminderWhereInput | EventReminderWhereInput[]
    eventId?: StringFilter<"EventReminder"> | string
    userId?: StringFilter<"EventReminder"> | string
    createdAt?: DateTimeFilter<"EventReminder"> | Date | string
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "eventId_userId">

  export type EventReminderOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: EventReminderCountOrderByAggregateInput
    _max?: EventReminderMaxOrderByAggregateInput
    _min?: EventReminderMinOrderByAggregateInput
  }

  export type EventReminderScalarWhereWithAggregatesInput = {
    AND?: EventReminderScalarWhereWithAggregatesInput | EventReminderScalarWhereWithAggregatesInput[]
    OR?: EventReminderScalarWhereWithAggregatesInput[]
    NOT?: EventReminderScalarWhereWithAggregatesInput | EventReminderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventReminder"> | string
    eventId?: StringWithAggregatesFilter<"EventReminder"> | string
    userId?: StringWithAggregatesFilter<"EventReminder"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EventReminder"> | Date | string
  }

  export type TicketTierWhereInput = {
    AND?: TicketTierWhereInput | TicketTierWhereInput[]
    OR?: TicketTierWhereInput[]
    NOT?: TicketTierWhereInput | TicketTierWhereInput[]
    id?: StringFilter<"TicketTier"> | string
    eventId?: StringFilter<"TicketTier"> | string
    name?: StringFilter<"TicketTier"> | string
    price?: FloatFilter<"TicketTier"> | number
    currency?: StringFilter<"TicketTier"> | string
    description?: StringFilter<"TicketTier"> | string
    available?: IntFilter<"TicketTier"> | number
    total?: IntFilter<"TicketTier"> | number
    benefits?: StringNullableListFilter<"TicketTier">
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    tickets?: TicketListRelationFilter
  }

  export type TicketTierOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    available?: SortOrder
    total?: SortOrder
    benefits?: SortOrder
    event?: EventOrderByWithRelationInput
    tickets?: TicketOrderByRelationAggregateInput
  }

  export type TicketTierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketTierWhereInput | TicketTierWhereInput[]
    OR?: TicketTierWhereInput[]
    NOT?: TicketTierWhereInput | TicketTierWhereInput[]
    eventId?: StringFilter<"TicketTier"> | string
    name?: StringFilter<"TicketTier"> | string
    price?: FloatFilter<"TicketTier"> | number
    currency?: StringFilter<"TicketTier"> | string
    description?: StringFilter<"TicketTier"> | string
    available?: IntFilter<"TicketTier"> | number
    total?: IntFilter<"TicketTier"> | number
    benefits?: StringNullableListFilter<"TicketTier">
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    tickets?: TicketListRelationFilter
  }, "id">

  export type TicketTierOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    available?: SortOrder
    total?: SortOrder
    benefits?: SortOrder
    _count?: TicketTierCountOrderByAggregateInput
    _avg?: TicketTierAvgOrderByAggregateInput
    _max?: TicketTierMaxOrderByAggregateInput
    _min?: TicketTierMinOrderByAggregateInput
    _sum?: TicketTierSumOrderByAggregateInput
  }

  export type TicketTierScalarWhereWithAggregatesInput = {
    AND?: TicketTierScalarWhereWithAggregatesInput | TicketTierScalarWhereWithAggregatesInput[]
    OR?: TicketTierScalarWhereWithAggregatesInput[]
    NOT?: TicketTierScalarWhereWithAggregatesInput | TicketTierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TicketTier"> | string
    eventId?: StringWithAggregatesFilter<"TicketTier"> | string
    name?: StringWithAggregatesFilter<"TicketTier"> | string
    price?: FloatWithAggregatesFilter<"TicketTier"> | number
    currency?: StringWithAggregatesFilter<"TicketTier"> | string
    description?: StringWithAggregatesFilter<"TicketTier"> | string
    available?: IntWithAggregatesFilter<"TicketTier"> | number
    total?: IntWithAggregatesFilter<"TicketTier"> | number
    benefits?: StringNullableListFilter<"TicketTier">
  }

  export type TicketWhereInput = {
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    id?: StringFilter<"Ticket"> | string
    eventId?: StringFilter<"Ticket"> | string
    tierId?: StringFilter<"Ticket"> | string
    ownerId?: StringFilter<"Ticket"> | string
    originalPrice?: FloatFilter<"Ticket"> | number
    currentPrice?: FloatFilter<"Ticket"> | number
    purchaseDate?: DateTimeFilter<"Ticket"> | Date | string
    status?: StringFilter<"Ticket"> | string
    qrCode?: StringNullableFilter<"Ticket"> | string | null
    tokenId?: StringNullableFilter<"Ticket"> | string | null
    txHash?: StringNullableFilter<"Ticket"> | string | null
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    tier?: XOR<TicketTierScalarRelationFilter, TicketTierWhereInput>
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TicketOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    tierId?: SortOrder
    ownerId?: SortOrder
    originalPrice?: SortOrder
    currentPrice?: SortOrder
    purchaseDate?: SortOrder
    status?: SortOrder
    qrCode?: SortOrderInput | SortOrder
    tokenId?: SortOrderInput | SortOrder
    txHash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    event?: EventOrderByWithRelationInput
    tier?: TicketTierOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
  }

  export type TicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    eventId?: StringFilter<"Ticket"> | string
    tierId?: StringFilter<"Ticket"> | string
    ownerId?: StringFilter<"Ticket"> | string
    originalPrice?: FloatFilter<"Ticket"> | number
    currentPrice?: FloatFilter<"Ticket"> | number
    purchaseDate?: DateTimeFilter<"Ticket"> | Date | string
    status?: StringFilter<"Ticket"> | string
    qrCode?: StringNullableFilter<"Ticket"> | string | null
    tokenId?: StringNullableFilter<"Ticket"> | string | null
    txHash?: StringNullableFilter<"Ticket"> | string | null
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    event?: XOR<EventScalarRelationFilter, EventWhereInput>
    tier?: XOR<TicketTierScalarRelationFilter, TicketTierWhereInput>
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TicketOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    tierId?: SortOrder
    ownerId?: SortOrder
    originalPrice?: SortOrder
    currentPrice?: SortOrder
    purchaseDate?: SortOrder
    status?: SortOrder
    qrCode?: SortOrderInput | SortOrder
    tokenId?: SortOrderInput | SortOrder
    txHash?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TicketCountOrderByAggregateInput
    _avg?: TicketAvgOrderByAggregateInput
    _max?: TicketMaxOrderByAggregateInput
    _min?: TicketMinOrderByAggregateInput
    _sum?: TicketSumOrderByAggregateInput
  }

  export type TicketScalarWhereWithAggregatesInput = {
    AND?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    OR?: TicketScalarWhereWithAggregatesInput[]
    NOT?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ticket"> | string
    eventId?: StringWithAggregatesFilter<"Ticket"> | string
    tierId?: StringWithAggregatesFilter<"Ticket"> | string
    ownerId?: StringWithAggregatesFilter<"Ticket"> | string
    originalPrice?: FloatWithAggregatesFilter<"Ticket"> | number
    currentPrice?: FloatWithAggregatesFilter<"Ticket"> | number
    purchaseDate?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    status?: StringWithAggregatesFilter<"Ticket"> | string
    qrCode?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    tokenId?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    txHash?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
  }

  export type CommunityWhereInput = {
    AND?: CommunityWhereInput | CommunityWhereInput[]
    OR?: CommunityWhereInput[]
    NOT?: CommunityWhereInput | CommunityWhereInput[]
    id?: StringFilter<"Community"> | string
    name?: StringFilter<"Community"> | string
    artistId?: StringFilter<"Community"> | string
    artistName?: StringFilter<"Community"> | string
    artistImage?: StringFilter<"Community"> | string
    description?: StringFilter<"Community"> | string
    memberCount?: IntFilter<"Community"> | number
    isActive?: BoolFilter<"Community"> | boolean
    createdAt?: DateTimeFilter<"Community"> | Date | string
    updatedAt?: DateTimeFilter<"Community"> | Date | string
    posts?: CommunityPostListRelationFilter
    members?: CommunityMemberListRelationFilter
    proposals?: GovernanceProposalListRelationFilter
  }

  export type CommunityOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    artistId?: SortOrder
    artistName?: SortOrder
    artistImage?: SortOrder
    description?: SortOrder
    memberCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    posts?: CommunityPostOrderByRelationAggregateInput
    members?: CommunityMemberOrderByRelationAggregateInput
    proposals?: GovernanceProposalOrderByRelationAggregateInput
  }

  export type CommunityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommunityWhereInput | CommunityWhereInput[]
    OR?: CommunityWhereInput[]
    NOT?: CommunityWhereInput | CommunityWhereInput[]
    name?: StringFilter<"Community"> | string
    artistId?: StringFilter<"Community"> | string
    artistName?: StringFilter<"Community"> | string
    artistImage?: StringFilter<"Community"> | string
    description?: StringFilter<"Community"> | string
    memberCount?: IntFilter<"Community"> | number
    isActive?: BoolFilter<"Community"> | boolean
    createdAt?: DateTimeFilter<"Community"> | Date | string
    updatedAt?: DateTimeFilter<"Community"> | Date | string
    posts?: CommunityPostListRelationFilter
    members?: CommunityMemberListRelationFilter
    proposals?: GovernanceProposalListRelationFilter
  }, "id">

  export type CommunityOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    artistId?: SortOrder
    artistName?: SortOrder
    artistImage?: SortOrder
    description?: SortOrder
    memberCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommunityCountOrderByAggregateInput
    _avg?: CommunityAvgOrderByAggregateInput
    _max?: CommunityMaxOrderByAggregateInput
    _min?: CommunityMinOrderByAggregateInput
    _sum?: CommunitySumOrderByAggregateInput
  }

  export type CommunityScalarWhereWithAggregatesInput = {
    AND?: CommunityScalarWhereWithAggregatesInput | CommunityScalarWhereWithAggregatesInput[]
    OR?: CommunityScalarWhereWithAggregatesInput[]
    NOT?: CommunityScalarWhereWithAggregatesInput | CommunityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Community"> | string
    name?: StringWithAggregatesFilter<"Community"> | string
    artistId?: StringWithAggregatesFilter<"Community"> | string
    artistName?: StringWithAggregatesFilter<"Community"> | string
    artistImage?: StringWithAggregatesFilter<"Community"> | string
    description?: StringWithAggregatesFilter<"Community"> | string
    memberCount?: IntWithAggregatesFilter<"Community"> | number
    isActive?: BoolWithAggregatesFilter<"Community"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Community"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Community"> | Date | string
  }

  export type CommunityPostWhereInput = {
    AND?: CommunityPostWhereInput | CommunityPostWhereInput[]
    OR?: CommunityPostWhereInput[]
    NOT?: CommunityPostWhereInput | CommunityPostWhereInput[]
    id?: StringFilter<"CommunityPost"> | string
    communityId?: StringFilter<"CommunityPost"> | string
    authorId?: StringFilter<"CommunityPost"> | string
    title?: StringFilter<"CommunityPost"> | string
    content?: StringFilter<"CommunityPost"> | string
    type?: StringFilter<"CommunityPost"> | string
    images?: StringNullableListFilter<"CommunityPost">
    upvotes?: IntFilter<"CommunityPost"> | number
    downvotes?: IntFilter<"CommunityPost"> | number
    commentCount?: IntFilter<"CommunityPost"> | number
    isPinned?: BoolFilter<"CommunityPost"> | boolean
    createdAt?: DateTimeFilter<"CommunityPost"> | Date | string
    updatedAt?: DateTimeFilter<"CommunityPost"> | Date | string
    community?: XOR<CommunityScalarRelationFilter, CommunityWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    votes?: PostVoteListRelationFilter
    comments?: CommentListRelationFilter
  }

  export type CommunityPostOrderByWithRelationInput = {
    id?: SortOrder
    communityId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    images?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    commentCount?: SortOrder
    isPinned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    community?: CommunityOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    votes?: PostVoteOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
  }

  export type CommunityPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommunityPostWhereInput | CommunityPostWhereInput[]
    OR?: CommunityPostWhereInput[]
    NOT?: CommunityPostWhereInput | CommunityPostWhereInput[]
    communityId?: StringFilter<"CommunityPost"> | string
    authorId?: StringFilter<"CommunityPost"> | string
    title?: StringFilter<"CommunityPost"> | string
    content?: StringFilter<"CommunityPost"> | string
    type?: StringFilter<"CommunityPost"> | string
    images?: StringNullableListFilter<"CommunityPost">
    upvotes?: IntFilter<"CommunityPost"> | number
    downvotes?: IntFilter<"CommunityPost"> | number
    commentCount?: IntFilter<"CommunityPost"> | number
    isPinned?: BoolFilter<"CommunityPost"> | boolean
    createdAt?: DateTimeFilter<"CommunityPost"> | Date | string
    updatedAt?: DateTimeFilter<"CommunityPost"> | Date | string
    community?: XOR<CommunityScalarRelationFilter, CommunityWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    votes?: PostVoteListRelationFilter
    comments?: CommentListRelationFilter
  }, "id">

  export type CommunityPostOrderByWithAggregationInput = {
    id?: SortOrder
    communityId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    images?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    commentCount?: SortOrder
    isPinned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommunityPostCountOrderByAggregateInput
    _avg?: CommunityPostAvgOrderByAggregateInput
    _max?: CommunityPostMaxOrderByAggregateInput
    _min?: CommunityPostMinOrderByAggregateInput
    _sum?: CommunityPostSumOrderByAggregateInput
  }

  export type CommunityPostScalarWhereWithAggregatesInput = {
    AND?: CommunityPostScalarWhereWithAggregatesInput | CommunityPostScalarWhereWithAggregatesInput[]
    OR?: CommunityPostScalarWhereWithAggregatesInput[]
    NOT?: CommunityPostScalarWhereWithAggregatesInput | CommunityPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommunityPost"> | string
    communityId?: StringWithAggregatesFilter<"CommunityPost"> | string
    authorId?: StringWithAggregatesFilter<"CommunityPost"> | string
    title?: StringWithAggregatesFilter<"CommunityPost"> | string
    content?: StringWithAggregatesFilter<"CommunityPost"> | string
    type?: StringWithAggregatesFilter<"CommunityPost"> | string
    images?: StringNullableListFilter<"CommunityPost">
    upvotes?: IntWithAggregatesFilter<"CommunityPost"> | number
    downvotes?: IntWithAggregatesFilter<"CommunityPost"> | number
    commentCount?: IntWithAggregatesFilter<"CommunityPost"> | number
    isPinned?: BoolWithAggregatesFilter<"CommunityPost"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CommunityPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CommunityPost"> | Date | string
  }

  export type PostVoteWhereInput = {
    AND?: PostVoteWhereInput | PostVoteWhereInput[]
    OR?: PostVoteWhereInput[]
    NOT?: PostVoteWhereInput | PostVoteWhereInput[]
    id?: StringFilter<"PostVote"> | string
    postId?: StringFilter<"PostVote"> | string
    userId?: StringFilter<"PostVote"> | string
    type?: StringFilter<"PostVote"> | string
    createdAt?: DateTimeFilter<"PostVote"> | Date | string
    post?: XOR<CommunityPostScalarRelationFilter, CommunityPostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PostVoteOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    post?: CommunityPostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PostVoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    postId_userId?: PostVotePostIdUserIdCompoundUniqueInput
    AND?: PostVoteWhereInput | PostVoteWhereInput[]
    OR?: PostVoteWhereInput[]
    NOT?: PostVoteWhereInput | PostVoteWhereInput[]
    postId?: StringFilter<"PostVote"> | string
    userId?: StringFilter<"PostVote"> | string
    type?: StringFilter<"PostVote"> | string
    createdAt?: DateTimeFilter<"PostVote"> | Date | string
    post?: XOR<CommunityPostScalarRelationFilter, CommunityPostWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "postId_userId">

  export type PostVoteOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: PostVoteCountOrderByAggregateInput
    _max?: PostVoteMaxOrderByAggregateInput
    _min?: PostVoteMinOrderByAggregateInput
  }

  export type PostVoteScalarWhereWithAggregatesInput = {
    AND?: PostVoteScalarWhereWithAggregatesInput | PostVoteScalarWhereWithAggregatesInput[]
    OR?: PostVoteScalarWhereWithAggregatesInput[]
    NOT?: PostVoteScalarWhereWithAggregatesInput | PostVoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PostVote"> | string
    postId?: StringWithAggregatesFilter<"PostVote"> | string
    userId?: StringWithAggregatesFilter<"PostVote"> | string
    type?: StringWithAggregatesFilter<"PostVote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PostVote"> | Date | string
  }

  export type CommunityMemberWhereInput = {
    AND?: CommunityMemberWhereInput | CommunityMemberWhereInput[]
    OR?: CommunityMemberWhereInput[]
    NOT?: CommunityMemberWhereInput | CommunityMemberWhereInput[]
    id?: StringFilter<"CommunityMember"> | string
    userId?: StringFilter<"CommunityMember"> | string
    communityId?: StringFilter<"CommunityMember"> | string
    role?: StringFilter<"CommunityMember"> | string
    reputationPoints?: IntFilter<"CommunityMember"> | number
    votingPower?: IntFilter<"CommunityMember"> | number
    isActive?: BoolFilter<"CommunityMember"> | boolean
    joinedAt?: DateTimeFilter<"CommunityMember"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    community?: XOR<CommunityScalarRelationFilter, CommunityWhereInput>
  }

  export type CommunityMemberOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    communityId?: SortOrder
    role?: SortOrder
    reputationPoints?: SortOrder
    votingPower?: SortOrder
    isActive?: SortOrder
    joinedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    community?: CommunityOrderByWithRelationInput
  }

  export type CommunityMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_communityId?: CommunityMemberUserIdCommunityIdCompoundUniqueInput
    AND?: CommunityMemberWhereInput | CommunityMemberWhereInput[]
    OR?: CommunityMemberWhereInput[]
    NOT?: CommunityMemberWhereInput | CommunityMemberWhereInput[]
    userId?: StringFilter<"CommunityMember"> | string
    communityId?: StringFilter<"CommunityMember"> | string
    role?: StringFilter<"CommunityMember"> | string
    reputationPoints?: IntFilter<"CommunityMember"> | number
    votingPower?: IntFilter<"CommunityMember"> | number
    isActive?: BoolFilter<"CommunityMember"> | boolean
    joinedAt?: DateTimeFilter<"CommunityMember"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    community?: XOR<CommunityScalarRelationFilter, CommunityWhereInput>
  }, "id" | "userId_communityId">

  export type CommunityMemberOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    communityId?: SortOrder
    role?: SortOrder
    reputationPoints?: SortOrder
    votingPower?: SortOrder
    isActive?: SortOrder
    joinedAt?: SortOrder
    _count?: CommunityMemberCountOrderByAggregateInput
    _avg?: CommunityMemberAvgOrderByAggregateInput
    _max?: CommunityMemberMaxOrderByAggregateInput
    _min?: CommunityMemberMinOrderByAggregateInput
    _sum?: CommunityMemberSumOrderByAggregateInput
  }

  export type CommunityMemberScalarWhereWithAggregatesInput = {
    AND?: CommunityMemberScalarWhereWithAggregatesInput | CommunityMemberScalarWhereWithAggregatesInput[]
    OR?: CommunityMemberScalarWhereWithAggregatesInput[]
    NOT?: CommunityMemberScalarWhereWithAggregatesInput | CommunityMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommunityMember"> | string
    userId?: StringWithAggregatesFilter<"CommunityMember"> | string
    communityId?: StringWithAggregatesFilter<"CommunityMember"> | string
    role?: StringWithAggregatesFilter<"CommunityMember"> | string
    reputationPoints?: IntWithAggregatesFilter<"CommunityMember"> | number
    votingPower?: IntWithAggregatesFilter<"CommunityMember"> | number
    isActive?: BoolWithAggregatesFilter<"CommunityMember"> | boolean
    joinedAt?: DateTimeWithAggregatesFilter<"CommunityMember"> | Date | string
  }

  export type GovernanceProposalWhereInput = {
    AND?: GovernanceProposalWhereInput | GovernanceProposalWhereInput[]
    OR?: GovernanceProposalWhereInput[]
    NOT?: GovernanceProposalWhereInput | GovernanceProposalWhereInput[]
    id?: StringFilter<"GovernanceProposal"> | string
    communityId?: StringFilter<"GovernanceProposal"> | string
    proposerId?: StringFilter<"GovernanceProposal"> | string
    title?: StringFilter<"GovernanceProposal"> | string
    description?: StringFilter<"GovernanceProposal"> | string
    type?: StringFilter<"GovernanceProposal"> | string
    status?: StringFilter<"GovernanceProposal"> | string
    startDate?: DateTimeFilter<"GovernanceProposal"> | Date | string
    endDate?: DateTimeFilter<"GovernanceProposal"> | Date | string
    quorumRequired?: IntFilter<"GovernanceProposal"> | number
    totalVotes?: IntFilter<"GovernanceProposal"> | number
    createdAt?: DateTimeFilter<"GovernanceProposal"> | Date | string
    updatedAt?: DateTimeFilter<"GovernanceProposal"> | Date | string
    community?: XOR<CommunityScalarRelationFilter, CommunityWhereInput>
    options?: ProposalOptionListRelationFilter
  }

  export type GovernanceProposalOrderByWithRelationInput = {
    id?: SortOrder
    communityId?: SortOrder
    proposerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    quorumRequired?: SortOrder
    totalVotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    community?: CommunityOrderByWithRelationInput
    options?: ProposalOptionOrderByRelationAggregateInput
  }

  export type GovernanceProposalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GovernanceProposalWhereInput | GovernanceProposalWhereInput[]
    OR?: GovernanceProposalWhereInput[]
    NOT?: GovernanceProposalWhereInput | GovernanceProposalWhereInput[]
    communityId?: StringFilter<"GovernanceProposal"> | string
    proposerId?: StringFilter<"GovernanceProposal"> | string
    title?: StringFilter<"GovernanceProposal"> | string
    description?: StringFilter<"GovernanceProposal"> | string
    type?: StringFilter<"GovernanceProposal"> | string
    status?: StringFilter<"GovernanceProposal"> | string
    startDate?: DateTimeFilter<"GovernanceProposal"> | Date | string
    endDate?: DateTimeFilter<"GovernanceProposal"> | Date | string
    quorumRequired?: IntFilter<"GovernanceProposal"> | number
    totalVotes?: IntFilter<"GovernanceProposal"> | number
    createdAt?: DateTimeFilter<"GovernanceProposal"> | Date | string
    updatedAt?: DateTimeFilter<"GovernanceProposal"> | Date | string
    community?: XOR<CommunityScalarRelationFilter, CommunityWhereInput>
    options?: ProposalOptionListRelationFilter
  }, "id">

  export type GovernanceProposalOrderByWithAggregationInput = {
    id?: SortOrder
    communityId?: SortOrder
    proposerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    quorumRequired?: SortOrder
    totalVotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GovernanceProposalCountOrderByAggregateInput
    _avg?: GovernanceProposalAvgOrderByAggregateInput
    _max?: GovernanceProposalMaxOrderByAggregateInput
    _min?: GovernanceProposalMinOrderByAggregateInput
    _sum?: GovernanceProposalSumOrderByAggregateInput
  }

  export type GovernanceProposalScalarWhereWithAggregatesInput = {
    AND?: GovernanceProposalScalarWhereWithAggregatesInput | GovernanceProposalScalarWhereWithAggregatesInput[]
    OR?: GovernanceProposalScalarWhereWithAggregatesInput[]
    NOT?: GovernanceProposalScalarWhereWithAggregatesInput | GovernanceProposalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GovernanceProposal"> | string
    communityId?: StringWithAggregatesFilter<"GovernanceProposal"> | string
    proposerId?: StringWithAggregatesFilter<"GovernanceProposal"> | string
    title?: StringWithAggregatesFilter<"GovernanceProposal"> | string
    description?: StringWithAggregatesFilter<"GovernanceProposal"> | string
    type?: StringWithAggregatesFilter<"GovernanceProposal"> | string
    status?: StringWithAggregatesFilter<"GovernanceProposal"> | string
    startDate?: DateTimeWithAggregatesFilter<"GovernanceProposal"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"GovernanceProposal"> | Date | string
    quorumRequired?: IntWithAggregatesFilter<"GovernanceProposal"> | number
    totalVotes?: IntWithAggregatesFilter<"GovernanceProposal"> | number
    createdAt?: DateTimeWithAggregatesFilter<"GovernanceProposal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GovernanceProposal"> | Date | string
  }

  export type ProposalOptionWhereInput = {
    AND?: ProposalOptionWhereInput | ProposalOptionWhereInput[]
    OR?: ProposalOptionWhereInput[]
    NOT?: ProposalOptionWhereInput | ProposalOptionWhereInput[]
    id?: StringFilter<"ProposalOption"> | string
    proposalId?: StringFilter<"ProposalOption"> | string
    text?: StringFilter<"ProposalOption"> | string
    votes?: IntFilter<"ProposalOption"> | number
    proposal?: XOR<GovernanceProposalScalarRelationFilter, GovernanceProposalWhereInput>
  }

  export type ProposalOptionOrderByWithRelationInput = {
    id?: SortOrder
    proposalId?: SortOrder
    text?: SortOrder
    votes?: SortOrder
    proposal?: GovernanceProposalOrderByWithRelationInput
  }

  export type ProposalOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProposalOptionWhereInput | ProposalOptionWhereInput[]
    OR?: ProposalOptionWhereInput[]
    NOT?: ProposalOptionWhereInput | ProposalOptionWhereInput[]
    proposalId?: StringFilter<"ProposalOption"> | string
    text?: StringFilter<"ProposalOption"> | string
    votes?: IntFilter<"ProposalOption"> | number
    proposal?: XOR<GovernanceProposalScalarRelationFilter, GovernanceProposalWhereInput>
  }, "id">

  export type ProposalOptionOrderByWithAggregationInput = {
    id?: SortOrder
    proposalId?: SortOrder
    text?: SortOrder
    votes?: SortOrder
    _count?: ProposalOptionCountOrderByAggregateInput
    _avg?: ProposalOptionAvgOrderByAggregateInput
    _max?: ProposalOptionMaxOrderByAggregateInput
    _min?: ProposalOptionMinOrderByAggregateInput
    _sum?: ProposalOptionSumOrderByAggregateInput
  }

  export type ProposalOptionScalarWhereWithAggregatesInput = {
    AND?: ProposalOptionScalarWhereWithAggregatesInput | ProposalOptionScalarWhereWithAggregatesInput[]
    OR?: ProposalOptionScalarWhereWithAggregatesInput[]
    NOT?: ProposalOptionScalarWhereWithAggregatesInput | ProposalOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProposalOption"> | string
    proposalId?: StringWithAggregatesFilter<"ProposalOption"> | string
    text?: StringWithAggregatesFilter<"ProposalOption"> | string
    votes?: IntWithAggregatesFilter<"ProposalOption"> | number
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    upvotes?: IntFilter<"Comment"> | number
    downvotes?: IntFilter<"Comment"> | number
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    post?: XOR<CommunityPostScalarRelationFilter, CommunityPostWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    parent?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    children?: CommentListRelationFilter
    votes?: CommentVoteListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    post?: CommunityPostOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    parent?: CommentOrderByWithRelationInput
    children?: CommentOrderByRelationAggregateInput
    votes?: CommentVoteOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    content?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    upvotes?: IntFilter<"Comment"> | number
    downvotes?: IntFilter<"Comment"> | number
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    post?: XOR<CommunityPostScalarRelationFilter, CommunityPostWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    parent?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    children?: CommentListRelationFilter
    votes?: CommentVoteListRelationFilter
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrderInput | SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    content?: StringWithAggregatesFilter<"Comment"> | string
    postId?: StringWithAggregatesFilter<"Comment"> | string
    authorId?: StringWithAggregatesFilter<"Comment"> | string
    parentId?: StringNullableWithAggregatesFilter<"Comment"> | string | null
    upvotes?: IntWithAggregatesFilter<"Comment"> | number
    downvotes?: IntWithAggregatesFilter<"Comment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type CommentVoteWhereInput = {
    AND?: CommentVoteWhereInput | CommentVoteWhereInput[]
    OR?: CommentVoteWhereInput[]
    NOT?: CommentVoteWhereInput | CommentVoteWhereInput[]
    id?: StringFilter<"CommentVote"> | string
    commentId?: StringFilter<"CommentVote"> | string
    userId?: StringFilter<"CommentVote"> | string
    type?: StringFilter<"CommentVote"> | string
    createdAt?: DateTimeFilter<"CommentVote"> | Date | string
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CommentVoteOrderByWithRelationInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    comment?: CommentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CommentVoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    commentId_userId?: CommentVoteCommentIdUserIdCompoundUniqueInput
    AND?: CommentVoteWhereInput | CommentVoteWhereInput[]
    OR?: CommentVoteWhereInput[]
    NOT?: CommentVoteWhereInput | CommentVoteWhereInput[]
    commentId?: StringFilter<"CommentVote"> | string
    userId?: StringFilter<"CommentVote"> | string
    type?: StringFilter<"CommentVote"> | string
    createdAt?: DateTimeFilter<"CommentVote"> | Date | string
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "commentId_userId">

  export type CommentVoteOrderByWithAggregationInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: CommentVoteCountOrderByAggregateInput
    _max?: CommentVoteMaxOrderByAggregateInput
    _min?: CommentVoteMinOrderByAggregateInput
  }

  export type CommentVoteScalarWhereWithAggregatesInput = {
    AND?: CommentVoteScalarWhereWithAggregatesInput | CommentVoteScalarWhereWithAggregatesInput[]
    OR?: CommentVoteScalarWhereWithAggregatesInput[]
    NOT?: CommentVoteScalarWhereWithAggregatesInput | CommentVoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CommentVote"> | string
    commentId?: StringWithAggregatesFilter<"CommentVote"> | string
    userId?: StringWithAggregatesFilter<"CommentVote"> | string
    type?: StringWithAggregatesFilter<"CommentVote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CommentVote"> | Date | string
  }

  export type QuizWhereInput = {
    AND?: QuizWhereInput | QuizWhereInput[]
    OR?: QuizWhereInput[]
    NOT?: QuizWhereInput | QuizWhereInput[]
    id?: StringFilter<"Quiz"> | string
    eventId?: StringNullableFilter<"Quiz"> | string | null
    artistId?: StringFilter<"Quiz"> | string
    artistName?: StringFilter<"Quiz"> | string
    type?: StringFilter<"Quiz"> | string
    status?: StringFilter<"Quiz"> | string
    duration?: IntFilter<"Quiz"> | number
    questionCount?: IntFilter<"Quiz"> | number
    startTime?: DateTimeNullableFilter<"Quiz"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Quiz"> | Date | string | null
    createdAt?: DateTimeFilter<"Quiz"> | Date | string
    updatedAt?: DateTimeFilter<"Quiz"> | Date | string
    questions?: QuizQuestionListRelationFilter
    attempts?: QuizAttemptListRelationFilter
  }

  export type QuizOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrderInput | SortOrder
    artistId?: SortOrder
    artistName?: SortOrder
    type?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    questionCount?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    questions?: QuizQuestionOrderByRelationAggregateInput
    attempts?: QuizAttemptOrderByRelationAggregateInput
  }

  export type QuizWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuizWhereInput | QuizWhereInput[]
    OR?: QuizWhereInput[]
    NOT?: QuizWhereInput | QuizWhereInput[]
    eventId?: StringNullableFilter<"Quiz"> | string | null
    artistId?: StringFilter<"Quiz"> | string
    artistName?: StringFilter<"Quiz"> | string
    type?: StringFilter<"Quiz"> | string
    status?: StringFilter<"Quiz"> | string
    duration?: IntFilter<"Quiz"> | number
    questionCount?: IntFilter<"Quiz"> | number
    startTime?: DateTimeNullableFilter<"Quiz"> | Date | string | null
    endTime?: DateTimeNullableFilter<"Quiz"> | Date | string | null
    createdAt?: DateTimeFilter<"Quiz"> | Date | string
    updatedAt?: DateTimeFilter<"Quiz"> | Date | string
    questions?: QuizQuestionListRelationFilter
    attempts?: QuizAttemptListRelationFilter
  }, "id">

  export type QuizOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrderInput | SortOrder
    artistId?: SortOrder
    artistName?: SortOrder
    type?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    questionCount?: SortOrder
    startTime?: SortOrderInput | SortOrder
    endTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuizCountOrderByAggregateInput
    _avg?: QuizAvgOrderByAggregateInput
    _max?: QuizMaxOrderByAggregateInput
    _min?: QuizMinOrderByAggregateInput
    _sum?: QuizSumOrderByAggregateInput
  }

  export type QuizScalarWhereWithAggregatesInput = {
    AND?: QuizScalarWhereWithAggregatesInput | QuizScalarWhereWithAggregatesInput[]
    OR?: QuizScalarWhereWithAggregatesInput[]
    NOT?: QuizScalarWhereWithAggregatesInput | QuizScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Quiz"> | string
    eventId?: StringNullableWithAggregatesFilter<"Quiz"> | string | null
    artistId?: StringWithAggregatesFilter<"Quiz"> | string
    artistName?: StringWithAggregatesFilter<"Quiz"> | string
    type?: StringWithAggregatesFilter<"Quiz"> | string
    status?: StringWithAggregatesFilter<"Quiz"> | string
    duration?: IntWithAggregatesFilter<"Quiz"> | number
    questionCount?: IntWithAggregatesFilter<"Quiz"> | number
    startTime?: DateTimeNullableWithAggregatesFilter<"Quiz"> | Date | string | null
    endTime?: DateTimeNullableWithAggregatesFilter<"Quiz"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Quiz"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Quiz"> | Date | string
  }

  export type QuizQuestionWhereInput = {
    AND?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    OR?: QuizQuestionWhereInput[]
    NOT?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    id?: StringFilter<"QuizQuestion"> | string
    quizId?: StringFilter<"QuizQuestion"> | string
    question?: StringFilter<"QuizQuestion"> | string
    type?: StringFilter<"QuizQuestion"> | string
    options?: StringNullableListFilter<"QuizQuestion">
    correctAnswer?: StringFilter<"QuizQuestion"> | string
    imageUrl?: StringNullableFilter<"QuizQuestion"> | string | null
    timeLimit?: IntFilter<"QuizQuestion"> | number
    difficulty?: StringFilter<"QuizQuestion"> | string
    orderIndex?: IntFilter<"QuizQuestion"> | number
    createdAt?: DateTimeFilter<"QuizQuestion"> | Date | string
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
  }

  export type QuizQuestionOrderByWithRelationInput = {
    id?: SortOrder
    quizId?: SortOrder
    question?: SortOrder
    type?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    timeLimit?: SortOrder
    difficulty?: SortOrder
    orderIndex?: SortOrder
    createdAt?: SortOrder
    quiz?: QuizOrderByWithRelationInput
  }

  export type QuizQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    OR?: QuizQuestionWhereInput[]
    NOT?: QuizQuestionWhereInput | QuizQuestionWhereInput[]
    quizId?: StringFilter<"QuizQuestion"> | string
    question?: StringFilter<"QuizQuestion"> | string
    type?: StringFilter<"QuizQuestion"> | string
    options?: StringNullableListFilter<"QuizQuestion">
    correctAnswer?: StringFilter<"QuizQuestion"> | string
    imageUrl?: StringNullableFilter<"QuizQuestion"> | string | null
    timeLimit?: IntFilter<"QuizQuestion"> | number
    difficulty?: StringFilter<"QuizQuestion"> | string
    orderIndex?: IntFilter<"QuizQuestion"> | number
    createdAt?: DateTimeFilter<"QuizQuestion"> | Date | string
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
  }, "id">

  export type QuizQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    quizId?: SortOrder
    question?: SortOrder
    type?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
    imageUrl?: SortOrderInput | SortOrder
    timeLimit?: SortOrder
    difficulty?: SortOrder
    orderIndex?: SortOrder
    createdAt?: SortOrder
    _count?: QuizQuestionCountOrderByAggregateInput
    _avg?: QuizQuestionAvgOrderByAggregateInput
    _max?: QuizQuestionMaxOrderByAggregateInput
    _min?: QuizQuestionMinOrderByAggregateInput
    _sum?: QuizQuestionSumOrderByAggregateInput
  }

  export type QuizQuestionScalarWhereWithAggregatesInput = {
    AND?: QuizQuestionScalarWhereWithAggregatesInput | QuizQuestionScalarWhereWithAggregatesInput[]
    OR?: QuizQuestionScalarWhereWithAggregatesInput[]
    NOT?: QuizQuestionScalarWhereWithAggregatesInput | QuizQuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuizQuestion"> | string
    quizId?: StringWithAggregatesFilter<"QuizQuestion"> | string
    question?: StringWithAggregatesFilter<"QuizQuestion"> | string
    type?: StringWithAggregatesFilter<"QuizQuestion"> | string
    options?: StringNullableListFilter<"QuizQuestion">
    correctAnswer?: StringWithAggregatesFilter<"QuizQuestion"> | string
    imageUrl?: StringNullableWithAggregatesFilter<"QuizQuestion"> | string | null
    timeLimit?: IntWithAggregatesFilter<"QuizQuestion"> | number
    difficulty?: StringWithAggregatesFilter<"QuizQuestion"> | string
    orderIndex?: IntWithAggregatesFilter<"QuizQuestion"> | number
    createdAt?: DateTimeWithAggregatesFilter<"QuizQuestion"> | Date | string
  }

  export type QuizAttemptWhereInput = {
    AND?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    OR?: QuizAttemptWhereInput[]
    NOT?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    id?: StringFilter<"QuizAttempt"> | string
    quizId?: StringFilter<"QuizAttempt"> | string
    userId?: StringFilter<"QuizAttempt"> | string
    correctAnswers?: IntFilter<"QuizAttempt"> | number
    totalQuestions?: IntFilter<"QuizAttempt"> | number
    avgResponseTime?: FloatFilter<"QuizAttempt"> | number
    responseTimeStdDev?: FloatFilter<"QuizAttempt"> | number
    streak?: IntFilter<"QuizAttempt"> | number
    maxStreak?: IntFilter<"QuizAttempt"> | number
    finalScore?: FloatFilter<"QuizAttempt"> | number
    speedScore?: FloatFilter<"QuizAttempt"> | number
    accuracyScore?: FloatFilter<"QuizAttempt"> | number
    consistencyScore?: FloatFilter<"QuizAttempt"> | number
    rank?: IntNullableFilter<"QuizAttempt"> | number | null
    status?: StringFilter<"QuizAttempt"> | string
    startedAt?: DateTimeFilter<"QuizAttempt"> | Date | string
    completedAt?: DateTimeNullableFilter<"QuizAttempt"> | Date | string | null
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    responses?: QuizResponseListRelationFilter
  }

  export type QuizAttemptOrderByWithRelationInput = {
    id?: SortOrder
    quizId?: SortOrder
    userId?: SortOrder
    correctAnswers?: SortOrder
    totalQuestions?: SortOrder
    avgResponseTime?: SortOrder
    responseTimeStdDev?: SortOrder
    streak?: SortOrder
    maxStreak?: SortOrder
    finalScore?: SortOrder
    speedScore?: SortOrder
    accuracyScore?: SortOrder
    consistencyScore?: SortOrder
    rank?: SortOrderInput | SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    quiz?: QuizOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    responses?: QuizResponseOrderByRelationAggregateInput
  }

  export type QuizAttemptWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    OR?: QuizAttemptWhereInput[]
    NOT?: QuizAttemptWhereInput | QuizAttemptWhereInput[]
    quizId?: StringFilter<"QuizAttempt"> | string
    userId?: StringFilter<"QuizAttempt"> | string
    correctAnswers?: IntFilter<"QuizAttempt"> | number
    totalQuestions?: IntFilter<"QuizAttempt"> | number
    avgResponseTime?: FloatFilter<"QuizAttempt"> | number
    responseTimeStdDev?: FloatFilter<"QuizAttempt"> | number
    streak?: IntFilter<"QuizAttempt"> | number
    maxStreak?: IntFilter<"QuizAttempt"> | number
    finalScore?: FloatFilter<"QuizAttempt"> | number
    speedScore?: FloatFilter<"QuizAttempt"> | number
    accuracyScore?: FloatFilter<"QuizAttempt"> | number
    consistencyScore?: FloatFilter<"QuizAttempt"> | number
    rank?: IntNullableFilter<"QuizAttempt"> | number | null
    status?: StringFilter<"QuizAttempt"> | string
    startedAt?: DateTimeFilter<"QuizAttempt"> | Date | string
    completedAt?: DateTimeNullableFilter<"QuizAttempt"> | Date | string | null
    quiz?: XOR<QuizScalarRelationFilter, QuizWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    responses?: QuizResponseListRelationFilter
  }, "id">

  export type QuizAttemptOrderByWithAggregationInput = {
    id?: SortOrder
    quizId?: SortOrder
    userId?: SortOrder
    correctAnswers?: SortOrder
    totalQuestions?: SortOrder
    avgResponseTime?: SortOrder
    responseTimeStdDev?: SortOrder
    streak?: SortOrder
    maxStreak?: SortOrder
    finalScore?: SortOrder
    speedScore?: SortOrder
    accuracyScore?: SortOrder
    consistencyScore?: SortOrder
    rank?: SortOrderInput | SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: QuizAttemptCountOrderByAggregateInput
    _avg?: QuizAttemptAvgOrderByAggregateInput
    _max?: QuizAttemptMaxOrderByAggregateInput
    _min?: QuizAttemptMinOrderByAggregateInput
    _sum?: QuizAttemptSumOrderByAggregateInput
  }

  export type QuizAttemptScalarWhereWithAggregatesInput = {
    AND?: QuizAttemptScalarWhereWithAggregatesInput | QuizAttemptScalarWhereWithAggregatesInput[]
    OR?: QuizAttemptScalarWhereWithAggregatesInput[]
    NOT?: QuizAttemptScalarWhereWithAggregatesInput | QuizAttemptScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuizAttempt"> | string
    quizId?: StringWithAggregatesFilter<"QuizAttempt"> | string
    userId?: StringWithAggregatesFilter<"QuizAttempt"> | string
    correctAnswers?: IntWithAggregatesFilter<"QuizAttempt"> | number
    totalQuestions?: IntWithAggregatesFilter<"QuizAttempt"> | number
    avgResponseTime?: FloatWithAggregatesFilter<"QuizAttempt"> | number
    responseTimeStdDev?: FloatWithAggregatesFilter<"QuizAttempt"> | number
    streak?: IntWithAggregatesFilter<"QuizAttempt"> | number
    maxStreak?: IntWithAggregatesFilter<"QuizAttempt"> | number
    finalScore?: FloatWithAggregatesFilter<"QuizAttempt"> | number
    speedScore?: FloatWithAggregatesFilter<"QuizAttempt"> | number
    accuracyScore?: FloatWithAggregatesFilter<"QuizAttempt"> | number
    consistencyScore?: FloatWithAggregatesFilter<"QuizAttempt"> | number
    rank?: IntNullableWithAggregatesFilter<"QuizAttempt"> | number | null
    status?: StringWithAggregatesFilter<"QuizAttempt"> | string
    startedAt?: DateTimeWithAggregatesFilter<"QuizAttempt"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"QuizAttempt"> | Date | string | null
  }

  export type QuizResponseWhereInput = {
    AND?: QuizResponseWhereInput | QuizResponseWhereInput[]
    OR?: QuizResponseWhereInput[]
    NOT?: QuizResponseWhereInput | QuizResponseWhereInput[]
    id?: StringFilter<"QuizResponse"> | string
    attemptId?: StringFilter<"QuizResponse"> | string
    questionId?: StringFilter<"QuizResponse"> | string
    answer?: StringFilter<"QuizResponse"> | string
    isCorrect?: BoolFilter<"QuizResponse"> | boolean
    responseTime?: IntFilter<"QuizResponse"> | number
    answeredAt?: DateTimeFilter<"QuizResponse"> | Date | string
    attempt?: XOR<QuizAttemptScalarRelationFilter, QuizAttemptWhereInput>
  }

  export type QuizResponseOrderByWithRelationInput = {
    id?: SortOrder
    attemptId?: SortOrder
    questionId?: SortOrder
    answer?: SortOrder
    isCorrect?: SortOrder
    responseTime?: SortOrder
    answeredAt?: SortOrder
    attempt?: QuizAttemptOrderByWithRelationInput
  }

  export type QuizResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuizResponseWhereInput | QuizResponseWhereInput[]
    OR?: QuizResponseWhereInput[]
    NOT?: QuizResponseWhereInput | QuizResponseWhereInput[]
    attemptId?: StringFilter<"QuizResponse"> | string
    questionId?: StringFilter<"QuizResponse"> | string
    answer?: StringFilter<"QuizResponse"> | string
    isCorrect?: BoolFilter<"QuizResponse"> | boolean
    responseTime?: IntFilter<"QuizResponse"> | number
    answeredAt?: DateTimeFilter<"QuizResponse"> | Date | string
    attempt?: XOR<QuizAttemptScalarRelationFilter, QuizAttemptWhereInput>
  }, "id">

  export type QuizResponseOrderByWithAggregationInput = {
    id?: SortOrder
    attemptId?: SortOrder
    questionId?: SortOrder
    answer?: SortOrder
    isCorrect?: SortOrder
    responseTime?: SortOrder
    answeredAt?: SortOrder
    _count?: QuizResponseCountOrderByAggregateInput
    _avg?: QuizResponseAvgOrderByAggregateInput
    _max?: QuizResponseMaxOrderByAggregateInput
    _min?: QuizResponseMinOrderByAggregateInput
    _sum?: QuizResponseSumOrderByAggregateInput
  }

  export type QuizResponseScalarWhereWithAggregatesInput = {
    AND?: QuizResponseScalarWhereWithAggregatesInput | QuizResponseScalarWhereWithAggregatesInput[]
    OR?: QuizResponseScalarWhereWithAggregatesInput[]
    NOT?: QuizResponseScalarWhereWithAggregatesInput | QuizResponseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuizResponse"> | string
    attemptId?: StringWithAggregatesFilter<"QuizResponse"> | string
    questionId?: StringWithAggregatesFilter<"QuizResponse"> | string
    answer?: StringWithAggregatesFilter<"QuizResponse"> | string
    isCorrect?: BoolWithAggregatesFilter<"QuizResponse"> | boolean
    responseTime?: IntWithAggregatesFilter<"QuizResponse"> | number
    answeredAt?: DateTimeWithAggregatesFilter<"QuizResponse"> | Date | string
  }

  export type FanIQBadgeWhereInput = {
    AND?: FanIQBadgeWhereInput | FanIQBadgeWhereInput[]
    OR?: FanIQBadgeWhereInput[]
    NOT?: FanIQBadgeWhereInput | FanIQBadgeWhereInput[]
    id?: StringFilter<"FanIQBadge"> | string
    userId?: StringFilter<"FanIQBadge"> | string
    tier?: StringFilter<"FanIQBadge"> | string
    artistId?: StringFilter<"FanIQBadge"> | string
    artistName?: StringFilter<"FanIQBadge"> | string
    tokenId?: StringNullableFilter<"FanIQBadge"> | string | null
    txHash?: StringNullableFilter<"FanIQBadge"> | string | null
    earnedAt?: DateTimeFilter<"FanIQBadge"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FanIQBadgeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tier?: SortOrder
    artistId?: SortOrder
    artistName?: SortOrder
    tokenId?: SortOrderInput | SortOrder
    txHash?: SortOrderInput | SortOrder
    earnedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type FanIQBadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_artistId_tier?: FanIQBadgeUserIdArtistIdTierCompoundUniqueInput
    AND?: FanIQBadgeWhereInput | FanIQBadgeWhereInput[]
    OR?: FanIQBadgeWhereInput[]
    NOT?: FanIQBadgeWhereInput | FanIQBadgeWhereInput[]
    userId?: StringFilter<"FanIQBadge"> | string
    tier?: StringFilter<"FanIQBadge"> | string
    artistId?: StringFilter<"FanIQBadge"> | string
    artistName?: StringFilter<"FanIQBadge"> | string
    tokenId?: StringNullableFilter<"FanIQBadge"> | string | null
    txHash?: StringNullableFilter<"FanIQBadge"> | string | null
    earnedAt?: DateTimeFilter<"FanIQBadge"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_artistId_tier">

  export type FanIQBadgeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tier?: SortOrder
    artistId?: SortOrder
    artistName?: SortOrder
    tokenId?: SortOrderInput | SortOrder
    txHash?: SortOrderInput | SortOrder
    earnedAt?: SortOrder
    _count?: FanIQBadgeCountOrderByAggregateInput
    _max?: FanIQBadgeMaxOrderByAggregateInput
    _min?: FanIQBadgeMinOrderByAggregateInput
  }

  export type FanIQBadgeScalarWhereWithAggregatesInput = {
    AND?: FanIQBadgeScalarWhereWithAggregatesInput | FanIQBadgeScalarWhereWithAggregatesInput[]
    OR?: FanIQBadgeScalarWhereWithAggregatesInput[]
    NOT?: FanIQBadgeScalarWhereWithAggregatesInput | FanIQBadgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FanIQBadge"> | string
    userId?: StringWithAggregatesFilter<"FanIQBadge"> | string
    tier?: StringWithAggregatesFilter<"FanIQBadge"> | string
    artistId?: StringWithAggregatesFilter<"FanIQBadge"> | string
    artistName?: StringWithAggregatesFilter<"FanIQBadge"> | string
    tokenId?: StringNullableWithAggregatesFilter<"FanIQBadge"> | string | null
    txHash?: StringNullableWithAggregatesFilter<"FanIQBadge"> | string | null
    earnedAt?: DateTimeWithAggregatesFilter<"FanIQBadge"> | Date | string
  }

  export type QuizUserStatsWhereInput = {
    AND?: QuizUserStatsWhereInput | QuizUserStatsWhereInput[]
    OR?: QuizUserStatsWhereInput[]
    NOT?: QuizUserStatsWhereInput | QuizUserStatsWhereInput[]
    id?: StringFilter<"QuizUserStats"> | string
    visitorId?: StringFilter<"QuizUserStats"> | string
    artistName?: StringFilter<"QuizUserStats"> | string
    attemptCount?: IntFilter<"QuizUserStats"> | number
    totalScore?: FloatFilter<"QuizUserStats"> | number
    averageScore?: FloatFilter<"QuizUserStats"> | number
    bestScore?: FloatFilter<"QuizUserStats"> | number
    bestAccuracy?: FloatFilter<"QuizUserStats"> | number
    bestSpeed?: FloatFilter<"QuizUserStats"> | number
    lastScore?: FloatFilter<"QuizUserStats"> | number
    lastPlayedAt?: DateTimeFilter<"QuizUserStats"> | Date | string
    createdAt?: DateTimeFilter<"QuizUserStats"> | Date | string
    updatedAt?: DateTimeFilter<"QuizUserStats"> | Date | string
  }

  export type QuizUserStatsOrderByWithRelationInput = {
    id?: SortOrder
    visitorId?: SortOrder
    artistName?: SortOrder
    attemptCount?: SortOrder
    totalScore?: SortOrder
    averageScore?: SortOrder
    bestScore?: SortOrder
    bestAccuracy?: SortOrder
    bestSpeed?: SortOrder
    lastScore?: SortOrder
    lastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizUserStatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    visitorId_artistName?: QuizUserStatsVisitorIdArtistNameCompoundUniqueInput
    AND?: QuizUserStatsWhereInput | QuizUserStatsWhereInput[]
    OR?: QuizUserStatsWhereInput[]
    NOT?: QuizUserStatsWhereInput | QuizUserStatsWhereInput[]
    visitorId?: StringFilter<"QuizUserStats"> | string
    artistName?: StringFilter<"QuizUserStats"> | string
    attemptCount?: IntFilter<"QuizUserStats"> | number
    totalScore?: FloatFilter<"QuizUserStats"> | number
    averageScore?: FloatFilter<"QuizUserStats"> | number
    bestScore?: FloatFilter<"QuizUserStats"> | number
    bestAccuracy?: FloatFilter<"QuizUserStats"> | number
    bestSpeed?: FloatFilter<"QuizUserStats"> | number
    lastScore?: FloatFilter<"QuizUserStats"> | number
    lastPlayedAt?: DateTimeFilter<"QuizUserStats"> | Date | string
    createdAt?: DateTimeFilter<"QuizUserStats"> | Date | string
    updatedAt?: DateTimeFilter<"QuizUserStats"> | Date | string
  }, "id" | "visitorId_artistName">

  export type QuizUserStatsOrderByWithAggregationInput = {
    id?: SortOrder
    visitorId?: SortOrder
    artistName?: SortOrder
    attemptCount?: SortOrder
    totalScore?: SortOrder
    averageScore?: SortOrder
    bestScore?: SortOrder
    bestAccuracy?: SortOrder
    bestSpeed?: SortOrder
    lastScore?: SortOrder
    lastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuizUserStatsCountOrderByAggregateInput
    _avg?: QuizUserStatsAvgOrderByAggregateInput
    _max?: QuizUserStatsMaxOrderByAggregateInput
    _min?: QuizUserStatsMinOrderByAggregateInput
    _sum?: QuizUserStatsSumOrderByAggregateInput
  }

  export type QuizUserStatsScalarWhereWithAggregatesInput = {
    AND?: QuizUserStatsScalarWhereWithAggregatesInput | QuizUserStatsScalarWhereWithAggregatesInput[]
    OR?: QuizUserStatsScalarWhereWithAggregatesInput[]
    NOT?: QuizUserStatsScalarWhereWithAggregatesInput | QuizUserStatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuizUserStats"> | string
    visitorId?: StringWithAggregatesFilter<"QuizUserStats"> | string
    artistName?: StringWithAggregatesFilter<"QuizUserStats"> | string
    attemptCount?: IntWithAggregatesFilter<"QuizUserStats"> | number
    totalScore?: FloatWithAggregatesFilter<"QuizUserStats"> | number
    averageScore?: FloatWithAggregatesFilter<"QuizUserStats"> | number
    bestScore?: FloatWithAggregatesFilter<"QuizUserStats"> | number
    bestAccuracy?: FloatWithAggregatesFilter<"QuizUserStats"> | number
    bestSpeed?: FloatWithAggregatesFilter<"QuizUserStats"> | number
    lastScore?: FloatWithAggregatesFilter<"QuizUserStats"> | number
    lastPlayedAt?: DateTimeWithAggregatesFilter<"QuizUserStats"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"QuizUserStats"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuizUserStats"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    auth0Id: string
    email: string
    name: string
    avatar?: string | null
    fandomScore?: number
    walletAddress?: string | null
    solanaWalletAddress?: string | null
    spotifyConnected?: boolean
    eventsAttended?: number
    vouchesGiven?: number
    vouchesReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketCreateNestedManyWithoutOwnerInput
    posts?: CommunityPostCreateNestedManyWithoutAuthorInput
    memberships?: CommunityMemberCreateNestedManyWithoutUserInput
    postVotes?: PostVoteCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentVotes?: CommentVoteCreateNestedManyWithoutUserInput
    reminders?: EventReminderCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    fanIQBadges?: FanIQBadgeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    auth0Id: string
    email: string
    name: string
    avatar?: string | null
    fandomScore?: number
    walletAddress?: string | null
    solanaWalletAddress?: string | null
    spotifyConnected?: boolean
    eventsAttended?: number
    vouchesGiven?: number
    vouchesReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutOwnerInput
    posts?: CommunityPostUncheckedCreateNestedManyWithoutAuthorInput
    memberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    postVotes?: PostVoteUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentVotes?: CommentVoteUncheckedCreateNestedManyWithoutUserInput
    reminders?: EventReminderUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    fanIQBadges?: FanIQBadgeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    fandomScore?: IntFieldUpdateOperationsInput | number
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    solanaWalletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyConnected?: BoolFieldUpdateOperationsInput | boolean
    eventsAttended?: IntFieldUpdateOperationsInput | number
    vouchesGiven?: IntFieldUpdateOperationsInput | number
    vouchesReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutOwnerNestedInput
    posts?: CommunityPostUpdateManyWithoutAuthorNestedInput
    memberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    postVotes?: PostVoteUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentVotes?: CommentVoteUpdateManyWithoutUserNestedInput
    reminders?: EventReminderUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    fanIQBadges?: FanIQBadgeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    fandomScore?: IntFieldUpdateOperationsInput | number
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    solanaWalletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyConnected?: BoolFieldUpdateOperationsInput | boolean
    eventsAttended?: IntFieldUpdateOperationsInput | number
    vouchesGiven?: IntFieldUpdateOperationsInput | number
    vouchesReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutOwnerNestedInput
    posts?: CommunityPostUncheckedUpdateManyWithoutAuthorNestedInput
    memberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    postVotes?: PostVoteUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentVotes?: CommentVoteUncheckedUpdateManyWithoutUserNestedInput
    reminders?: EventReminderUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    fanIQBadges?: FanIQBadgeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    auth0Id: string
    email: string
    name: string
    avatar?: string | null
    fandomScore?: number
    walletAddress?: string | null
    solanaWalletAddress?: string | null
    spotifyConnected?: boolean
    eventsAttended?: number
    vouchesGiven?: number
    vouchesReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    fandomScore?: IntFieldUpdateOperationsInput | number
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    solanaWalletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyConnected?: BoolFieldUpdateOperationsInput | boolean
    eventsAttended?: IntFieldUpdateOperationsInput | number
    vouchesGiven?: IntFieldUpdateOperationsInput | number
    vouchesReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    fandomScore?: IntFieldUpdateOperationsInput | number
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    solanaWalletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyConnected?: BoolFieldUpdateOperationsInput | boolean
    eventsAttended?: IntFieldUpdateOperationsInput | number
    vouchesGiven?: IntFieldUpdateOperationsInput | number
    vouchesReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    id?: string
    title: string
    artist: string
    artistImage: string
    venue: string
    location: string
    date: Date | string
    time: string
    image: string
    description: string
    category: string
    status?: string
    totalTickets: number
    soldTickets?: number
    resaleEnabled?: boolean
    resaleCap?: number | null
    artistRoyalty?: number
    minFandomScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ticketTiers?: TicketTierCreateNestedManyWithoutEventInput
    tickets?: TicketCreateNestedManyWithoutEventInput
    reminders?: EventReminderCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    title: string
    artist: string
    artistImage: string
    venue: string
    location: string
    date: Date | string
    time: string
    image: string
    description: string
    category: string
    status?: string
    totalTickets: number
    soldTickets?: number
    resaleEnabled?: boolean
    resaleCap?: number | null
    artistRoyalty?: number
    minFandomScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ticketTiers?: TicketTierUncheckedCreateNestedManyWithoutEventInput
    tickets?: TicketUncheckedCreateNestedManyWithoutEventInput
    reminders?: EventReminderUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    artistImage?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalTickets?: IntFieldUpdateOperationsInput | number
    soldTickets?: IntFieldUpdateOperationsInput | number
    resaleEnabled?: BoolFieldUpdateOperationsInput | boolean
    resaleCap?: NullableIntFieldUpdateOperationsInput | number | null
    artistRoyalty?: IntFieldUpdateOperationsInput | number
    minFandomScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketTiers?: TicketTierUpdateManyWithoutEventNestedInput
    tickets?: TicketUpdateManyWithoutEventNestedInput
    reminders?: EventReminderUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    artistImage?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalTickets?: IntFieldUpdateOperationsInput | number
    soldTickets?: IntFieldUpdateOperationsInput | number
    resaleEnabled?: BoolFieldUpdateOperationsInput | boolean
    resaleCap?: NullableIntFieldUpdateOperationsInput | number | null
    artistRoyalty?: IntFieldUpdateOperationsInput | number
    minFandomScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketTiers?: TicketTierUncheckedUpdateManyWithoutEventNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutEventNestedInput
    reminders?: EventReminderUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateManyInput = {
    id?: string
    title: string
    artist: string
    artistImage: string
    venue: string
    location: string
    date: Date | string
    time: string
    image: string
    description: string
    category: string
    status?: string
    totalTickets: number
    soldTickets?: number
    resaleEnabled?: boolean
    resaleCap?: number | null
    artistRoyalty?: number
    minFandomScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    artistImage?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalTickets?: IntFieldUpdateOperationsInput | number
    soldTickets?: IntFieldUpdateOperationsInput | number
    resaleEnabled?: BoolFieldUpdateOperationsInput | boolean
    resaleCap?: NullableIntFieldUpdateOperationsInput | number | null
    artistRoyalty?: IntFieldUpdateOperationsInput | number
    minFandomScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    artistImage?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalTickets?: IntFieldUpdateOperationsInput | number
    soldTickets?: IntFieldUpdateOperationsInput | number
    resaleEnabled?: BoolFieldUpdateOperationsInput | boolean
    resaleCap?: NullableIntFieldUpdateOperationsInput | number | null
    artistRoyalty?: IntFieldUpdateOperationsInput | number
    minFandomScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventReminderCreateInput = {
    id?: string
    createdAt?: Date | string
    event: EventCreateNestedOneWithoutRemindersInput
    user: UserCreateNestedOneWithoutRemindersInput
  }

  export type EventReminderUncheckedCreateInput = {
    id?: string
    eventId: string
    userId: string
    createdAt?: Date | string
  }

  export type EventReminderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutRemindersNestedInput
    user?: UserUpdateOneRequiredWithoutRemindersNestedInput
  }

  export type EventReminderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventReminderCreateManyInput = {
    id?: string
    eventId: string
    userId: string
    createdAt?: Date | string
  }

  export type EventReminderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventReminderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketTierCreateInput = {
    id?: string
    name: string
    price: number
    currency?: string
    description: string
    available: number
    total: number
    benefits?: TicketTierCreatebenefitsInput | string[]
    event: EventCreateNestedOneWithoutTicketTiersInput
    tickets?: TicketCreateNestedManyWithoutTierInput
  }

  export type TicketTierUncheckedCreateInput = {
    id?: string
    eventId: string
    name: string
    price: number
    currency?: string
    description: string
    available: number
    total: number
    benefits?: TicketTierCreatebenefitsInput | string[]
    tickets?: TicketUncheckedCreateNestedManyWithoutTierInput
  }

  export type TicketTierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    available?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    benefits?: TicketTierUpdatebenefitsInput | string[]
    event?: EventUpdateOneRequiredWithoutTicketTiersNestedInput
    tickets?: TicketUpdateManyWithoutTierNestedInput
  }

  export type TicketTierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    available?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    benefits?: TicketTierUpdatebenefitsInput | string[]
    tickets?: TicketUncheckedUpdateManyWithoutTierNestedInput
  }

  export type TicketTierCreateManyInput = {
    id?: string
    eventId: string
    name: string
    price: number
    currency?: string
    description: string
    available: number
    total: number
    benefits?: TicketTierCreatebenefitsInput | string[]
  }

  export type TicketTierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    available?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    benefits?: TicketTierUpdatebenefitsInput | string[]
  }

  export type TicketTierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    available?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    benefits?: TicketTierUpdatebenefitsInput | string[]
  }

  export type TicketCreateInput = {
    id?: string
    originalPrice: number
    currentPrice: number
    purchaseDate?: Date | string
    status?: string
    qrCode?: string | null
    tokenId?: string | null
    txHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutTicketsInput
    tier: TicketTierCreateNestedOneWithoutTicketsInput
    owner: UserCreateNestedOneWithoutTicketsInput
  }

  export type TicketUncheckedCreateInput = {
    id?: string
    eventId: string
    tierId: string
    ownerId: string
    originalPrice: number
    currentPrice: number
    purchaseDate?: Date | string
    status?: string
    qrCode?: string | null
    tokenId?: string | null
    txHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutTicketsNestedInput
    tier?: TicketTierUpdateOneRequiredWithoutTicketsNestedInput
    owner?: UserUpdateOneRequiredWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    tierId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    originalPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCreateManyInput = {
    id?: string
    eventId: string
    tierId: string
    ownerId: string
    originalPrice: number
    currentPrice: number
    purchaseDate?: Date | string
    status?: string
    qrCode?: string | null
    tokenId?: string | null
    txHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    tierId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    originalPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityCreateInput = {
    id?: string
    name: string
    artistId: string
    artistName: string
    artistImage: string
    description: string
    memberCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: CommunityPostCreateNestedManyWithoutCommunityInput
    members?: CommunityMemberCreateNestedManyWithoutCommunityInput
    proposals?: GovernanceProposalCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateInput = {
    id?: string
    name: string
    artistId: string
    artistName: string
    artistImage: string
    description: string
    memberCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: CommunityPostUncheckedCreateNestedManyWithoutCommunityInput
    members?: CommunityMemberUncheckedCreateNestedManyWithoutCommunityInput
    proposals?: GovernanceProposalUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    artistImage?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    memberCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: CommunityPostUpdateManyWithoutCommunityNestedInput
    members?: CommunityMemberUpdateManyWithoutCommunityNestedInput
    proposals?: GovernanceProposalUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    artistImage?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    memberCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: CommunityPostUncheckedUpdateManyWithoutCommunityNestedInput
    members?: CommunityMemberUncheckedUpdateManyWithoutCommunityNestedInput
    proposals?: GovernanceProposalUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityCreateManyInput = {
    id?: string
    name: string
    artistId: string
    artistName: string
    artistImage: string
    description: string
    memberCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    artistImage?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    memberCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    artistImage?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    memberCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityPostCreateInput = {
    id?: string
    title: string
    content: string
    type?: string
    images?: CommunityPostCreateimagesInput | string[]
    upvotes?: number
    downvotes?: number
    commentCount?: number
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    community: CommunityCreateNestedOneWithoutPostsInput
    author: UserCreateNestedOneWithoutPostsInput
    votes?: PostVoteCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
  }

  export type CommunityPostUncheckedCreateInput = {
    id?: string
    communityId: string
    authorId: string
    title: string
    content: string
    type?: string
    images?: CommunityPostCreateimagesInput | string[]
    upvotes?: number
    downvotes?: number
    commentCount?: number
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: PostVoteUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type CommunityPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    images?: CommunityPostUpdateimagesInput | string[]
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    community?: CommunityUpdateOneRequiredWithoutPostsNestedInput
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
    votes?: PostVoteUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
  }

  export type CommunityPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    communityId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    images?: CommunityPostUpdateimagesInput | string[]
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: PostVoteUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type CommunityPostCreateManyInput = {
    id?: string
    communityId: string
    authorId: string
    title: string
    content: string
    type?: string
    images?: CommunityPostCreateimagesInput | string[]
    upvotes?: number
    downvotes?: number
    commentCount?: number
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    images?: CommunityPostUpdateimagesInput | string[]
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    communityId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    images?: CommunityPostUpdateimagesInput | string[]
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostVoteCreateInput = {
    id?: string
    type: string
    createdAt?: Date | string
    post: CommunityPostCreateNestedOneWithoutVotesInput
    user: UserCreateNestedOneWithoutPostVotesInput
  }

  export type PostVoteUncheckedCreateInput = {
    id?: string
    postId: string
    userId: string
    type: string
    createdAt?: Date | string
  }

  export type PostVoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: CommunityPostUpdateOneRequiredWithoutVotesNestedInput
    user?: UserUpdateOneRequiredWithoutPostVotesNestedInput
  }

  export type PostVoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostVoteCreateManyInput = {
    id?: string
    postId: string
    userId: string
    type: string
    createdAt?: Date | string
  }

  export type PostVoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostVoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityMemberCreateInput = {
    id?: string
    role?: string
    reputationPoints?: number
    votingPower?: number
    isActive?: boolean
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipsInput
    community: CommunityCreateNestedOneWithoutMembersInput
  }

  export type CommunityMemberUncheckedCreateInput = {
    id?: string
    userId: string
    communityId: string
    role?: string
    reputationPoints?: number
    votingPower?: number
    isActive?: boolean
    joinedAt?: Date | string
  }

  export type CommunityMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    reputationPoints?: IntFieldUpdateOperationsInput | number
    votingPower?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
    community?: CommunityUpdateOneRequiredWithoutMembersNestedInput
  }

  export type CommunityMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    communityId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    reputationPoints?: IntFieldUpdateOperationsInput | number
    votingPower?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityMemberCreateManyInput = {
    id?: string
    userId: string
    communityId: string
    role?: string
    reputationPoints?: number
    votingPower?: number
    isActive?: boolean
    joinedAt?: Date | string
  }

  export type CommunityMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    reputationPoints?: IntFieldUpdateOperationsInput | number
    votingPower?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    communityId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    reputationPoints?: IntFieldUpdateOperationsInput | number
    votingPower?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GovernanceProposalCreateInput = {
    id?: string
    proposerId: string
    title: string
    description: string
    type: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    quorumRequired: number
    totalVotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    community: CommunityCreateNestedOneWithoutProposalsInput
    options?: ProposalOptionCreateNestedManyWithoutProposalInput
  }

  export type GovernanceProposalUncheckedCreateInput = {
    id?: string
    communityId: string
    proposerId: string
    title: string
    description: string
    type: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    quorumRequired: number
    totalVotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: ProposalOptionUncheckedCreateNestedManyWithoutProposalInput
  }

  export type GovernanceProposalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quorumRequired?: IntFieldUpdateOperationsInput | number
    totalVotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    community?: CommunityUpdateOneRequiredWithoutProposalsNestedInput
    options?: ProposalOptionUpdateManyWithoutProposalNestedInput
  }

  export type GovernanceProposalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    communityId?: StringFieldUpdateOperationsInput | string
    proposerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quorumRequired?: IntFieldUpdateOperationsInput | number
    totalVotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: ProposalOptionUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type GovernanceProposalCreateManyInput = {
    id?: string
    communityId: string
    proposerId: string
    title: string
    description: string
    type: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    quorumRequired: number
    totalVotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GovernanceProposalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quorumRequired?: IntFieldUpdateOperationsInput | number
    totalVotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GovernanceProposalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    communityId?: StringFieldUpdateOperationsInput | string
    proposerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quorumRequired?: IntFieldUpdateOperationsInput | number
    totalVotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalOptionCreateInput = {
    id?: string
    text: string
    votes?: number
    proposal: GovernanceProposalCreateNestedOneWithoutOptionsInput
  }

  export type ProposalOptionUncheckedCreateInput = {
    id?: string
    proposalId: string
    text: string
    votes?: number
  }

  export type ProposalOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
    proposal?: GovernanceProposalUpdateOneRequiredWithoutOptionsNestedInput
  }

  export type ProposalOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
  }

  export type ProposalOptionCreateManyInput = {
    id?: string
    proposalId: string
    text: string
    votes?: number
  }

  export type ProposalOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
  }

  export type ProposalOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposalId?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    post: CommunityPostCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutChildrenInput
    children?: CommentCreateNestedManyWithoutParentInput
    votes?: CommentVoteCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    content: string
    postId: string
    authorId: string
    parentId?: string | null
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CommentUncheckedCreateNestedManyWithoutParentInput
    votes?: CommentVoteUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: CommunityPostUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutChildrenNestedInput
    children?: CommentUpdateManyWithoutParentNestedInput
    votes?: CommentVoteUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CommentUncheckedUpdateManyWithoutParentNestedInput
    votes?: CommentVoteUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    content: string
    postId: string
    authorId: string
    parentId?: string | null
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentVoteCreateInput = {
    id?: string
    type: string
    createdAt?: Date | string
    comment: CommentCreateNestedOneWithoutVotesInput
    user: UserCreateNestedOneWithoutCommentVotesInput
  }

  export type CommentVoteUncheckedCreateInput = {
    id?: string
    commentId: string
    userId: string
    type: string
    createdAt?: Date | string
  }

  export type CommentVoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneRequiredWithoutVotesNestedInput
    user?: UserUpdateOneRequiredWithoutCommentVotesNestedInput
  }

  export type CommentVoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentVoteCreateManyInput = {
    id?: string
    commentId: string
    userId: string
    type: string
    createdAt?: Date | string
  }

  export type CommentVoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentVoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizCreateInput = {
    id?: string
    eventId?: string | null
    artistId: string
    artistName: string
    type: string
    status?: string
    duration?: number
    questionCount?: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
    attempts?: QuizAttemptCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateInput = {
    id?: string
    eventId?: string | null
    artistId: string
    artistName: string
    type: string
    status?: string
    duration?: number
    questionCount?: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    artistId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    questionCount?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
    attempts?: QuizAttemptUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    artistId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    questionCount?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
    attempts?: QuizAttemptUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizCreateManyInput = {
    id?: string
    eventId?: string | null
    artistId: string
    artistName: string
    type: string
    status?: string
    duration?: number
    questionCount?: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    artistId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    questionCount?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    artistId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    questionCount?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionCreateInput = {
    id?: string
    question: string
    type: string
    options?: QuizQuestionCreateoptionsInput | string[]
    correctAnswer: string
    imageUrl?: string | null
    timeLimit?: number
    difficulty?: string
    orderIndex: number
    createdAt?: Date | string
    quiz: QuizCreateNestedOneWithoutQuestionsInput
  }

  export type QuizQuestionUncheckedCreateInput = {
    id?: string
    quizId: string
    question: string
    type: string
    options?: QuizQuestionCreateoptionsInput | string[]
    correctAnswer: string
    imageUrl?: string | null
    timeLimit?: number
    difficulty?: string
    orderIndex: number
    createdAt?: Date | string
  }

  export type QuizQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: QuizQuestionUpdateoptionsInput | string[]
    correctAnswer?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    quiz?: QuizUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type QuizQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: QuizQuestionUpdateoptionsInput | string[]
    correctAnswer?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionCreateManyInput = {
    id?: string
    quizId: string
    question: string
    type: string
    options?: QuizQuestionCreateoptionsInput | string[]
    correctAnswer: string
    imageUrl?: string | null
    timeLimit?: number
    difficulty?: string
    orderIndex: number
    createdAt?: Date | string
  }

  export type QuizQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: QuizQuestionUpdateoptionsInput | string[]
    correctAnswer?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: QuizQuestionUpdateoptionsInput | string[]
    correctAnswer?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizAttemptCreateInput = {
    id?: string
    correctAnswers?: number
    totalQuestions: number
    avgResponseTime?: number
    responseTimeStdDev?: number
    streak?: number
    maxStreak?: number
    finalScore?: number
    speedScore?: number
    accuracyScore?: number
    consistencyScore?: number
    rank?: number | null
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    quiz: QuizCreateNestedOneWithoutAttemptsInput
    user: UserCreateNestedOneWithoutQuizAttemptsInput
    responses?: QuizResponseCreateNestedManyWithoutAttemptInput
  }

  export type QuizAttemptUncheckedCreateInput = {
    id?: string
    quizId: string
    userId: string
    correctAnswers?: number
    totalQuestions: number
    avgResponseTime?: number
    responseTimeStdDev?: number
    streak?: number
    maxStreak?: number
    finalScore?: number
    speedScore?: number
    accuracyScore?: number
    consistencyScore?: number
    rank?: number | null
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    responses?: QuizResponseUncheckedCreateNestedManyWithoutAttemptInput
  }

  export type QuizAttemptUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    correctAnswers?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    responseTimeStdDev?: FloatFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    maxStreak?: IntFieldUpdateOperationsInput | number
    finalScore?: FloatFieldUpdateOperationsInput | number
    speedScore?: FloatFieldUpdateOperationsInput | number
    accuracyScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quiz?: QuizUpdateOneRequiredWithoutAttemptsNestedInput
    user?: UserUpdateOneRequiredWithoutQuizAttemptsNestedInput
    responses?: QuizResponseUpdateManyWithoutAttemptNestedInput
  }

  export type QuizAttemptUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    correctAnswers?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    responseTimeStdDev?: FloatFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    maxStreak?: IntFieldUpdateOperationsInput | number
    finalScore?: FloatFieldUpdateOperationsInput | number
    speedScore?: FloatFieldUpdateOperationsInput | number
    accuracyScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responses?: QuizResponseUncheckedUpdateManyWithoutAttemptNestedInput
  }

  export type QuizAttemptCreateManyInput = {
    id?: string
    quizId: string
    userId: string
    correctAnswers?: number
    totalQuestions: number
    avgResponseTime?: number
    responseTimeStdDev?: number
    streak?: number
    maxStreak?: number
    finalScore?: number
    speedScore?: number
    accuracyScore?: number
    consistencyScore?: number
    rank?: number | null
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type QuizAttemptUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    correctAnswers?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    responseTimeStdDev?: FloatFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    maxStreak?: IntFieldUpdateOperationsInput | number
    finalScore?: FloatFieldUpdateOperationsInput | number
    speedScore?: FloatFieldUpdateOperationsInput | number
    accuracyScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizAttemptUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    correctAnswers?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    responseTimeStdDev?: FloatFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    maxStreak?: IntFieldUpdateOperationsInput | number
    finalScore?: FloatFieldUpdateOperationsInput | number
    speedScore?: FloatFieldUpdateOperationsInput | number
    accuracyScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizResponseCreateInput = {
    id?: string
    questionId: string
    answer: string
    isCorrect: boolean
    responseTime: number
    answeredAt?: Date | string
    attempt: QuizAttemptCreateNestedOneWithoutResponsesInput
  }

  export type QuizResponseUncheckedCreateInput = {
    id?: string
    attemptId: string
    questionId: string
    answer: string
    isCorrect: boolean
    responseTime: number
    answeredAt?: Date | string
  }

  export type QuizResponseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: IntFieldUpdateOperationsInput | number
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempt?: QuizAttemptUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type QuizResponseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: IntFieldUpdateOperationsInput | number
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizResponseCreateManyInput = {
    id?: string
    attemptId: string
    questionId: string
    answer: string
    isCorrect: boolean
    responseTime: number
    answeredAt?: Date | string
  }

  export type QuizResponseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: IntFieldUpdateOperationsInput | number
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizResponseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    attemptId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: IntFieldUpdateOperationsInput | number
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FanIQBadgeCreateInput = {
    id?: string
    tier: string
    artistId: string
    artistName: string
    tokenId?: string | null
    txHash?: string | null
    earnedAt?: Date | string
    user: UserCreateNestedOneWithoutFanIQBadgesInput
  }

  export type FanIQBadgeUncheckedCreateInput = {
    id?: string
    userId: string
    tier: string
    artistId: string
    artistName: string
    tokenId?: string | null
    txHash?: string | null
    earnedAt?: Date | string
  }

  export type FanIQBadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFanIQBadgesNestedInput
  }

  export type FanIQBadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FanIQBadgeCreateManyInput = {
    id?: string
    userId: string
    tier: string
    artistId: string
    artistName: string
    tokenId?: string | null
    txHash?: string | null
    earnedAt?: Date | string
  }

  export type FanIQBadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FanIQBadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUserStatsCreateInput = {
    id?: string
    visitorId: string
    artistName: string
    attemptCount?: number
    totalScore?: number
    averageScore?: number
    bestScore?: number
    bestAccuracy?: number
    bestSpeed?: number
    lastScore?: number
    lastPlayedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizUserStatsUncheckedCreateInput = {
    id?: string
    visitorId: string
    artistName: string
    attemptCount?: number
    totalScore?: number
    averageScore?: number
    bestScore?: number
    bestAccuracy?: number
    bestSpeed?: number
    lastScore?: number
    lastPlayedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizUserStatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitorId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    attemptCount?: IntFieldUpdateOperationsInput | number
    totalScore?: FloatFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    bestScore?: FloatFieldUpdateOperationsInput | number
    bestAccuracy?: FloatFieldUpdateOperationsInput | number
    bestSpeed?: FloatFieldUpdateOperationsInput | number
    lastScore?: FloatFieldUpdateOperationsInput | number
    lastPlayedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUserStatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitorId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    attemptCount?: IntFieldUpdateOperationsInput | number
    totalScore?: FloatFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    bestScore?: FloatFieldUpdateOperationsInput | number
    bestAccuracy?: FloatFieldUpdateOperationsInput | number
    bestSpeed?: FloatFieldUpdateOperationsInput | number
    lastScore?: FloatFieldUpdateOperationsInput | number
    lastPlayedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUserStatsCreateManyInput = {
    id?: string
    visitorId: string
    artistName: string
    attemptCount?: number
    totalScore?: number
    averageScore?: number
    bestScore?: number
    bestAccuracy?: number
    bestSpeed?: number
    lastScore?: number
    lastPlayedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuizUserStatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitorId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    attemptCount?: IntFieldUpdateOperationsInput | number
    totalScore?: FloatFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    bestScore?: FloatFieldUpdateOperationsInput | number
    bestAccuracy?: FloatFieldUpdateOperationsInput | number
    bestSpeed?: FloatFieldUpdateOperationsInput | number
    lastScore?: FloatFieldUpdateOperationsInput | number
    lastPlayedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizUserStatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    visitorId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    attemptCount?: IntFieldUpdateOperationsInput | number
    totalScore?: FloatFieldUpdateOperationsInput | number
    averageScore?: FloatFieldUpdateOperationsInput | number
    bestScore?: FloatFieldUpdateOperationsInput | number
    bestAccuracy?: FloatFieldUpdateOperationsInput | number
    bestSpeed?: FloatFieldUpdateOperationsInput | number
    lastScore?: FloatFieldUpdateOperationsInput | number
    lastPlayedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type TicketListRelationFilter = {
    every?: TicketWhereInput
    some?: TicketWhereInput
    none?: TicketWhereInput
  }

  export type CommunityPostListRelationFilter = {
    every?: CommunityPostWhereInput
    some?: CommunityPostWhereInput
    none?: CommunityPostWhereInput
  }

  export type CommunityMemberListRelationFilter = {
    every?: CommunityMemberWhereInput
    some?: CommunityMemberWhereInput
    none?: CommunityMemberWhereInput
  }

  export type PostVoteListRelationFilter = {
    every?: PostVoteWhereInput
    some?: PostVoteWhereInput
    none?: PostVoteWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type CommentVoteListRelationFilter = {
    every?: CommentVoteWhereInput
    some?: CommentVoteWhereInput
    none?: CommentVoteWhereInput
  }

  export type EventReminderListRelationFilter = {
    every?: EventReminderWhereInput
    some?: EventReminderWhereInput
    none?: EventReminderWhereInput
  }

  export type QuizAttemptListRelationFilter = {
    every?: QuizAttemptWhereInput
    some?: QuizAttemptWhereInput
    none?: QuizAttemptWhereInput
  }

  export type FanIQBadgeListRelationFilter = {
    every?: FanIQBadgeWhereInput
    some?: FanIQBadgeWhereInput
    none?: FanIQBadgeWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunityPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunityMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostVoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentVoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventReminderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizAttemptOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FanIQBadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    auth0Id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    fandomScore?: SortOrder
    walletAddress?: SortOrder
    solanaWalletAddress?: SortOrder
    spotifyConnected?: SortOrder
    eventsAttended?: SortOrder
    vouchesGiven?: SortOrder
    vouchesReceived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    fandomScore?: SortOrder
    eventsAttended?: SortOrder
    vouchesGiven?: SortOrder
    vouchesReceived?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    auth0Id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    fandomScore?: SortOrder
    walletAddress?: SortOrder
    solanaWalletAddress?: SortOrder
    spotifyConnected?: SortOrder
    eventsAttended?: SortOrder
    vouchesGiven?: SortOrder
    vouchesReceived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    auth0Id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    fandomScore?: SortOrder
    walletAddress?: SortOrder
    solanaWalletAddress?: SortOrder
    spotifyConnected?: SortOrder
    eventsAttended?: SortOrder
    vouchesGiven?: SortOrder
    vouchesReceived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    fandomScore?: SortOrder
    eventsAttended?: SortOrder
    vouchesGiven?: SortOrder
    vouchesReceived?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type TicketTierListRelationFilter = {
    every?: TicketTierWhereInput
    some?: TicketTierWhereInput
    none?: TicketTierWhereInput
  }

  export type TicketTierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    artist?: SortOrder
    artistImage?: SortOrder
    venue?: SortOrder
    location?: SortOrder
    date?: SortOrder
    time?: SortOrder
    image?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    totalTickets?: SortOrder
    soldTickets?: SortOrder
    resaleEnabled?: SortOrder
    resaleCap?: SortOrder
    artistRoyalty?: SortOrder
    minFandomScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventAvgOrderByAggregateInput = {
    totalTickets?: SortOrder
    soldTickets?: SortOrder
    resaleCap?: SortOrder
    artistRoyalty?: SortOrder
    minFandomScore?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    artist?: SortOrder
    artistImage?: SortOrder
    venue?: SortOrder
    location?: SortOrder
    date?: SortOrder
    time?: SortOrder
    image?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    totalTickets?: SortOrder
    soldTickets?: SortOrder
    resaleEnabled?: SortOrder
    resaleCap?: SortOrder
    artistRoyalty?: SortOrder
    minFandomScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    artist?: SortOrder
    artistImage?: SortOrder
    venue?: SortOrder
    location?: SortOrder
    date?: SortOrder
    time?: SortOrder
    image?: SortOrder
    description?: SortOrder
    category?: SortOrder
    status?: SortOrder
    totalTickets?: SortOrder
    soldTickets?: SortOrder
    resaleEnabled?: SortOrder
    resaleCap?: SortOrder
    artistRoyalty?: SortOrder
    minFandomScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventSumOrderByAggregateInput = {
    totalTickets?: SortOrder
    soldTickets?: SortOrder
    resaleCap?: SortOrder
    artistRoyalty?: SortOrder
    minFandomScore?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EventScalarRelationFilter = {
    is?: EventWhereInput
    isNot?: EventWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type EventReminderEventIdUserIdCompoundUniqueInput = {
    eventId: string
    userId: string
  }

  export type EventReminderCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type EventReminderMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type EventReminderMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type TicketTierCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    available?: SortOrder
    total?: SortOrder
    benefits?: SortOrder
  }

  export type TicketTierAvgOrderByAggregateInput = {
    price?: SortOrder
    available?: SortOrder
    total?: SortOrder
  }

  export type TicketTierMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    available?: SortOrder
    total?: SortOrder
  }

  export type TicketTierMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    name?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    available?: SortOrder
    total?: SortOrder
  }

  export type TicketTierSumOrderByAggregateInput = {
    price?: SortOrder
    available?: SortOrder
    total?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type TicketTierScalarRelationFilter = {
    is?: TicketTierWhereInput
    isNot?: TicketTierWhereInput
  }

  export type TicketCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    tierId?: SortOrder
    ownerId?: SortOrder
    originalPrice?: SortOrder
    currentPrice?: SortOrder
    purchaseDate?: SortOrder
    status?: SortOrder
    qrCode?: SortOrder
    tokenId?: SortOrder
    txHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketAvgOrderByAggregateInput = {
    originalPrice?: SortOrder
    currentPrice?: SortOrder
  }

  export type TicketMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    tierId?: SortOrder
    ownerId?: SortOrder
    originalPrice?: SortOrder
    currentPrice?: SortOrder
    purchaseDate?: SortOrder
    status?: SortOrder
    qrCode?: SortOrder
    tokenId?: SortOrder
    txHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    tierId?: SortOrder
    ownerId?: SortOrder
    originalPrice?: SortOrder
    currentPrice?: SortOrder
    purchaseDate?: SortOrder
    status?: SortOrder
    qrCode?: SortOrder
    tokenId?: SortOrder
    txHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketSumOrderByAggregateInput = {
    originalPrice?: SortOrder
    currentPrice?: SortOrder
  }

  export type GovernanceProposalListRelationFilter = {
    every?: GovernanceProposalWhereInput
    some?: GovernanceProposalWhereInput
    none?: GovernanceProposalWhereInput
  }

  export type GovernanceProposalOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommunityCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    artistId?: SortOrder
    artistName?: SortOrder
    artistImage?: SortOrder
    description?: SortOrder
    memberCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityAvgOrderByAggregateInput = {
    memberCount?: SortOrder
  }

  export type CommunityMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    artistId?: SortOrder
    artistName?: SortOrder
    artistImage?: SortOrder
    description?: SortOrder
    memberCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    artistId?: SortOrder
    artistName?: SortOrder
    artistImage?: SortOrder
    description?: SortOrder
    memberCount?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunitySumOrderByAggregateInput = {
    memberCount?: SortOrder
  }

  export type CommunityScalarRelationFilter = {
    is?: CommunityWhereInput
    isNot?: CommunityWhereInput
  }

  export type CommunityPostCountOrderByAggregateInput = {
    id?: SortOrder
    communityId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    images?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    commentCount?: SortOrder
    isPinned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityPostAvgOrderByAggregateInput = {
    upvotes?: SortOrder
    downvotes?: SortOrder
    commentCount?: SortOrder
  }

  export type CommunityPostMaxOrderByAggregateInput = {
    id?: SortOrder
    communityId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    commentCount?: SortOrder
    isPinned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityPostMinOrderByAggregateInput = {
    id?: SortOrder
    communityId?: SortOrder
    authorId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    commentCount?: SortOrder
    isPinned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommunityPostSumOrderByAggregateInput = {
    upvotes?: SortOrder
    downvotes?: SortOrder
    commentCount?: SortOrder
  }

  export type CommunityPostScalarRelationFilter = {
    is?: CommunityPostWhereInput
    isNot?: CommunityPostWhereInput
  }

  export type PostVotePostIdUserIdCompoundUniqueInput = {
    postId: string
    userId: string
  }

  export type PostVoteCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type PostVoteMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type PostVoteMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type CommunityMemberUserIdCommunityIdCompoundUniqueInput = {
    userId: string
    communityId: string
  }

  export type CommunityMemberCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    communityId?: SortOrder
    role?: SortOrder
    reputationPoints?: SortOrder
    votingPower?: SortOrder
    isActive?: SortOrder
    joinedAt?: SortOrder
  }

  export type CommunityMemberAvgOrderByAggregateInput = {
    reputationPoints?: SortOrder
    votingPower?: SortOrder
  }

  export type CommunityMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    communityId?: SortOrder
    role?: SortOrder
    reputationPoints?: SortOrder
    votingPower?: SortOrder
    isActive?: SortOrder
    joinedAt?: SortOrder
  }

  export type CommunityMemberMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    communityId?: SortOrder
    role?: SortOrder
    reputationPoints?: SortOrder
    votingPower?: SortOrder
    isActive?: SortOrder
    joinedAt?: SortOrder
  }

  export type CommunityMemberSumOrderByAggregateInput = {
    reputationPoints?: SortOrder
    votingPower?: SortOrder
  }

  export type ProposalOptionListRelationFilter = {
    every?: ProposalOptionWhereInput
    some?: ProposalOptionWhereInput
    none?: ProposalOptionWhereInput
  }

  export type ProposalOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GovernanceProposalCountOrderByAggregateInput = {
    id?: SortOrder
    communityId?: SortOrder
    proposerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    quorumRequired?: SortOrder
    totalVotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GovernanceProposalAvgOrderByAggregateInput = {
    quorumRequired?: SortOrder
    totalVotes?: SortOrder
  }

  export type GovernanceProposalMaxOrderByAggregateInput = {
    id?: SortOrder
    communityId?: SortOrder
    proposerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    quorumRequired?: SortOrder
    totalVotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GovernanceProposalMinOrderByAggregateInput = {
    id?: SortOrder
    communityId?: SortOrder
    proposerId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    quorumRequired?: SortOrder
    totalVotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GovernanceProposalSumOrderByAggregateInput = {
    quorumRequired?: SortOrder
    totalVotes?: SortOrder
  }

  export type GovernanceProposalScalarRelationFilter = {
    is?: GovernanceProposalWhereInput
    isNot?: GovernanceProposalWhereInput
  }

  export type ProposalOptionCountOrderByAggregateInput = {
    id?: SortOrder
    proposalId?: SortOrder
    text?: SortOrder
    votes?: SortOrder
  }

  export type ProposalOptionAvgOrderByAggregateInput = {
    votes?: SortOrder
  }

  export type ProposalOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    proposalId?: SortOrder
    text?: SortOrder
    votes?: SortOrder
  }

  export type ProposalOptionMinOrderByAggregateInput = {
    id?: SortOrder
    proposalId?: SortOrder
    text?: SortOrder
    votes?: SortOrder
  }

  export type ProposalOptionSumOrderByAggregateInput = {
    votes?: SortOrder
  }

  export type CommentNullableScalarRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    upvotes?: SortOrder
    downvotes?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    parentId?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    upvotes?: SortOrder
    downvotes?: SortOrder
  }

  export type CommentScalarRelationFilter = {
    is?: CommentWhereInput
    isNot?: CommentWhereInput
  }

  export type CommentVoteCommentIdUserIdCompoundUniqueInput = {
    commentId: string
    userId: string
  }

  export type CommentVoteCountOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentVoteMaxOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentVoteMinOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type QuizQuestionListRelationFilter = {
    every?: QuizQuestionWhereInput
    some?: QuizQuestionWhereInput
    none?: QuizQuestionWhereInput
  }

  export type QuizQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    artistId?: SortOrder
    artistName?: SortOrder
    type?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    questionCount?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizAvgOrderByAggregateInput = {
    duration?: SortOrder
    questionCount?: SortOrder
  }

  export type QuizMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    artistId?: SortOrder
    artistName?: SortOrder
    type?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    questionCount?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    artistId?: SortOrder
    artistName?: SortOrder
    type?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    questionCount?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizSumOrderByAggregateInput = {
    duration?: SortOrder
    questionCount?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type QuizScalarRelationFilter = {
    is?: QuizWhereInput
    isNot?: QuizWhereInput
  }

  export type QuizQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    question?: SortOrder
    type?: SortOrder
    options?: SortOrder
    correctAnswer?: SortOrder
    imageUrl?: SortOrder
    timeLimit?: SortOrder
    difficulty?: SortOrder
    orderIndex?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizQuestionAvgOrderByAggregateInput = {
    timeLimit?: SortOrder
    orderIndex?: SortOrder
  }

  export type QuizQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    question?: SortOrder
    type?: SortOrder
    correctAnswer?: SortOrder
    imageUrl?: SortOrder
    timeLimit?: SortOrder
    difficulty?: SortOrder
    orderIndex?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    question?: SortOrder
    type?: SortOrder
    correctAnswer?: SortOrder
    imageUrl?: SortOrder
    timeLimit?: SortOrder
    difficulty?: SortOrder
    orderIndex?: SortOrder
    createdAt?: SortOrder
  }

  export type QuizQuestionSumOrderByAggregateInput = {
    timeLimit?: SortOrder
    orderIndex?: SortOrder
  }

  export type QuizResponseListRelationFilter = {
    every?: QuizResponseWhereInput
    some?: QuizResponseWhereInput
    none?: QuizResponseWhereInput
  }

  export type QuizResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuizAttemptCountOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    userId?: SortOrder
    correctAnswers?: SortOrder
    totalQuestions?: SortOrder
    avgResponseTime?: SortOrder
    responseTimeStdDev?: SortOrder
    streak?: SortOrder
    maxStreak?: SortOrder
    finalScore?: SortOrder
    speedScore?: SortOrder
    accuracyScore?: SortOrder
    consistencyScore?: SortOrder
    rank?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type QuizAttemptAvgOrderByAggregateInput = {
    correctAnswers?: SortOrder
    totalQuestions?: SortOrder
    avgResponseTime?: SortOrder
    responseTimeStdDev?: SortOrder
    streak?: SortOrder
    maxStreak?: SortOrder
    finalScore?: SortOrder
    speedScore?: SortOrder
    accuracyScore?: SortOrder
    consistencyScore?: SortOrder
    rank?: SortOrder
  }

  export type QuizAttemptMaxOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    userId?: SortOrder
    correctAnswers?: SortOrder
    totalQuestions?: SortOrder
    avgResponseTime?: SortOrder
    responseTimeStdDev?: SortOrder
    streak?: SortOrder
    maxStreak?: SortOrder
    finalScore?: SortOrder
    speedScore?: SortOrder
    accuracyScore?: SortOrder
    consistencyScore?: SortOrder
    rank?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type QuizAttemptMinOrderByAggregateInput = {
    id?: SortOrder
    quizId?: SortOrder
    userId?: SortOrder
    correctAnswers?: SortOrder
    totalQuestions?: SortOrder
    avgResponseTime?: SortOrder
    responseTimeStdDev?: SortOrder
    streak?: SortOrder
    maxStreak?: SortOrder
    finalScore?: SortOrder
    speedScore?: SortOrder
    accuracyScore?: SortOrder
    consistencyScore?: SortOrder
    rank?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
  }

  export type QuizAttemptSumOrderByAggregateInput = {
    correctAnswers?: SortOrder
    totalQuestions?: SortOrder
    avgResponseTime?: SortOrder
    responseTimeStdDev?: SortOrder
    streak?: SortOrder
    maxStreak?: SortOrder
    finalScore?: SortOrder
    speedScore?: SortOrder
    accuracyScore?: SortOrder
    consistencyScore?: SortOrder
    rank?: SortOrder
  }

  export type QuizAttemptScalarRelationFilter = {
    is?: QuizAttemptWhereInput
    isNot?: QuizAttemptWhereInput
  }

  export type QuizResponseCountOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    questionId?: SortOrder
    answer?: SortOrder
    isCorrect?: SortOrder
    responseTime?: SortOrder
    answeredAt?: SortOrder
  }

  export type QuizResponseAvgOrderByAggregateInput = {
    responseTime?: SortOrder
  }

  export type QuizResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    questionId?: SortOrder
    answer?: SortOrder
    isCorrect?: SortOrder
    responseTime?: SortOrder
    answeredAt?: SortOrder
  }

  export type QuizResponseMinOrderByAggregateInput = {
    id?: SortOrder
    attemptId?: SortOrder
    questionId?: SortOrder
    answer?: SortOrder
    isCorrect?: SortOrder
    responseTime?: SortOrder
    answeredAt?: SortOrder
  }

  export type QuizResponseSumOrderByAggregateInput = {
    responseTime?: SortOrder
  }

  export type FanIQBadgeUserIdArtistIdTierCompoundUniqueInput = {
    userId: string
    artistId: string
    tier: string
  }

  export type FanIQBadgeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tier?: SortOrder
    artistId?: SortOrder
    artistName?: SortOrder
    tokenId?: SortOrder
    txHash?: SortOrder
    earnedAt?: SortOrder
  }

  export type FanIQBadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tier?: SortOrder
    artistId?: SortOrder
    artistName?: SortOrder
    tokenId?: SortOrder
    txHash?: SortOrder
    earnedAt?: SortOrder
  }

  export type FanIQBadgeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tier?: SortOrder
    artistId?: SortOrder
    artistName?: SortOrder
    tokenId?: SortOrder
    txHash?: SortOrder
    earnedAt?: SortOrder
  }

  export type QuizUserStatsVisitorIdArtistNameCompoundUniqueInput = {
    visitorId: string
    artistName: string
  }

  export type QuizUserStatsCountOrderByAggregateInput = {
    id?: SortOrder
    visitorId?: SortOrder
    artistName?: SortOrder
    attemptCount?: SortOrder
    totalScore?: SortOrder
    averageScore?: SortOrder
    bestScore?: SortOrder
    bestAccuracy?: SortOrder
    bestSpeed?: SortOrder
    lastScore?: SortOrder
    lastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizUserStatsAvgOrderByAggregateInput = {
    attemptCount?: SortOrder
    totalScore?: SortOrder
    averageScore?: SortOrder
    bestScore?: SortOrder
    bestAccuracy?: SortOrder
    bestSpeed?: SortOrder
    lastScore?: SortOrder
  }

  export type QuizUserStatsMaxOrderByAggregateInput = {
    id?: SortOrder
    visitorId?: SortOrder
    artistName?: SortOrder
    attemptCount?: SortOrder
    totalScore?: SortOrder
    averageScore?: SortOrder
    bestScore?: SortOrder
    bestAccuracy?: SortOrder
    bestSpeed?: SortOrder
    lastScore?: SortOrder
    lastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizUserStatsMinOrderByAggregateInput = {
    id?: SortOrder
    visitorId?: SortOrder
    artistName?: SortOrder
    attemptCount?: SortOrder
    totalScore?: SortOrder
    averageScore?: SortOrder
    bestScore?: SortOrder
    bestAccuracy?: SortOrder
    bestSpeed?: SortOrder
    lastScore?: SortOrder
    lastPlayedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuizUserStatsSumOrderByAggregateInput = {
    attemptCount?: SortOrder
    totalScore?: SortOrder
    averageScore?: SortOrder
    bestScore?: SortOrder
    bestAccuracy?: SortOrder
    bestSpeed?: SortOrder
    lastScore?: SortOrder
  }

  export type TicketCreateNestedManyWithoutOwnerInput = {
    create?: XOR<TicketCreateWithoutOwnerInput, TicketUncheckedCreateWithoutOwnerInput> | TicketCreateWithoutOwnerInput[] | TicketUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutOwnerInput | TicketCreateOrConnectWithoutOwnerInput[]
    createMany?: TicketCreateManyOwnerInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type CommunityPostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommunityPostCreateWithoutAuthorInput, CommunityPostUncheckedCreateWithoutAuthorInput> | CommunityPostCreateWithoutAuthorInput[] | CommunityPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommunityPostCreateOrConnectWithoutAuthorInput | CommunityPostCreateOrConnectWithoutAuthorInput[]
    createMany?: CommunityPostCreateManyAuthorInputEnvelope
    connect?: CommunityPostWhereUniqueInput | CommunityPostWhereUniqueInput[]
  }

  export type CommunityMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<CommunityMemberCreateWithoutUserInput, CommunityMemberUncheckedCreateWithoutUserInput> | CommunityMemberCreateWithoutUserInput[] | CommunityMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunityMemberCreateOrConnectWithoutUserInput | CommunityMemberCreateOrConnectWithoutUserInput[]
    createMany?: CommunityMemberCreateManyUserInputEnvelope
    connect?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
  }

  export type PostVoteCreateNestedManyWithoutUserInput = {
    create?: XOR<PostVoteCreateWithoutUserInput, PostVoteUncheckedCreateWithoutUserInput> | PostVoteCreateWithoutUserInput[] | PostVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostVoteCreateOrConnectWithoutUserInput | PostVoteCreateOrConnectWithoutUserInput[]
    createMany?: PostVoteCreateManyUserInputEnvelope
    connect?: PostVoteWhereUniqueInput | PostVoteWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentVoteCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentVoteCreateWithoutUserInput, CommentVoteUncheckedCreateWithoutUserInput> | CommentVoteCreateWithoutUserInput[] | CommentVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentVoteCreateOrConnectWithoutUserInput | CommentVoteCreateOrConnectWithoutUserInput[]
    createMany?: CommentVoteCreateManyUserInputEnvelope
    connect?: CommentVoteWhereUniqueInput | CommentVoteWhereUniqueInput[]
  }

  export type EventReminderCreateNestedManyWithoutUserInput = {
    create?: XOR<EventReminderCreateWithoutUserInput, EventReminderUncheckedCreateWithoutUserInput> | EventReminderCreateWithoutUserInput[] | EventReminderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventReminderCreateOrConnectWithoutUserInput | EventReminderCreateOrConnectWithoutUserInput[]
    createMany?: EventReminderCreateManyUserInputEnvelope
    connect?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
  }

  export type QuizAttemptCreateNestedManyWithoutUserInput = {
    create?: XOR<QuizAttemptCreateWithoutUserInput, QuizAttemptUncheckedCreateWithoutUserInput> | QuizAttemptCreateWithoutUserInput[] | QuizAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutUserInput | QuizAttemptCreateOrConnectWithoutUserInput[]
    createMany?: QuizAttemptCreateManyUserInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type FanIQBadgeCreateNestedManyWithoutUserInput = {
    create?: XOR<FanIQBadgeCreateWithoutUserInput, FanIQBadgeUncheckedCreateWithoutUserInput> | FanIQBadgeCreateWithoutUserInput[] | FanIQBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FanIQBadgeCreateOrConnectWithoutUserInput | FanIQBadgeCreateOrConnectWithoutUserInput[]
    createMany?: FanIQBadgeCreateManyUserInputEnvelope
    connect?: FanIQBadgeWhereUniqueInput | FanIQBadgeWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<TicketCreateWithoutOwnerInput, TicketUncheckedCreateWithoutOwnerInput> | TicketCreateWithoutOwnerInput[] | TicketUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutOwnerInput | TicketCreateOrConnectWithoutOwnerInput[]
    createMany?: TicketCreateManyOwnerInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type CommunityPostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommunityPostCreateWithoutAuthorInput, CommunityPostUncheckedCreateWithoutAuthorInput> | CommunityPostCreateWithoutAuthorInput[] | CommunityPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommunityPostCreateOrConnectWithoutAuthorInput | CommunityPostCreateOrConnectWithoutAuthorInput[]
    createMany?: CommunityPostCreateManyAuthorInputEnvelope
    connect?: CommunityPostWhereUniqueInput | CommunityPostWhereUniqueInput[]
  }

  export type CommunityMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommunityMemberCreateWithoutUserInput, CommunityMemberUncheckedCreateWithoutUserInput> | CommunityMemberCreateWithoutUserInput[] | CommunityMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunityMemberCreateOrConnectWithoutUserInput | CommunityMemberCreateOrConnectWithoutUserInput[]
    createMany?: CommunityMemberCreateManyUserInputEnvelope
    connect?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
  }

  export type PostVoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PostVoteCreateWithoutUserInput, PostVoteUncheckedCreateWithoutUserInput> | PostVoteCreateWithoutUserInput[] | PostVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostVoteCreateOrConnectWithoutUserInput | PostVoteCreateOrConnectWithoutUserInput[]
    createMany?: PostVoteCreateManyUserInputEnvelope
    connect?: PostVoteWhereUniqueInput | PostVoteWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentVoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentVoteCreateWithoutUserInput, CommentVoteUncheckedCreateWithoutUserInput> | CommentVoteCreateWithoutUserInput[] | CommentVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentVoteCreateOrConnectWithoutUserInput | CommentVoteCreateOrConnectWithoutUserInput[]
    createMany?: CommentVoteCreateManyUserInputEnvelope
    connect?: CommentVoteWhereUniqueInput | CommentVoteWhereUniqueInput[]
  }

  export type EventReminderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EventReminderCreateWithoutUserInput, EventReminderUncheckedCreateWithoutUserInput> | EventReminderCreateWithoutUserInput[] | EventReminderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventReminderCreateOrConnectWithoutUserInput | EventReminderCreateOrConnectWithoutUserInput[]
    createMany?: EventReminderCreateManyUserInputEnvelope
    connect?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
  }

  export type QuizAttemptUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<QuizAttemptCreateWithoutUserInput, QuizAttemptUncheckedCreateWithoutUserInput> | QuizAttemptCreateWithoutUserInput[] | QuizAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutUserInput | QuizAttemptCreateOrConnectWithoutUserInput[]
    createMany?: QuizAttemptCreateManyUserInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type FanIQBadgeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FanIQBadgeCreateWithoutUserInput, FanIQBadgeUncheckedCreateWithoutUserInput> | FanIQBadgeCreateWithoutUserInput[] | FanIQBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FanIQBadgeCreateOrConnectWithoutUserInput | FanIQBadgeCreateOrConnectWithoutUserInput[]
    createMany?: FanIQBadgeCreateManyUserInputEnvelope
    connect?: FanIQBadgeWhereUniqueInput | FanIQBadgeWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TicketUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<TicketCreateWithoutOwnerInput, TicketUncheckedCreateWithoutOwnerInput> | TicketCreateWithoutOwnerInput[] | TicketUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutOwnerInput | TicketCreateOrConnectWithoutOwnerInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutOwnerInput | TicketUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: TicketCreateManyOwnerInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutOwnerInput | TicketUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutOwnerInput | TicketUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type CommunityPostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommunityPostCreateWithoutAuthorInput, CommunityPostUncheckedCreateWithoutAuthorInput> | CommunityPostCreateWithoutAuthorInput[] | CommunityPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommunityPostCreateOrConnectWithoutAuthorInput | CommunityPostCreateOrConnectWithoutAuthorInput[]
    upsert?: CommunityPostUpsertWithWhereUniqueWithoutAuthorInput | CommunityPostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommunityPostCreateManyAuthorInputEnvelope
    set?: CommunityPostWhereUniqueInput | CommunityPostWhereUniqueInput[]
    disconnect?: CommunityPostWhereUniqueInput | CommunityPostWhereUniqueInput[]
    delete?: CommunityPostWhereUniqueInput | CommunityPostWhereUniqueInput[]
    connect?: CommunityPostWhereUniqueInput | CommunityPostWhereUniqueInput[]
    update?: CommunityPostUpdateWithWhereUniqueWithoutAuthorInput | CommunityPostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommunityPostUpdateManyWithWhereWithoutAuthorInput | CommunityPostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommunityPostScalarWhereInput | CommunityPostScalarWhereInput[]
  }

  export type CommunityMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommunityMemberCreateWithoutUserInput, CommunityMemberUncheckedCreateWithoutUserInput> | CommunityMemberCreateWithoutUserInput[] | CommunityMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunityMemberCreateOrConnectWithoutUserInput | CommunityMemberCreateOrConnectWithoutUserInput[]
    upsert?: CommunityMemberUpsertWithWhereUniqueWithoutUserInput | CommunityMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommunityMemberCreateManyUserInputEnvelope
    set?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    disconnect?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    delete?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    connect?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    update?: CommunityMemberUpdateWithWhereUniqueWithoutUserInput | CommunityMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommunityMemberUpdateManyWithWhereWithoutUserInput | CommunityMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommunityMemberScalarWhereInput | CommunityMemberScalarWhereInput[]
  }

  export type PostVoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostVoteCreateWithoutUserInput, PostVoteUncheckedCreateWithoutUserInput> | PostVoteCreateWithoutUserInput[] | PostVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostVoteCreateOrConnectWithoutUserInput | PostVoteCreateOrConnectWithoutUserInput[]
    upsert?: PostVoteUpsertWithWhereUniqueWithoutUserInput | PostVoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostVoteCreateManyUserInputEnvelope
    set?: PostVoteWhereUniqueInput | PostVoteWhereUniqueInput[]
    disconnect?: PostVoteWhereUniqueInput | PostVoteWhereUniqueInput[]
    delete?: PostVoteWhereUniqueInput | PostVoteWhereUniqueInput[]
    connect?: PostVoteWhereUniqueInput | PostVoteWhereUniqueInput[]
    update?: PostVoteUpdateWithWhereUniqueWithoutUserInput | PostVoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostVoteUpdateManyWithWhereWithoutUserInput | PostVoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostVoteScalarWhereInput | PostVoteScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentVoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentVoteCreateWithoutUserInput, CommentVoteUncheckedCreateWithoutUserInput> | CommentVoteCreateWithoutUserInput[] | CommentVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentVoteCreateOrConnectWithoutUserInput | CommentVoteCreateOrConnectWithoutUserInput[]
    upsert?: CommentVoteUpsertWithWhereUniqueWithoutUserInput | CommentVoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentVoteCreateManyUserInputEnvelope
    set?: CommentVoteWhereUniqueInput | CommentVoteWhereUniqueInput[]
    disconnect?: CommentVoteWhereUniqueInput | CommentVoteWhereUniqueInput[]
    delete?: CommentVoteWhereUniqueInput | CommentVoteWhereUniqueInput[]
    connect?: CommentVoteWhereUniqueInput | CommentVoteWhereUniqueInput[]
    update?: CommentVoteUpdateWithWhereUniqueWithoutUserInput | CommentVoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentVoteUpdateManyWithWhereWithoutUserInput | CommentVoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentVoteScalarWhereInput | CommentVoteScalarWhereInput[]
  }

  export type EventReminderUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventReminderCreateWithoutUserInput, EventReminderUncheckedCreateWithoutUserInput> | EventReminderCreateWithoutUserInput[] | EventReminderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventReminderCreateOrConnectWithoutUserInput | EventReminderCreateOrConnectWithoutUserInput[]
    upsert?: EventReminderUpsertWithWhereUniqueWithoutUserInput | EventReminderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventReminderCreateManyUserInputEnvelope
    set?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
    disconnect?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
    delete?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
    connect?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
    update?: EventReminderUpdateWithWhereUniqueWithoutUserInput | EventReminderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventReminderUpdateManyWithWhereWithoutUserInput | EventReminderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventReminderScalarWhereInput | EventReminderScalarWhereInput[]
  }

  export type QuizAttemptUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutUserInput, QuizAttemptUncheckedCreateWithoutUserInput> | QuizAttemptCreateWithoutUserInput[] | QuizAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutUserInput | QuizAttemptCreateOrConnectWithoutUserInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutUserInput | QuizAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuizAttemptCreateManyUserInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutUserInput | QuizAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutUserInput | QuizAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type FanIQBadgeUpdateManyWithoutUserNestedInput = {
    create?: XOR<FanIQBadgeCreateWithoutUserInput, FanIQBadgeUncheckedCreateWithoutUserInput> | FanIQBadgeCreateWithoutUserInput[] | FanIQBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FanIQBadgeCreateOrConnectWithoutUserInput | FanIQBadgeCreateOrConnectWithoutUserInput[]
    upsert?: FanIQBadgeUpsertWithWhereUniqueWithoutUserInput | FanIQBadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FanIQBadgeCreateManyUserInputEnvelope
    set?: FanIQBadgeWhereUniqueInput | FanIQBadgeWhereUniqueInput[]
    disconnect?: FanIQBadgeWhereUniqueInput | FanIQBadgeWhereUniqueInput[]
    delete?: FanIQBadgeWhereUniqueInput | FanIQBadgeWhereUniqueInput[]
    connect?: FanIQBadgeWhereUniqueInput | FanIQBadgeWhereUniqueInput[]
    update?: FanIQBadgeUpdateWithWhereUniqueWithoutUserInput | FanIQBadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FanIQBadgeUpdateManyWithWhereWithoutUserInput | FanIQBadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FanIQBadgeScalarWhereInput | FanIQBadgeScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<TicketCreateWithoutOwnerInput, TicketUncheckedCreateWithoutOwnerInput> | TicketCreateWithoutOwnerInput[] | TicketUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutOwnerInput | TicketCreateOrConnectWithoutOwnerInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutOwnerInput | TicketUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: TicketCreateManyOwnerInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutOwnerInput | TicketUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutOwnerInput | TicketUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type CommunityPostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommunityPostCreateWithoutAuthorInput, CommunityPostUncheckedCreateWithoutAuthorInput> | CommunityPostCreateWithoutAuthorInput[] | CommunityPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommunityPostCreateOrConnectWithoutAuthorInput | CommunityPostCreateOrConnectWithoutAuthorInput[]
    upsert?: CommunityPostUpsertWithWhereUniqueWithoutAuthorInput | CommunityPostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommunityPostCreateManyAuthorInputEnvelope
    set?: CommunityPostWhereUniqueInput | CommunityPostWhereUniqueInput[]
    disconnect?: CommunityPostWhereUniqueInput | CommunityPostWhereUniqueInput[]
    delete?: CommunityPostWhereUniqueInput | CommunityPostWhereUniqueInput[]
    connect?: CommunityPostWhereUniqueInput | CommunityPostWhereUniqueInput[]
    update?: CommunityPostUpdateWithWhereUniqueWithoutAuthorInput | CommunityPostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommunityPostUpdateManyWithWhereWithoutAuthorInput | CommunityPostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommunityPostScalarWhereInput | CommunityPostScalarWhereInput[]
  }

  export type CommunityMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommunityMemberCreateWithoutUserInput, CommunityMemberUncheckedCreateWithoutUserInput> | CommunityMemberCreateWithoutUserInput[] | CommunityMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommunityMemberCreateOrConnectWithoutUserInput | CommunityMemberCreateOrConnectWithoutUserInput[]
    upsert?: CommunityMemberUpsertWithWhereUniqueWithoutUserInput | CommunityMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommunityMemberCreateManyUserInputEnvelope
    set?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    disconnect?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    delete?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    connect?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    update?: CommunityMemberUpdateWithWhereUniqueWithoutUserInput | CommunityMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommunityMemberUpdateManyWithWhereWithoutUserInput | CommunityMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommunityMemberScalarWhereInput | CommunityMemberScalarWhereInput[]
  }

  export type PostVoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostVoteCreateWithoutUserInput, PostVoteUncheckedCreateWithoutUserInput> | PostVoteCreateWithoutUserInput[] | PostVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostVoteCreateOrConnectWithoutUserInput | PostVoteCreateOrConnectWithoutUserInput[]
    upsert?: PostVoteUpsertWithWhereUniqueWithoutUserInput | PostVoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostVoteCreateManyUserInputEnvelope
    set?: PostVoteWhereUniqueInput | PostVoteWhereUniqueInput[]
    disconnect?: PostVoteWhereUniqueInput | PostVoteWhereUniqueInput[]
    delete?: PostVoteWhereUniqueInput | PostVoteWhereUniqueInput[]
    connect?: PostVoteWhereUniqueInput | PostVoteWhereUniqueInput[]
    update?: PostVoteUpdateWithWhereUniqueWithoutUserInput | PostVoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostVoteUpdateManyWithWhereWithoutUserInput | PostVoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostVoteScalarWhereInput | PostVoteScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentVoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentVoteCreateWithoutUserInput, CommentVoteUncheckedCreateWithoutUserInput> | CommentVoteCreateWithoutUserInput[] | CommentVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentVoteCreateOrConnectWithoutUserInput | CommentVoteCreateOrConnectWithoutUserInput[]
    upsert?: CommentVoteUpsertWithWhereUniqueWithoutUserInput | CommentVoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentVoteCreateManyUserInputEnvelope
    set?: CommentVoteWhereUniqueInput | CommentVoteWhereUniqueInput[]
    disconnect?: CommentVoteWhereUniqueInput | CommentVoteWhereUniqueInput[]
    delete?: CommentVoteWhereUniqueInput | CommentVoteWhereUniqueInput[]
    connect?: CommentVoteWhereUniqueInput | CommentVoteWhereUniqueInput[]
    update?: CommentVoteUpdateWithWhereUniqueWithoutUserInput | CommentVoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentVoteUpdateManyWithWhereWithoutUserInput | CommentVoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentVoteScalarWhereInput | CommentVoteScalarWhereInput[]
  }

  export type EventReminderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventReminderCreateWithoutUserInput, EventReminderUncheckedCreateWithoutUserInput> | EventReminderCreateWithoutUserInput[] | EventReminderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventReminderCreateOrConnectWithoutUserInput | EventReminderCreateOrConnectWithoutUserInput[]
    upsert?: EventReminderUpsertWithWhereUniqueWithoutUserInput | EventReminderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventReminderCreateManyUserInputEnvelope
    set?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
    disconnect?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
    delete?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
    connect?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
    update?: EventReminderUpdateWithWhereUniqueWithoutUserInput | EventReminderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventReminderUpdateManyWithWhereWithoutUserInput | EventReminderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventReminderScalarWhereInput | EventReminderScalarWhereInput[]
  }

  export type QuizAttemptUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutUserInput, QuizAttemptUncheckedCreateWithoutUserInput> | QuizAttemptCreateWithoutUserInput[] | QuizAttemptUncheckedCreateWithoutUserInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutUserInput | QuizAttemptCreateOrConnectWithoutUserInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutUserInput | QuizAttemptUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: QuizAttemptCreateManyUserInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutUserInput | QuizAttemptUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutUserInput | QuizAttemptUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type FanIQBadgeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FanIQBadgeCreateWithoutUserInput, FanIQBadgeUncheckedCreateWithoutUserInput> | FanIQBadgeCreateWithoutUserInput[] | FanIQBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FanIQBadgeCreateOrConnectWithoutUserInput | FanIQBadgeCreateOrConnectWithoutUserInput[]
    upsert?: FanIQBadgeUpsertWithWhereUniqueWithoutUserInput | FanIQBadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FanIQBadgeCreateManyUserInputEnvelope
    set?: FanIQBadgeWhereUniqueInput | FanIQBadgeWhereUniqueInput[]
    disconnect?: FanIQBadgeWhereUniqueInput | FanIQBadgeWhereUniqueInput[]
    delete?: FanIQBadgeWhereUniqueInput | FanIQBadgeWhereUniqueInput[]
    connect?: FanIQBadgeWhereUniqueInput | FanIQBadgeWhereUniqueInput[]
    update?: FanIQBadgeUpdateWithWhereUniqueWithoutUserInput | FanIQBadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FanIQBadgeUpdateManyWithWhereWithoutUserInput | FanIQBadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FanIQBadgeScalarWhereInput | FanIQBadgeScalarWhereInput[]
  }

  export type TicketTierCreateNestedManyWithoutEventInput = {
    create?: XOR<TicketTierCreateWithoutEventInput, TicketTierUncheckedCreateWithoutEventInput> | TicketTierCreateWithoutEventInput[] | TicketTierUncheckedCreateWithoutEventInput[]
    connectOrCreate?: TicketTierCreateOrConnectWithoutEventInput | TicketTierCreateOrConnectWithoutEventInput[]
    createMany?: TicketTierCreateManyEventInputEnvelope
    connect?: TicketTierWhereUniqueInput | TicketTierWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutEventInput = {
    create?: XOR<TicketCreateWithoutEventInput, TicketUncheckedCreateWithoutEventInput> | TicketCreateWithoutEventInput[] | TicketUncheckedCreateWithoutEventInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutEventInput | TicketCreateOrConnectWithoutEventInput[]
    createMany?: TicketCreateManyEventInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type EventReminderCreateNestedManyWithoutEventInput = {
    create?: XOR<EventReminderCreateWithoutEventInput, EventReminderUncheckedCreateWithoutEventInput> | EventReminderCreateWithoutEventInput[] | EventReminderUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventReminderCreateOrConnectWithoutEventInput | EventReminderCreateOrConnectWithoutEventInput[]
    createMany?: EventReminderCreateManyEventInputEnvelope
    connect?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
  }

  export type TicketTierUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<TicketTierCreateWithoutEventInput, TicketTierUncheckedCreateWithoutEventInput> | TicketTierCreateWithoutEventInput[] | TicketTierUncheckedCreateWithoutEventInput[]
    connectOrCreate?: TicketTierCreateOrConnectWithoutEventInput | TicketTierCreateOrConnectWithoutEventInput[]
    createMany?: TicketTierCreateManyEventInputEnvelope
    connect?: TicketTierWhereUniqueInput | TicketTierWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<TicketCreateWithoutEventInput, TicketUncheckedCreateWithoutEventInput> | TicketCreateWithoutEventInput[] | TicketUncheckedCreateWithoutEventInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutEventInput | TicketCreateOrConnectWithoutEventInput[]
    createMany?: TicketCreateManyEventInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type EventReminderUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventReminderCreateWithoutEventInput, EventReminderUncheckedCreateWithoutEventInput> | EventReminderCreateWithoutEventInput[] | EventReminderUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventReminderCreateOrConnectWithoutEventInput | EventReminderCreateOrConnectWithoutEventInput[]
    createMany?: EventReminderCreateManyEventInputEnvelope
    connect?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TicketTierUpdateManyWithoutEventNestedInput = {
    create?: XOR<TicketTierCreateWithoutEventInput, TicketTierUncheckedCreateWithoutEventInput> | TicketTierCreateWithoutEventInput[] | TicketTierUncheckedCreateWithoutEventInput[]
    connectOrCreate?: TicketTierCreateOrConnectWithoutEventInput | TicketTierCreateOrConnectWithoutEventInput[]
    upsert?: TicketTierUpsertWithWhereUniqueWithoutEventInput | TicketTierUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: TicketTierCreateManyEventInputEnvelope
    set?: TicketTierWhereUniqueInput | TicketTierWhereUniqueInput[]
    disconnect?: TicketTierWhereUniqueInput | TicketTierWhereUniqueInput[]
    delete?: TicketTierWhereUniqueInput | TicketTierWhereUniqueInput[]
    connect?: TicketTierWhereUniqueInput | TicketTierWhereUniqueInput[]
    update?: TicketTierUpdateWithWhereUniqueWithoutEventInput | TicketTierUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: TicketTierUpdateManyWithWhereWithoutEventInput | TicketTierUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: TicketTierScalarWhereInput | TicketTierScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutEventNestedInput = {
    create?: XOR<TicketCreateWithoutEventInput, TicketUncheckedCreateWithoutEventInput> | TicketCreateWithoutEventInput[] | TicketUncheckedCreateWithoutEventInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutEventInput | TicketCreateOrConnectWithoutEventInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutEventInput | TicketUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: TicketCreateManyEventInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutEventInput | TicketUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutEventInput | TicketUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type EventReminderUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventReminderCreateWithoutEventInput, EventReminderUncheckedCreateWithoutEventInput> | EventReminderCreateWithoutEventInput[] | EventReminderUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventReminderCreateOrConnectWithoutEventInput | EventReminderCreateOrConnectWithoutEventInput[]
    upsert?: EventReminderUpsertWithWhereUniqueWithoutEventInput | EventReminderUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventReminderCreateManyEventInputEnvelope
    set?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
    disconnect?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
    delete?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
    connect?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
    update?: EventReminderUpdateWithWhereUniqueWithoutEventInput | EventReminderUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventReminderUpdateManyWithWhereWithoutEventInput | EventReminderUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventReminderScalarWhereInput | EventReminderScalarWhereInput[]
  }

  export type TicketTierUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<TicketTierCreateWithoutEventInput, TicketTierUncheckedCreateWithoutEventInput> | TicketTierCreateWithoutEventInput[] | TicketTierUncheckedCreateWithoutEventInput[]
    connectOrCreate?: TicketTierCreateOrConnectWithoutEventInput | TicketTierCreateOrConnectWithoutEventInput[]
    upsert?: TicketTierUpsertWithWhereUniqueWithoutEventInput | TicketTierUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: TicketTierCreateManyEventInputEnvelope
    set?: TicketTierWhereUniqueInput | TicketTierWhereUniqueInput[]
    disconnect?: TicketTierWhereUniqueInput | TicketTierWhereUniqueInput[]
    delete?: TicketTierWhereUniqueInput | TicketTierWhereUniqueInput[]
    connect?: TicketTierWhereUniqueInput | TicketTierWhereUniqueInput[]
    update?: TicketTierUpdateWithWhereUniqueWithoutEventInput | TicketTierUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: TicketTierUpdateManyWithWhereWithoutEventInput | TicketTierUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: TicketTierScalarWhereInput | TicketTierScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<TicketCreateWithoutEventInput, TicketUncheckedCreateWithoutEventInput> | TicketCreateWithoutEventInput[] | TicketUncheckedCreateWithoutEventInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutEventInput | TicketCreateOrConnectWithoutEventInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutEventInput | TicketUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: TicketCreateManyEventInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutEventInput | TicketUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutEventInput | TicketUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type EventReminderUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventReminderCreateWithoutEventInput, EventReminderUncheckedCreateWithoutEventInput> | EventReminderCreateWithoutEventInput[] | EventReminderUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventReminderCreateOrConnectWithoutEventInput | EventReminderCreateOrConnectWithoutEventInput[]
    upsert?: EventReminderUpsertWithWhereUniqueWithoutEventInput | EventReminderUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventReminderCreateManyEventInputEnvelope
    set?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
    disconnect?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
    delete?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
    connect?: EventReminderWhereUniqueInput | EventReminderWhereUniqueInput[]
    update?: EventReminderUpdateWithWhereUniqueWithoutEventInput | EventReminderUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventReminderUpdateManyWithWhereWithoutEventInput | EventReminderUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventReminderScalarWhereInput | EventReminderScalarWhereInput[]
  }

  export type EventCreateNestedOneWithoutRemindersInput = {
    create?: XOR<EventCreateWithoutRemindersInput, EventUncheckedCreateWithoutRemindersInput>
    connectOrCreate?: EventCreateOrConnectWithoutRemindersInput
    connect?: EventWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRemindersInput = {
    create?: XOR<UserCreateWithoutRemindersInput, UserUncheckedCreateWithoutRemindersInput>
    connectOrCreate?: UserCreateOrConnectWithoutRemindersInput
    connect?: UserWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutRemindersNestedInput = {
    create?: XOR<EventCreateWithoutRemindersInput, EventUncheckedCreateWithoutRemindersInput>
    connectOrCreate?: EventCreateOrConnectWithoutRemindersInput
    upsert?: EventUpsertWithoutRemindersInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutRemindersInput, EventUpdateWithoutRemindersInput>, EventUncheckedUpdateWithoutRemindersInput>
  }

  export type UserUpdateOneRequiredWithoutRemindersNestedInput = {
    create?: XOR<UserCreateWithoutRemindersInput, UserUncheckedCreateWithoutRemindersInput>
    connectOrCreate?: UserCreateOrConnectWithoutRemindersInput
    upsert?: UserUpsertWithoutRemindersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRemindersInput, UserUpdateWithoutRemindersInput>, UserUncheckedUpdateWithoutRemindersInput>
  }

  export type TicketTierCreatebenefitsInput = {
    set: string[]
  }

  export type EventCreateNestedOneWithoutTicketTiersInput = {
    create?: XOR<EventCreateWithoutTicketTiersInput, EventUncheckedCreateWithoutTicketTiersInput>
    connectOrCreate?: EventCreateOrConnectWithoutTicketTiersInput
    connect?: EventWhereUniqueInput
  }

  export type TicketCreateNestedManyWithoutTierInput = {
    create?: XOR<TicketCreateWithoutTierInput, TicketUncheckedCreateWithoutTierInput> | TicketCreateWithoutTierInput[] | TicketUncheckedCreateWithoutTierInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTierInput | TicketCreateOrConnectWithoutTierInput[]
    createMany?: TicketCreateManyTierInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutTierInput = {
    create?: XOR<TicketCreateWithoutTierInput, TicketUncheckedCreateWithoutTierInput> | TicketCreateWithoutTierInput[] | TicketUncheckedCreateWithoutTierInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTierInput | TicketCreateOrConnectWithoutTierInput[]
    createMany?: TicketCreateManyTierInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TicketTierUpdatebenefitsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EventUpdateOneRequiredWithoutTicketTiersNestedInput = {
    create?: XOR<EventCreateWithoutTicketTiersInput, EventUncheckedCreateWithoutTicketTiersInput>
    connectOrCreate?: EventCreateOrConnectWithoutTicketTiersInput
    upsert?: EventUpsertWithoutTicketTiersInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutTicketTiersInput, EventUpdateWithoutTicketTiersInput>, EventUncheckedUpdateWithoutTicketTiersInput>
  }

  export type TicketUpdateManyWithoutTierNestedInput = {
    create?: XOR<TicketCreateWithoutTierInput, TicketUncheckedCreateWithoutTierInput> | TicketCreateWithoutTierInput[] | TicketUncheckedCreateWithoutTierInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTierInput | TicketCreateOrConnectWithoutTierInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutTierInput | TicketUpsertWithWhereUniqueWithoutTierInput[]
    createMany?: TicketCreateManyTierInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutTierInput | TicketUpdateWithWhereUniqueWithoutTierInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutTierInput | TicketUpdateManyWithWhereWithoutTierInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutTierNestedInput = {
    create?: XOR<TicketCreateWithoutTierInput, TicketUncheckedCreateWithoutTierInput> | TicketCreateWithoutTierInput[] | TicketUncheckedCreateWithoutTierInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTierInput | TicketCreateOrConnectWithoutTierInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutTierInput | TicketUpsertWithWhereUniqueWithoutTierInput[]
    createMany?: TicketCreateManyTierInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutTierInput | TicketUpdateWithWhereUniqueWithoutTierInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutTierInput | TicketUpdateManyWithWhereWithoutTierInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type EventCreateNestedOneWithoutTicketsInput = {
    create?: XOR<EventCreateWithoutTicketsInput, EventUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: EventCreateOrConnectWithoutTicketsInput
    connect?: EventWhereUniqueInput
  }

  export type TicketTierCreateNestedOneWithoutTicketsInput = {
    create?: XOR<TicketTierCreateWithoutTicketsInput, TicketTierUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: TicketTierCreateOrConnectWithoutTicketsInput
    connect?: TicketTierWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicketsInput = {
    create?: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsInput
    connect?: UserWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<EventCreateWithoutTicketsInput, EventUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: EventCreateOrConnectWithoutTicketsInput
    upsert?: EventUpsertWithoutTicketsInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutTicketsInput, EventUpdateWithoutTicketsInput>, EventUncheckedUpdateWithoutTicketsInput>
  }

  export type TicketTierUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<TicketTierCreateWithoutTicketsInput, TicketTierUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: TicketTierCreateOrConnectWithoutTicketsInput
    upsert?: TicketTierUpsertWithoutTicketsInput
    connect?: TicketTierWhereUniqueInput
    update?: XOR<XOR<TicketTierUpdateToOneWithWhereWithoutTicketsInput, TicketTierUpdateWithoutTicketsInput>, TicketTierUncheckedUpdateWithoutTicketsInput>
  }

  export type UserUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsInput
    upsert?: UserUpsertWithoutTicketsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketsInput, UserUpdateWithoutTicketsInput>, UserUncheckedUpdateWithoutTicketsInput>
  }

  export type CommunityPostCreateNestedManyWithoutCommunityInput = {
    create?: XOR<CommunityPostCreateWithoutCommunityInput, CommunityPostUncheckedCreateWithoutCommunityInput> | CommunityPostCreateWithoutCommunityInput[] | CommunityPostUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: CommunityPostCreateOrConnectWithoutCommunityInput | CommunityPostCreateOrConnectWithoutCommunityInput[]
    createMany?: CommunityPostCreateManyCommunityInputEnvelope
    connect?: CommunityPostWhereUniqueInput | CommunityPostWhereUniqueInput[]
  }

  export type CommunityMemberCreateNestedManyWithoutCommunityInput = {
    create?: XOR<CommunityMemberCreateWithoutCommunityInput, CommunityMemberUncheckedCreateWithoutCommunityInput> | CommunityMemberCreateWithoutCommunityInput[] | CommunityMemberUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: CommunityMemberCreateOrConnectWithoutCommunityInput | CommunityMemberCreateOrConnectWithoutCommunityInput[]
    createMany?: CommunityMemberCreateManyCommunityInputEnvelope
    connect?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
  }

  export type GovernanceProposalCreateNestedManyWithoutCommunityInput = {
    create?: XOR<GovernanceProposalCreateWithoutCommunityInput, GovernanceProposalUncheckedCreateWithoutCommunityInput> | GovernanceProposalCreateWithoutCommunityInput[] | GovernanceProposalUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: GovernanceProposalCreateOrConnectWithoutCommunityInput | GovernanceProposalCreateOrConnectWithoutCommunityInput[]
    createMany?: GovernanceProposalCreateManyCommunityInputEnvelope
    connect?: GovernanceProposalWhereUniqueInput | GovernanceProposalWhereUniqueInput[]
  }

  export type CommunityPostUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<CommunityPostCreateWithoutCommunityInput, CommunityPostUncheckedCreateWithoutCommunityInput> | CommunityPostCreateWithoutCommunityInput[] | CommunityPostUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: CommunityPostCreateOrConnectWithoutCommunityInput | CommunityPostCreateOrConnectWithoutCommunityInput[]
    createMany?: CommunityPostCreateManyCommunityInputEnvelope
    connect?: CommunityPostWhereUniqueInput | CommunityPostWhereUniqueInput[]
  }

  export type CommunityMemberUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<CommunityMemberCreateWithoutCommunityInput, CommunityMemberUncheckedCreateWithoutCommunityInput> | CommunityMemberCreateWithoutCommunityInput[] | CommunityMemberUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: CommunityMemberCreateOrConnectWithoutCommunityInput | CommunityMemberCreateOrConnectWithoutCommunityInput[]
    createMany?: CommunityMemberCreateManyCommunityInputEnvelope
    connect?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
  }

  export type GovernanceProposalUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<GovernanceProposalCreateWithoutCommunityInput, GovernanceProposalUncheckedCreateWithoutCommunityInput> | GovernanceProposalCreateWithoutCommunityInput[] | GovernanceProposalUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: GovernanceProposalCreateOrConnectWithoutCommunityInput | GovernanceProposalCreateOrConnectWithoutCommunityInput[]
    createMany?: GovernanceProposalCreateManyCommunityInputEnvelope
    connect?: GovernanceProposalWhereUniqueInput | GovernanceProposalWhereUniqueInput[]
  }

  export type CommunityPostUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<CommunityPostCreateWithoutCommunityInput, CommunityPostUncheckedCreateWithoutCommunityInput> | CommunityPostCreateWithoutCommunityInput[] | CommunityPostUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: CommunityPostCreateOrConnectWithoutCommunityInput | CommunityPostCreateOrConnectWithoutCommunityInput[]
    upsert?: CommunityPostUpsertWithWhereUniqueWithoutCommunityInput | CommunityPostUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: CommunityPostCreateManyCommunityInputEnvelope
    set?: CommunityPostWhereUniqueInput | CommunityPostWhereUniqueInput[]
    disconnect?: CommunityPostWhereUniqueInput | CommunityPostWhereUniqueInput[]
    delete?: CommunityPostWhereUniqueInput | CommunityPostWhereUniqueInput[]
    connect?: CommunityPostWhereUniqueInput | CommunityPostWhereUniqueInput[]
    update?: CommunityPostUpdateWithWhereUniqueWithoutCommunityInput | CommunityPostUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: CommunityPostUpdateManyWithWhereWithoutCommunityInput | CommunityPostUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: CommunityPostScalarWhereInput | CommunityPostScalarWhereInput[]
  }

  export type CommunityMemberUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<CommunityMemberCreateWithoutCommunityInput, CommunityMemberUncheckedCreateWithoutCommunityInput> | CommunityMemberCreateWithoutCommunityInput[] | CommunityMemberUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: CommunityMemberCreateOrConnectWithoutCommunityInput | CommunityMemberCreateOrConnectWithoutCommunityInput[]
    upsert?: CommunityMemberUpsertWithWhereUniqueWithoutCommunityInput | CommunityMemberUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: CommunityMemberCreateManyCommunityInputEnvelope
    set?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    disconnect?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    delete?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    connect?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    update?: CommunityMemberUpdateWithWhereUniqueWithoutCommunityInput | CommunityMemberUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: CommunityMemberUpdateManyWithWhereWithoutCommunityInput | CommunityMemberUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: CommunityMemberScalarWhereInput | CommunityMemberScalarWhereInput[]
  }

  export type GovernanceProposalUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<GovernanceProposalCreateWithoutCommunityInput, GovernanceProposalUncheckedCreateWithoutCommunityInput> | GovernanceProposalCreateWithoutCommunityInput[] | GovernanceProposalUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: GovernanceProposalCreateOrConnectWithoutCommunityInput | GovernanceProposalCreateOrConnectWithoutCommunityInput[]
    upsert?: GovernanceProposalUpsertWithWhereUniqueWithoutCommunityInput | GovernanceProposalUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: GovernanceProposalCreateManyCommunityInputEnvelope
    set?: GovernanceProposalWhereUniqueInput | GovernanceProposalWhereUniqueInput[]
    disconnect?: GovernanceProposalWhereUniqueInput | GovernanceProposalWhereUniqueInput[]
    delete?: GovernanceProposalWhereUniqueInput | GovernanceProposalWhereUniqueInput[]
    connect?: GovernanceProposalWhereUniqueInput | GovernanceProposalWhereUniqueInput[]
    update?: GovernanceProposalUpdateWithWhereUniqueWithoutCommunityInput | GovernanceProposalUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: GovernanceProposalUpdateManyWithWhereWithoutCommunityInput | GovernanceProposalUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: GovernanceProposalScalarWhereInput | GovernanceProposalScalarWhereInput[]
  }

  export type CommunityPostUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<CommunityPostCreateWithoutCommunityInput, CommunityPostUncheckedCreateWithoutCommunityInput> | CommunityPostCreateWithoutCommunityInput[] | CommunityPostUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: CommunityPostCreateOrConnectWithoutCommunityInput | CommunityPostCreateOrConnectWithoutCommunityInput[]
    upsert?: CommunityPostUpsertWithWhereUniqueWithoutCommunityInput | CommunityPostUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: CommunityPostCreateManyCommunityInputEnvelope
    set?: CommunityPostWhereUniqueInput | CommunityPostWhereUniqueInput[]
    disconnect?: CommunityPostWhereUniqueInput | CommunityPostWhereUniqueInput[]
    delete?: CommunityPostWhereUniqueInput | CommunityPostWhereUniqueInput[]
    connect?: CommunityPostWhereUniqueInput | CommunityPostWhereUniqueInput[]
    update?: CommunityPostUpdateWithWhereUniqueWithoutCommunityInput | CommunityPostUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: CommunityPostUpdateManyWithWhereWithoutCommunityInput | CommunityPostUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: CommunityPostScalarWhereInput | CommunityPostScalarWhereInput[]
  }

  export type CommunityMemberUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<CommunityMemberCreateWithoutCommunityInput, CommunityMemberUncheckedCreateWithoutCommunityInput> | CommunityMemberCreateWithoutCommunityInput[] | CommunityMemberUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: CommunityMemberCreateOrConnectWithoutCommunityInput | CommunityMemberCreateOrConnectWithoutCommunityInput[]
    upsert?: CommunityMemberUpsertWithWhereUniqueWithoutCommunityInput | CommunityMemberUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: CommunityMemberCreateManyCommunityInputEnvelope
    set?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    disconnect?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    delete?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    connect?: CommunityMemberWhereUniqueInput | CommunityMemberWhereUniqueInput[]
    update?: CommunityMemberUpdateWithWhereUniqueWithoutCommunityInput | CommunityMemberUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: CommunityMemberUpdateManyWithWhereWithoutCommunityInput | CommunityMemberUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: CommunityMemberScalarWhereInput | CommunityMemberScalarWhereInput[]
  }

  export type GovernanceProposalUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<GovernanceProposalCreateWithoutCommunityInput, GovernanceProposalUncheckedCreateWithoutCommunityInput> | GovernanceProposalCreateWithoutCommunityInput[] | GovernanceProposalUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: GovernanceProposalCreateOrConnectWithoutCommunityInput | GovernanceProposalCreateOrConnectWithoutCommunityInput[]
    upsert?: GovernanceProposalUpsertWithWhereUniqueWithoutCommunityInput | GovernanceProposalUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: GovernanceProposalCreateManyCommunityInputEnvelope
    set?: GovernanceProposalWhereUniqueInput | GovernanceProposalWhereUniqueInput[]
    disconnect?: GovernanceProposalWhereUniqueInput | GovernanceProposalWhereUniqueInput[]
    delete?: GovernanceProposalWhereUniqueInput | GovernanceProposalWhereUniqueInput[]
    connect?: GovernanceProposalWhereUniqueInput | GovernanceProposalWhereUniqueInput[]
    update?: GovernanceProposalUpdateWithWhereUniqueWithoutCommunityInput | GovernanceProposalUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: GovernanceProposalUpdateManyWithWhereWithoutCommunityInput | GovernanceProposalUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: GovernanceProposalScalarWhereInput | GovernanceProposalScalarWhereInput[]
  }

  export type CommunityPostCreateimagesInput = {
    set: string[]
  }

  export type CommunityCreateNestedOneWithoutPostsInput = {
    create?: XOR<CommunityCreateWithoutPostsInput, CommunityUncheckedCreateWithoutPostsInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutPostsInput
    connect?: CommunityWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPostsInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    connect?: UserWhereUniqueInput
  }

  export type PostVoteCreateNestedManyWithoutPostInput = {
    create?: XOR<PostVoteCreateWithoutPostInput, PostVoteUncheckedCreateWithoutPostInput> | PostVoteCreateWithoutPostInput[] | PostVoteUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostVoteCreateOrConnectWithoutPostInput | PostVoteCreateOrConnectWithoutPostInput[]
    createMany?: PostVoteCreateManyPostInputEnvelope
    connect?: PostVoteWhereUniqueInput | PostVoteWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PostVoteUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostVoteCreateWithoutPostInput, PostVoteUncheckedCreateWithoutPostInput> | PostVoteCreateWithoutPostInput[] | PostVoteUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostVoteCreateOrConnectWithoutPostInput | PostVoteCreateOrConnectWithoutPostInput[]
    createMany?: PostVoteCreateManyPostInputEnvelope
    connect?: PostVoteWhereUniqueInput | PostVoteWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommunityPostUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type CommunityUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<CommunityCreateWithoutPostsInput, CommunityUncheckedCreateWithoutPostsInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutPostsInput
    upsert?: CommunityUpsertWithoutPostsInput
    connect?: CommunityWhereUniqueInput
    update?: XOR<XOR<CommunityUpdateToOneWithWhereWithoutPostsInput, CommunityUpdateWithoutPostsInput>, CommunityUncheckedUpdateWithoutPostsInput>
  }

  export type UserUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostsInput
    upsert?: UserUpsertWithoutPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostsInput, UserUpdateWithoutPostsInput>, UserUncheckedUpdateWithoutPostsInput>
  }

  export type PostVoteUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostVoteCreateWithoutPostInput, PostVoteUncheckedCreateWithoutPostInput> | PostVoteCreateWithoutPostInput[] | PostVoteUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostVoteCreateOrConnectWithoutPostInput | PostVoteCreateOrConnectWithoutPostInput[]
    upsert?: PostVoteUpsertWithWhereUniqueWithoutPostInput | PostVoteUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostVoteCreateManyPostInputEnvelope
    set?: PostVoteWhereUniqueInput | PostVoteWhereUniqueInput[]
    disconnect?: PostVoteWhereUniqueInput | PostVoteWhereUniqueInput[]
    delete?: PostVoteWhereUniqueInput | PostVoteWhereUniqueInput[]
    connect?: PostVoteWhereUniqueInput | PostVoteWhereUniqueInput[]
    update?: PostVoteUpdateWithWhereUniqueWithoutPostInput | PostVoteUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostVoteUpdateManyWithWhereWithoutPostInput | PostVoteUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostVoteScalarWhereInput | PostVoteScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PostVoteUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostVoteCreateWithoutPostInput, PostVoteUncheckedCreateWithoutPostInput> | PostVoteCreateWithoutPostInput[] | PostVoteUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostVoteCreateOrConnectWithoutPostInput | PostVoteCreateOrConnectWithoutPostInput[]
    upsert?: PostVoteUpsertWithWhereUniqueWithoutPostInput | PostVoteUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostVoteCreateManyPostInputEnvelope
    set?: PostVoteWhereUniqueInput | PostVoteWhereUniqueInput[]
    disconnect?: PostVoteWhereUniqueInput | PostVoteWhereUniqueInput[]
    delete?: PostVoteWhereUniqueInput | PostVoteWhereUniqueInput[]
    connect?: PostVoteWhereUniqueInput | PostVoteWhereUniqueInput[]
    update?: PostVoteUpdateWithWhereUniqueWithoutPostInput | PostVoteUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostVoteUpdateManyWithWhereWithoutPostInput | PostVoteUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostVoteScalarWhereInput | PostVoteScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommunityPostCreateNestedOneWithoutVotesInput = {
    create?: XOR<CommunityPostCreateWithoutVotesInput, CommunityPostUncheckedCreateWithoutVotesInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutVotesInput
    connect?: CommunityPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPostVotesInput = {
    create?: XOR<UserCreateWithoutPostVotesInput, UserUncheckedCreateWithoutPostVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostVotesInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityPostUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<CommunityPostCreateWithoutVotesInput, CommunityPostUncheckedCreateWithoutVotesInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutVotesInput
    upsert?: CommunityPostUpsertWithoutVotesInput
    connect?: CommunityPostWhereUniqueInput
    update?: XOR<XOR<CommunityPostUpdateToOneWithWhereWithoutVotesInput, CommunityPostUpdateWithoutVotesInput>, CommunityPostUncheckedUpdateWithoutVotesInput>
  }

  export type UserUpdateOneRequiredWithoutPostVotesNestedInput = {
    create?: XOR<UserCreateWithoutPostVotesInput, UserUncheckedCreateWithoutPostVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostVotesInput
    upsert?: UserUpsertWithoutPostVotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostVotesInput, UserUpdateWithoutPostVotesInput>, UserUncheckedUpdateWithoutPostVotesInput>
  }

  export type UserCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type CommunityCreateNestedOneWithoutMembersInput = {
    create?: XOR<CommunityCreateWithoutMembersInput, CommunityUncheckedCreateWithoutMembersInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutMembersInput
    connect?: CommunityWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMembershipsInput
    upsert?: UserUpsertWithoutMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMembershipsInput, UserUpdateWithoutMembershipsInput>, UserUncheckedUpdateWithoutMembershipsInput>
  }

  export type CommunityUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<CommunityCreateWithoutMembersInput, CommunityUncheckedCreateWithoutMembersInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutMembersInput
    upsert?: CommunityUpsertWithoutMembersInput
    connect?: CommunityWhereUniqueInput
    update?: XOR<XOR<CommunityUpdateToOneWithWhereWithoutMembersInput, CommunityUpdateWithoutMembersInput>, CommunityUncheckedUpdateWithoutMembersInput>
  }

  export type CommunityCreateNestedOneWithoutProposalsInput = {
    create?: XOR<CommunityCreateWithoutProposalsInput, CommunityUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutProposalsInput
    connect?: CommunityWhereUniqueInput
  }

  export type ProposalOptionCreateNestedManyWithoutProposalInput = {
    create?: XOR<ProposalOptionCreateWithoutProposalInput, ProposalOptionUncheckedCreateWithoutProposalInput> | ProposalOptionCreateWithoutProposalInput[] | ProposalOptionUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: ProposalOptionCreateOrConnectWithoutProposalInput | ProposalOptionCreateOrConnectWithoutProposalInput[]
    createMany?: ProposalOptionCreateManyProposalInputEnvelope
    connect?: ProposalOptionWhereUniqueInput | ProposalOptionWhereUniqueInput[]
  }

  export type ProposalOptionUncheckedCreateNestedManyWithoutProposalInput = {
    create?: XOR<ProposalOptionCreateWithoutProposalInput, ProposalOptionUncheckedCreateWithoutProposalInput> | ProposalOptionCreateWithoutProposalInput[] | ProposalOptionUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: ProposalOptionCreateOrConnectWithoutProposalInput | ProposalOptionCreateOrConnectWithoutProposalInput[]
    createMany?: ProposalOptionCreateManyProposalInputEnvelope
    connect?: ProposalOptionWhereUniqueInput | ProposalOptionWhereUniqueInput[]
  }

  export type CommunityUpdateOneRequiredWithoutProposalsNestedInput = {
    create?: XOR<CommunityCreateWithoutProposalsInput, CommunityUncheckedCreateWithoutProposalsInput>
    connectOrCreate?: CommunityCreateOrConnectWithoutProposalsInput
    upsert?: CommunityUpsertWithoutProposalsInput
    connect?: CommunityWhereUniqueInput
    update?: XOR<XOR<CommunityUpdateToOneWithWhereWithoutProposalsInput, CommunityUpdateWithoutProposalsInput>, CommunityUncheckedUpdateWithoutProposalsInput>
  }

  export type ProposalOptionUpdateManyWithoutProposalNestedInput = {
    create?: XOR<ProposalOptionCreateWithoutProposalInput, ProposalOptionUncheckedCreateWithoutProposalInput> | ProposalOptionCreateWithoutProposalInput[] | ProposalOptionUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: ProposalOptionCreateOrConnectWithoutProposalInput | ProposalOptionCreateOrConnectWithoutProposalInput[]
    upsert?: ProposalOptionUpsertWithWhereUniqueWithoutProposalInput | ProposalOptionUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: ProposalOptionCreateManyProposalInputEnvelope
    set?: ProposalOptionWhereUniqueInput | ProposalOptionWhereUniqueInput[]
    disconnect?: ProposalOptionWhereUniqueInput | ProposalOptionWhereUniqueInput[]
    delete?: ProposalOptionWhereUniqueInput | ProposalOptionWhereUniqueInput[]
    connect?: ProposalOptionWhereUniqueInput | ProposalOptionWhereUniqueInput[]
    update?: ProposalOptionUpdateWithWhereUniqueWithoutProposalInput | ProposalOptionUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: ProposalOptionUpdateManyWithWhereWithoutProposalInput | ProposalOptionUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: ProposalOptionScalarWhereInput | ProposalOptionScalarWhereInput[]
  }

  export type ProposalOptionUncheckedUpdateManyWithoutProposalNestedInput = {
    create?: XOR<ProposalOptionCreateWithoutProposalInput, ProposalOptionUncheckedCreateWithoutProposalInput> | ProposalOptionCreateWithoutProposalInput[] | ProposalOptionUncheckedCreateWithoutProposalInput[]
    connectOrCreate?: ProposalOptionCreateOrConnectWithoutProposalInput | ProposalOptionCreateOrConnectWithoutProposalInput[]
    upsert?: ProposalOptionUpsertWithWhereUniqueWithoutProposalInput | ProposalOptionUpsertWithWhereUniqueWithoutProposalInput[]
    createMany?: ProposalOptionCreateManyProposalInputEnvelope
    set?: ProposalOptionWhereUniqueInput | ProposalOptionWhereUniqueInput[]
    disconnect?: ProposalOptionWhereUniqueInput | ProposalOptionWhereUniqueInput[]
    delete?: ProposalOptionWhereUniqueInput | ProposalOptionWhereUniqueInput[]
    connect?: ProposalOptionWhereUniqueInput | ProposalOptionWhereUniqueInput[]
    update?: ProposalOptionUpdateWithWhereUniqueWithoutProposalInput | ProposalOptionUpdateWithWhereUniqueWithoutProposalInput[]
    updateMany?: ProposalOptionUpdateManyWithWhereWithoutProposalInput | ProposalOptionUpdateManyWithWhereWithoutProposalInput[]
    deleteMany?: ProposalOptionScalarWhereInput | ProposalOptionScalarWhereInput[]
  }

  export type GovernanceProposalCreateNestedOneWithoutOptionsInput = {
    create?: XOR<GovernanceProposalCreateWithoutOptionsInput, GovernanceProposalUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: GovernanceProposalCreateOrConnectWithoutOptionsInput
    connect?: GovernanceProposalWhereUniqueInput
  }

  export type GovernanceProposalUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<GovernanceProposalCreateWithoutOptionsInput, GovernanceProposalUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: GovernanceProposalCreateOrConnectWithoutOptionsInput
    upsert?: GovernanceProposalUpsertWithoutOptionsInput
    connect?: GovernanceProposalWhereUniqueInput
    update?: XOR<XOR<GovernanceProposalUpdateToOneWithWhereWithoutOptionsInput, GovernanceProposalUpdateWithoutOptionsInput>, GovernanceProposalUncheckedUpdateWithoutOptionsInput>
  }

  export type CommunityPostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<CommunityPostCreateWithoutCommentsInput, CommunityPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutCommentsInput
    connect?: CommunityPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutChildrenInput = {
    create?: XOR<CommentCreateWithoutChildrenInput, CommentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CommentCreateOrConnectWithoutChildrenInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentVoteCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentVoteCreateWithoutCommentInput, CommentVoteUncheckedCreateWithoutCommentInput> | CommentVoteCreateWithoutCommentInput[] | CommentVoteUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentVoteCreateOrConnectWithoutCommentInput | CommentVoteCreateOrConnectWithoutCommentInput[]
    createMany?: CommentVoteCreateManyCommentInputEnvelope
    connect?: CommentVoteWhereUniqueInput | CommentVoteWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentVoteUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentVoteCreateWithoutCommentInput, CommentVoteUncheckedCreateWithoutCommentInput> | CommentVoteCreateWithoutCommentInput[] | CommentVoteUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentVoteCreateOrConnectWithoutCommentInput | CommentVoteCreateOrConnectWithoutCommentInput[]
    createMany?: CommentVoteCreateManyCommentInputEnvelope
    connect?: CommentVoteWhereUniqueInput | CommentVoteWhereUniqueInput[]
  }

  export type CommunityPostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<CommunityPostCreateWithoutCommentsInput, CommunityPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: CommunityPostCreateOrConnectWithoutCommentsInput
    upsert?: CommunityPostUpsertWithoutCommentsInput
    connect?: CommunityPostWhereUniqueInput
    update?: XOR<XOR<CommunityPostUpdateToOneWithWhereWithoutCommentsInput, CommunityPostUpdateWithoutCommentsInput>, CommunityPostUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<CommentCreateWithoutChildrenInput, CommentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CommentCreateOrConnectWithoutChildrenInput
    upsert?: CommentUpsertWithoutChildrenInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutChildrenInput, CommentUpdateWithoutChildrenInput>, CommentUncheckedUpdateWithoutChildrenInput>
  }

  export type CommentUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentVoteUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentVoteCreateWithoutCommentInput, CommentVoteUncheckedCreateWithoutCommentInput> | CommentVoteCreateWithoutCommentInput[] | CommentVoteUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentVoteCreateOrConnectWithoutCommentInput | CommentVoteCreateOrConnectWithoutCommentInput[]
    upsert?: CommentVoteUpsertWithWhereUniqueWithoutCommentInput | CommentVoteUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentVoteCreateManyCommentInputEnvelope
    set?: CommentVoteWhereUniqueInput | CommentVoteWhereUniqueInput[]
    disconnect?: CommentVoteWhereUniqueInput | CommentVoteWhereUniqueInput[]
    delete?: CommentVoteWhereUniqueInput | CommentVoteWhereUniqueInput[]
    connect?: CommentVoteWhereUniqueInput | CommentVoteWhereUniqueInput[]
    update?: CommentVoteUpdateWithWhereUniqueWithoutCommentInput | CommentVoteUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentVoteUpdateManyWithWhereWithoutCommentInput | CommentVoteUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentVoteScalarWhereInput | CommentVoteScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput> | CommentCreateWithoutParentInput[] | CommentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentInput | CommentCreateOrConnectWithoutParentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentInput | CommentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CommentCreateManyParentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentInput | CommentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentInput | CommentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentVoteUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentVoteCreateWithoutCommentInput, CommentVoteUncheckedCreateWithoutCommentInput> | CommentVoteCreateWithoutCommentInput[] | CommentVoteUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentVoteCreateOrConnectWithoutCommentInput | CommentVoteCreateOrConnectWithoutCommentInput[]
    upsert?: CommentVoteUpsertWithWhereUniqueWithoutCommentInput | CommentVoteUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentVoteCreateManyCommentInputEnvelope
    set?: CommentVoteWhereUniqueInput | CommentVoteWhereUniqueInput[]
    disconnect?: CommentVoteWhereUniqueInput | CommentVoteWhereUniqueInput[]
    delete?: CommentVoteWhereUniqueInput | CommentVoteWhereUniqueInput[]
    connect?: CommentVoteWhereUniqueInput | CommentVoteWhereUniqueInput[]
    update?: CommentVoteUpdateWithWhereUniqueWithoutCommentInput | CommentVoteUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentVoteUpdateManyWithWhereWithoutCommentInput | CommentVoteUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentVoteScalarWhereInput | CommentVoteScalarWhereInput[]
  }

  export type CommentCreateNestedOneWithoutVotesInput = {
    create?: XOR<CommentCreateWithoutVotesInput, CommentUncheckedCreateWithoutVotesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutVotesInput
    connect?: CommentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentVotesInput = {
    create?: XOR<UserCreateWithoutCommentVotesInput, UserUncheckedCreateWithoutCommentVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentVotesInput
    connect?: UserWhereUniqueInput
  }

  export type CommentUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<CommentCreateWithoutVotesInput, CommentUncheckedCreateWithoutVotesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutVotesInput
    upsert?: CommentUpsertWithoutVotesInput
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutVotesInput, CommentUpdateWithoutVotesInput>, CommentUncheckedUpdateWithoutVotesInput>
  }

  export type UserUpdateOneRequiredWithoutCommentVotesNestedInput = {
    create?: XOR<UserCreateWithoutCommentVotesInput, UserUncheckedCreateWithoutCommentVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentVotesInput
    upsert?: UserUpsertWithoutCommentVotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentVotesInput, UserUpdateWithoutCommentVotesInput>, UserUncheckedUpdateWithoutCommentVotesInput>
  }

  export type QuizQuestionCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
  }

  export type QuizAttemptCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput> | QuizAttemptCreateWithoutQuizInput[] | QuizAttemptUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutQuizInput | QuizAttemptCreateOrConnectWithoutQuizInput[]
    createMany?: QuizAttemptCreateManyQuizInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type QuizQuestionUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
  }

  export type QuizAttemptUncheckedCreateNestedManyWithoutQuizInput = {
    create?: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput> | QuizAttemptCreateWithoutQuizInput[] | QuizAttemptUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutQuizInput | QuizAttemptCreateOrConnectWithoutQuizInput[]
    createMany?: QuizAttemptCreateManyQuizInputEnvelope
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type QuizQuestionUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    upsert?: QuizQuestionUpsertWithWhereUniqueWithoutQuizInput | QuizQuestionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    set?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    disconnect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    delete?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    update?: QuizQuestionUpdateWithWhereUniqueWithoutQuizInput | QuizQuestionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizQuestionUpdateManyWithWhereWithoutQuizInput | QuizQuestionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
  }

  export type QuizAttemptUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput> | QuizAttemptCreateWithoutQuizInput[] | QuizAttemptUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutQuizInput | QuizAttemptCreateOrConnectWithoutQuizInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutQuizInput | QuizAttemptUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizAttemptCreateManyQuizInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutQuizInput | QuizAttemptUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutQuizInput | QuizAttemptUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput> | QuizQuestionCreateWithoutQuizInput[] | QuizQuestionUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizQuestionCreateOrConnectWithoutQuizInput | QuizQuestionCreateOrConnectWithoutQuizInput[]
    upsert?: QuizQuestionUpsertWithWhereUniqueWithoutQuizInput | QuizQuestionUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizQuestionCreateManyQuizInputEnvelope
    set?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    disconnect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    delete?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    connect?: QuizQuestionWhereUniqueInput | QuizQuestionWhereUniqueInput[]
    update?: QuizQuestionUpdateWithWhereUniqueWithoutQuizInput | QuizQuestionUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizQuestionUpdateManyWithWhereWithoutQuizInput | QuizQuestionUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
  }

  export type QuizAttemptUncheckedUpdateManyWithoutQuizNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput> | QuizAttemptCreateWithoutQuizInput[] | QuizAttemptUncheckedCreateWithoutQuizInput[]
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutQuizInput | QuizAttemptCreateOrConnectWithoutQuizInput[]
    upsert?: QuizAttemptUpsertWithWhereUniqueWithoutQuizInput | QuizAttemptUpsertWithWhereUniqueWithoutQuizInput[]
    createMany?: QuizAttemptCreateManyQuizInputEnvelope
    set?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    disconnect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    delete?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    connect?: QuizAttemptWhereUniqueInput | QuizAttemptWhereUniqueInput[]
    update?: QuizAttemptUpdateWithWhereUniqueWithoutQuizInput | QuizAttemptUpdateWithWhereUniqueWithoutQuizInput[]
    updateMany?: QuizAttemptUpdateManyWithWhereWithoutQuizInput | QuizAttemptUpdateManyWithWhereWithoutQuizInput[]
    deleteMany?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
  }

  export type QuizQuestionCreateoptionsInput = {
    set: string[]
  }

  export type QuizCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutQuestionsInput
    connect?: QuizWhereUniqueInput
  }

  export type QuizQuestionUpdateoptionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type QuizUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutQuestionsInput
    upsert?: QuizUpsertWithoutQuestionsInput
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutQuestionsInput, QuizUpdateWithoutQuestionsInput>, QuizUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuizCreateNestedOneWithoutAttemptsInput = {
    create?: XOR<QuizCreateWithoutAttemptsInput, QuizUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutAttemptsInput
    connect?: QuizWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutQuizAttemptsInput = {
    create?: XOR<UserCreateWithoutQuizAttemptsInput, UserUncheckedCreateWithoutQuizAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuizAttemptsInput
    connect?: UserWhereUniqueInput
  }

  export type QuizResponseCreateNestedManyWithoutAttemptInput = {
    create?: XOR<QuizResponseCreateWithoutAttemptInput, QuizResponseUncheckedCreateWithoutAttemptInput> | QuizResponseCreateWithoutAttemptInput[] | QuizResponseUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: QuizResponseCreateOrConnectWithoutAttemptInput | QuizResponseCreateOrConnectWithoutAttemptInput[]
    createMany?: QuizResponseCreateManyAttemptInputEnvelope
    connect?: QuizResponseWhereUniqueInput | QuizResponseWhereUniqueInput[]
  }

  export type QuizResponseUncheckedCreateNestedManyWithoutAttemptInput = {
    create?: XOR<QuizResponseCreateWithoutAttemptInput, QuizResponseUncheckedCreateWithoutAttemptInput> | QuizResponseCreateWithoutAttemptInput[] | QuizResponseUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: QuizResponseCreateOrConnectWithoutAttemptInput | QuizResponseCreateOrConnectWithoutAttemptInput[]
    createMany?: QuizResponseCreateManyAttemptInputEnvelope
    connect?: QuizResponseWhereUniqueInput | QuizResponseWhereUniqueInput[]
  }

  export type QuizUpdateOneRequiredWithoutAttemptsNestedInput = {
    create?: XOR<QuizCreateWithoutAttemptsInput, QuizUncheckedCreateWithoutAttemptsInput>
    connectOrCreate?: QuizCreateOrConnectWithoutAttemptsInput
    upsert?: QuizUpsertWithoutAttemptsInput
    connect?: QuizWhereUniqueInput
    update?: XOR<XOR<QuizUpdateToOneWithWhereWithoutAttemptsInput, QuizUpdateWithoutAttemptsInput>, QuizUncheckedUpdateWithoutAttemptsInput>
  }

  export type UserUpdateOneRequiredWithoutQuizAttemptsNestedInput = {
    create?: XOR<UserCreateWithoutQuizAttemptsInput, UserUncheckedCreateWithoutQuizAttemptsInput>
    connectOrCreate?: UserCreateOrConnectWithoutQuizAttemptsInput
    upsert?: UserUpsertWithoutQuizAttemptsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutQuizAttemptsInput, UserUpdateWithoutQuizAttemptsInput>, UserUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type QuizResponseUpdateManyWithoutAttemptNestedInput = {
    create?: XOR<QuizResponseCreateWithoutAttemptInput, QuizResponseUncheckedCreateWithoutAttemptInput> | QuizResponseCreateWithoutAttemptInput[] | QuizResponseUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: QuizResponseCreateOrConnectWithoutAttemptInput | QuizResponseCreateOrConnectWithoutAttemptInput[]
    upsert?: QuizResponseUpsertWithWhereUniqueWithoutAttemptInput | QuizResponseUpsertWithWhereUniqueWithoutAttemptInput[]
    createMany?: QuizResponseCreateManyAttemptInputEnvelope
    set?: QuizResponseWhereUniqueInput | QuizResponseWhereUniqueInput[]
    disconnect?: QuizResponseWhereUniqueInput | QuizResponseWhereUniqueInput[]
    delete?: QuizResponseWhereUniqueInput | QuizResponseWhereUniqueInput[]
    connect?: QuizResponseWhereUniqueInput | QuizResponseWhereUniqueInput[]
    update?: QuizResponseUpdateWithWhereUniqueWithoutAttemptInput | QuizResponseUpdateWithWhereUniqueWithoutAttemptInput[]
    updateMany?: QuizResponseUpdateManyWithWhereWithoutAttemptInput | QuizResponseUpdateManyWithWhereWithoutAttemptInput[]
    deleteMany?: QuizResponseScalarWhereInput | QuizResponseScalarWhereInput[]
  }

  export type QuizResponseUncheckedUpdateManyWithoutAttemptNestedInput = {
    create?: XOR<QuizResponseCreateWithoutAttemptInput, QuizResponseUncheckedCreateWithoutAttemptInput> | QuizResponseCreateWithoutAttemptInput[] | QuizResponseUncheckedCreateWithoutAttemptInput[]
    connectOrCreate?: QuizResponseCreateOrConnectWithoutAttemptInput | QuizResponseCreateOrConnectWithoutAttemptInput[]
    upsert?: QuizResponseUpsertWithWhereUniqueWithoutAttemptInput | QuizResponseUpsertWithWhereUniqueWithoutAttemptInput[]
    createMany?: QuizResponseCreateManyAttemptInputEnvelope
    set?: QuizResponseWhereUniqueInput | QuizResponseWhereUniqueInput[]
    disconnect?: QuizResponseWhereUniqueInput | QuizResponseWhereUniqueInput[]
    delete?: QuizResponseWhereUniqueInput | QuizResponseWhereUniqueInput[]
    connect?: QuizResponseWhereUniqueInput | QuizResponseWhereUniqueInput[]
    update?: QuizResponseUpdateWithWhereUniqueWithoutAttemptInput | QuizResponseUpdateWithWhereUniqueWithoutAttemptInput[]
    updateMany?: QuizResponseUpdateManyWithWhereWithoutAttemptInput | QuizResponseUpdateManyWithWhereWithoutAttemptInput[]
    deleteMany?: QuizResponseScalarWhereInput | QuizResponseScalarWhereInput[]
  }

  export type QuizAttemptCreateNestedOneWithoutResponsesInput = {
    create?: XOR<QuizAttemptCreateWithoutResponsesInput, QuizAttemptUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutResponsesInput
    connect?: QuizAttemptWhereUniqueInput
  }

  export type QuizAttemptUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<QuizAttemptCreateWithoutResponsesInput, QuizAttemptUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: QuizAttemptCreateOrConnectWithoutResponsesInput
    upsert?: QuizAttemptUpsertWithoutResponsesInput
    connect?: QuizAttemptWhereUniqueInput
    update?: XOR<XOR<QuizAttemptUpdateToOneWithWhereWithoutResponsesInput, QuizAttemptUpdateWithoutResponsesInput>, QuizAttemptUncheckedUpdateWithoutResponsesInput>
  }

  export type UserCreateNestedOneWithoutFanIQBadgesInput = {
    create?: XOR<UserCreateWithoutFanIQBadgesInput, UserUncheckedCreateWithoutFanIQBadgesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFanIQBadgesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFanIQBadgesNestedInput = {
    create?: XOR<UserCreateWithoutFanIQBadgesInput, UserUncheckedCreateWithoutFanIQBadgesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFanIQBadgesInput
    upsert?: UserUpsertWithoutFanIQBadgesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFanIQBadgesInput, UserUpdateWithoutFanIQBadgesInput>, UserUncheckedUpdateWithoutFanIQBadgesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type TicketCreateWithoutOwnerInput = {
    id?: string
    originalPrice: number
    currentPrice: number
    purchaseDate?: Date | string
    status?: string
    qrCode?: string | null
    tokenId?: string | null
    txHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutTicketsInput
    tier: TicketTierCreateNestedOneWithoutTicketsInput
  }

  export type TicketUncheckedCreateWithoutOwnerInput = {
    id?: string
    eventId: string
    tierId: string
    originalPrice: number
    currentPrice: number
    purchaseDate?: Date | string
    status?: string
    qrCode?: string | null
    tokenId?: string | null
    txHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCreateOrConnectWithoutOwnerInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutOwnerInput, TicketUncheckedCreateWithoutOwnerInput>
  }

  export type TicketCreateManyOwnerInputEnvelope = {
    data: TicketCreateManyOwnerInput | TicketCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type CommunityPostCreateWithoutAuthorInput = {
    id?: string
    title: string
    content: string
    type?: string
    images?: CommunityPostCreateimagesInput | string[]
    upvotes?: number
    downvotes?: number
    commentCount?: number
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    community: CommunityCreateNestedOneWithoutPostsInput
    votes?: PostVoteCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
  }

  export type CommunityPostUncheckedCreateWithoutAuthorInput = {
    id?: string
    communityId: string
    title: string
    content: string
    type?: string
    images?: CommunityPostCreateimagesInput | string[]
    upvotes?: number
    downvotes?: number
    commentCount?: number
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: PostVoteUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type CommunityPostCreateOrConnectWithoutAuthorInput = {
    where: CommunityPostWhereUniqueInput
    create: XOR<CommunityPostCreateWithoutAuthorInput, CommunityPostUncheckedCreateWithoutAuthorInput>
  }

  export type CommunityPostCreateManyAuthorInputEnvelope = {
    data: CommunityPostCreateManyAuthorInput | CommunityPostCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type CommunityMemberCreateWithoutUserInput = {
    id?: string
    role?: string
    reputationPoints?: number
    votingPower?: number
    isActive?: boolean
    joinedAt?: Date | string
    community: CommunityCreateNestedOneWithoutMembersInput
  }

  export type CommunityMemberUncheckedCreateWithoutUserInput = {
    id?: string
    communityId: string
    role?: string
    reputationPoints?: number
    votingPower?: number
    isActive?: boolean
    joinedAt?: Date | string
  }

  export type CommunityMemberCreateOrConnectWithoutUserInput = {
    where: CommunityMemberWhereUniqueInput
    create: XOR<CommunityMemberCreateWithoutUserInput, CommunityMemberUncheckedCreateWithoutUserInput>
  }

  export type CommunityMemberCreateManyUserInputEnvelope = {
    data: CommunityMemberCreateManyUserInput | CommunityMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PostVoteCreateWithoutUserInput = {
    id?: string
    type: string
    createdAt?: Date | string
    post: CommunityPostCreateNestedOneWithoutVotesInput
  }

  export type PostVoteUncheckedCreateWithoutUserInput = {
    id?: string
    postId: string
    type: string
    createdAt?: Date | string
  }

  export type PostVoteCreateOrConnectWithoutUserInput = {
    where: PostVoteWhereUniqueInput
    create: XOR<PostVoteCreateWithoutUserInput, PostVoteUncheckedCreateWithoutUserInput>
  }

  export type PostVoteCreateManyUserInputEnvelope = {
    data: PostVoteCreateManyUserInput | PostVoteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutAuthorInput = {
    id?: string
    content: string
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    post: CommunityPostCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutChildrenInput
    children?: CommentCreateNestedManyWithoutParentInput
    votes?: CommentVoteCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutAuthorInput = {
    id?: string
    content: string
    postId: string
    parentId?: string | null
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CommentUncheckedCreateNestedManyWithoutParentInput
    votes?: CommentVoteUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentCreateManyAuthorInputEnvelope = {
    data: CommentCreateManyAuthorInput | CommentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type CommentVoteCreateWithoutUserInput = {
    id?: string
    type: string
    createdAt?: Date | string
    comment: CommentCreateNestedOneWithoutVotesInput
  }

  export type CommentVoteUncheckedCreateWithoutUserInput = {
    id?: string
    commentId: string
    type: string
    createdAt?: Date | string
  }

  export type CommentVoteCreateOrConnectWithoutUserInput = {
    where: CommentVoteWhereUniqueInput
    create: XOR<CommentVoteCreateWithoutUserInput, CommentVoteUncheckedCreateWithoutUserInput>
  }

  export type CommentVoteCreateManyUserInputEnvelope = {
    data: CommentVoteCreateManyUserInput | CommentVoteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EventReminderCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    event: EventCreateNestedOneWithoutRemindersInput
  }

  export type EventReminderUncheckedCreateWithoutUserInput = {
    id?: string
    eventId: string
    createdAt?: Date | string
  }

  export type EventReminderCreateOrConnectWithoutUserInput = {
    where: EventReminderWhereUniqueInput
    create: XOR<EventReminderCreateWithoutUserInput, EventReminderUncheckedCreateWithoutUserInput>
  }

  export type EventReminderCreateManyUserInputEnvelope = {
    data: EventReminderCreateManyUserInput | EventReminderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type QuizAttemptCreateWithoutUserInput = {
    id?: string
    correctAnswers?: number
    totalQuestions: number
    avgResponseTime?: number
    responseTimeStdDev?: number
    streak?: number
    maxStreak?: number
    finalScore?: number
    speedScore?: number
    accuracyScore?: number
    consistencyScore?: number
    rank?: number | null
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    quiz: QuizCreateNestedOneWithoutAttemptsInput
    responses?: QuizResponseCreateNestedManyWithoutAttemptInput
  }

  export type QuizAttemptUncheckedCreateWithoutUserInput = {
    id?: string
    quizId: string
    correctAnswers?: number
    totalQuestions: number
    avgResponseTime?: number
    responseTimeStdDev?: number
    streak?: number
    maxStreak?: number
    finalScore?: number
    speedScore?: number
    accuracyScore?: number
    consistencyScore?: number
    rank?: number | null
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    responses?: QuizResponseUncheckedCreateNestedManyWithoutAttemptInput
  }

  export type QuizAttemptCreateOrConnectWithoutUserInput = {
    where: QuizAttemptWhereUniqueInput
    create: XOR<QuizAttemptCreateWithoutUserInput, QuizAttemptUncheckedCreateWithoutUserInput>
  }

  export type QuizAttemptCreateManyUserInputEnvelope = {
    data: QuizAttemptCreateManyUserInput | QuizAttemptCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FanIQBadgeCreateWithoutUserInput = {
    id?: string
    tier: string
    artistId: string
    artistName: string
    tokenId?: string | null
    txHash?: string | null
    earnedAt?: Date | string
  }

  export type FanIQBadgeUncheckedCreateWithoutUserInput = {
    id?: string
    tier: string
    artistId: string
    artistName: string
    tokenId?: string | null
    txHash?: string | null
    earnedAt?: Date | string
  }

  export type FanIQBadgeCreateOrConnectWithoutUserInput = {
    where: FanIQBadgeWhereUniqueInput
    create: XOR<FanIQBadgeCreateWithoutUserInput, FanIQBadgeUncheckedCreateWithoutUserInput>
  }

  export type FanIQBadgeCreateManyUserInputEnvelope = {
    data: FanIQBadgeCreateManyUserInput | FanIQBadgeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TicketUpsertWithWhereUniqueWithoutOwnerInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutOwnerInput, TicketUncheckedUpdateWithoutOwnerInput>
    create: XOR<TicketCreateWithoutOwnerInput, TicketUncheckedCreateWithoutOwnerInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutOwnerInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutOwnerInput, TicketUncheckedUpdateWithoutOwnerInput>
  }

  export type TicketUpdateManyWithWhereWithoutOwnerInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutOwnerInput>
  }

  export type TicketScalarWhereInput = {
    AND?: TicketScalarWhereInput | TicketScalarWhereInput[]
    OR?: TicketScalarWhereInput[]
    NOT?: TicketScalarWhereInput | TicketScalarWhereInput[]
    id?: StringFilter<"Ticket"> | string
    eventId?: StringFilter<"Ticket"> | string
    tierId?: StringFilter<"Ticket"> | string
    ownerId?: StringFilter<"Ticket"> | string
    originalPrice?: FloatFilter<"Ticket"> | number
    currentPrice?: FloatFilter<"Ticket"> | number
    purchaseDate?: DateTimeFilter<"Ticket"> | Date | string
    status?: StringFilter<"Ticket"> | string
    qrCode?: StringNullableFilter<"Ticket"> | string | null
    tokenId?: StringNullableFilter<"Ticket"> | string | null
    txHash?: StringNullableFilter<"Ticket"> | string | null
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
  }

  export type CommunityPostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommunityPostWhereUniqueInput
    update: XOR<CommunityPostUpdateWithoutAuthorInput, CommunityPostUncheckedUpdateWithoutAuthorInput>
    create: XOR<CommunityPostCreateWithoutAuthorInput, CommunityPostUncheckedCreateWithoutAuthorInput>
  }

  export type CommunityPostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommunityPostWhereUniqueInput
    data: XOR<CommunityPostUpdateWithoutAuthorInput, CommunityPostUncheckedUpdateWithoutAuthorInput>
  }

  export type CommunityPostUpdateManyWithWhereWithoutAuthorInput = {
    where: CommunityPostScalarWhereInput
    data: XOR<CommunityPostUpdateManyMutationInput, CommunityPostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CommunityPostScalarWhereInput = {
    AND?: CommunityPostScalarWhereInput | CommunityPostScalarWhereInput[]
    OR?: CommunityPostScalarWhereInput[]
    NOT?: CommunityPostScalarWhereInput | CommunityPostScalarWhereInput[]
    id?: StringFilter<"CommunityPost"> | string
    communityId?: StringFilter<"CommunityPost"> | string
    authorId?: StringFilter<"CommunityPost"> | string
    title?: StringFilter<"CommunityPost"> | string
    content?: StringFilter<"CommunityPost"> | string
    type?: StringFilter<"CommunityPost"> | string
    images?: StringNullableListFilter<"CommunityPost">
    upvotes?: IntFilter<"CommunityPost"> | number
    downvotes?: IntFilter<"CommunityPost"> | number
    commentCount?: IntFilter<"CommunityPost"> | number
    isPinned?: BoolFilter<"CommunityPost"> | boolean
    createdAt?: DateTimeFilter<"CommunityPost"> | Date | string
    updatedAt?: DateTimeFilter<"CommunityPost"> | Date | string
  }

  export type CommunityMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: CommunityMemberWhereUniqueInput
    update: XOR<CommunityMemberUpdateWithoutUserInput, CommunityMemberUncheckedUpdateWithoutUserInput>
    create: XOR<CommunityMemberCreateWithoutUserInput, CommunityMemberUncheckedCreateWithoutUserInput>
  }

  export type CommunityMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: CommunityMemberWhereUniqueInput
    data: XOR<CommunityMemberUpdateWithoutUserInput, CommunityMemberUncheckedUpdateWithoutUserInput>
  }

  export type CommunityMemberUpdateManyWithWhereWithoutUserInput = {
    where: CommunityMemberScalarWhereInput
    data: XOR<CommunityMemberUpdateManyMutationInput, CommunityMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type CommunityMemberScalarWhereInput = {
    AND?: CommunityMemberScalarWhereInput | CommunityMemberScalarWhereInput[]
    OR?: CommunityMemberScalarWhereInput[]
    NOT?: CommunityMemberScalarWhereInput | CommunityMemberScalarWhereInput[]
    id?: StringFilter<"CommunityMember"> | string
    userId?: StringFilter<"CommunityMember"> | string
    communityId?: StringFilter<"CommunityMember"> | string
    role?: StringFilter<"CommunityMember"> | string
    reputationPoints?: IntFilter<"CommunityMember"> | number
    votingPower?: IntFilter<"CommunityMember"> | number
    isActive?: BoolFilter<"CommunityMember"> | boolean
    joinedAt?: DateTimeFilter<"CommunityMember"> | Date | string
  }

  export type PostVoteUpsertWithWhereUniqueWithoutUserInput = {
    where: PostVoteWhereUniqueInput
    update: XOR<PostVoteUpdateWithoutUserInput, PostVoteUncheckedUpdateWithoutUserInput>
    create: XOR<PostVoteCreateWithoutUserInput, PostVoteUncheckedCreateWithoutUserInput>
  }

  export type PostVoteUpdateWithWhereUniqueWithoutUserInput = {
    where: PostVoteWhereUniqueInput
    data: XOR<PostVoteUpdateWithoutUserInput, PostVoteUncheckedUpdateWithoutUserInput>
  }

  export type PostVoteUpdateManyWithWhereWithoutUserInput = {
    where: PostVoteScalarWhereInput
    data: XOR<PostVoteUpdateManyMutationInput, PostVoteUncheckedUpdateManyWithoutUserInput>
  }

  export type PostVoteScalarWhereInput = {
    AND?: PostVoteScalarWhereInput | PostVoteScalarWhereInput[]
    OR?: PostVoteScalarWhereInput[]
    NOT?: PostVoteScalarWhereInput | PostVoteScalarWhereInput[]
    id?: StringFilter<"PostVote"> | string
    postId?: StringFilter<"PostVote"> | string
    userId?: StringFilter<"PostVote"> | string
    type?: StringFilter<"PostVote"> | string
    createdAt?: DateTimeFilter<"PostVote"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
  }

  export type CommentUpdateManyWithWhereWithoutAuthorInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    content?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    parentId?: StringNullableFilter<"Comment"> | string | null
    upvotes?: IntFilter<"Comment"> | number
    downvotes?: IntFilter<"Comment"> | number
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type CommentVoteUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentVoteWhereUniqueInput
    update: XOR<CommentVoteUpdateWithoutUserInput, CommentVoteUncheckedUpdateWithoutUserInput>
    create: XOR<CommentVoteCreateWithoutUserInput, CommentVoteUncheckedCreateWithoutUserInput>
  }

  export type CommentVoteUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentVoteWhereUniqueInput
    data: XOR<CommentVoteUpdateWithoutUserInput, CommentVoteUncheckedUpdateWithoutUserInput>
  }

  export type CommentVoteUpdateManyWithWhereWithoutUserInput = {
    where: CommentVoteScalarWhereInput
    data: XOR<CommentVoteUpdateManyMutationInput, CommentVoteUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentVoteScalarWhereInput = {
    AND?: CommentVoteScalarWhereInput | CommentVoteScalarWhereInput[]
    OR?: CommentVoteScalarWhereInput[]
    NOT?: CommentVoteScalarWhereInput | CommentVoteScalarWhereInput[]
    id?: StringFilter<"CommentVote"> | string
    commentId?: StringFilter<"CommentVote"> | string
    userId?: StringFilter<"CommentVote"> | string
    type?: StringFilter<"CommentVote"> | string
    createdAt?: DateTimeFilter<"CommentVote"> | Date | string
  }

  export type EventReminderUpsertWithWhereUniqueWithoutUserInput = {
    where: EventReminderWhereUniqueInput
    update: XOR<EventReminderUpdateWithoutUserInput, EventReminderUncheckedUpdateWithoutUserInput>
    create: XOR<EventReminderCreateWithoutUserInput, EventReminderUncheckedCreateWithoutUserInput>
  }

  export type EventReminderUpdateWithWhereUniqueWithoutUserInput = {
    where: EventReminderWhereUniqueInput
    data: XOR<EventReminderUpdateWithoutUserInput, EventReminderUncheckedUpdateWithoutUserInput>
  }

  export type EventReminderUpdateManyWithWhereWithoutUserInput = {
    where: EventReminderScalarWhereInput
    data: XOR<EventReminderUpdateManyMutationInput, EventReminderUncheckedUpdateManyWithoutUserInput>
  }

  export type EventReminderScalarWhereInput = {
    AND?: EventReminderScalarWhereInput | EventReminderScalarWhereInput[]
    OR?: EventReminderScalarWhereInput[]
    NOT?: EventReminderScalarWhereInput | EventReminderScalarWhereInput[]
    id?: StringFilter<"EventReminder"> | string
    eventId?: StringFilter<"EventReminder"> | string
    userId?: StringFilter<"EventReminder"> | string
    createdAt?: DateTimeFilter<"EventReminder"> | Date | string
  }

  export type QuizAttemptUpsertWithWhereUniqueWithoutUserInput = {
    where: QuizAttemptWhereUniqueInput
    update: XOR<QuizAttemptUpdateWithoutUserInput, QuizAttemptUncheckedUpdateWithoutUserInput>
    create: XOR<QuizAttemptCreateWithoutUserInput, QuizAttemptUncheckedCreateWithoutUserInput>
  }

  export type QuizAttemptUpdateWithWhereUniqueWithoutUserInput = {
    where: QuizAttemptWhereUniqueInput
    data: XOR<QuizAttemptUpdateWithoutUserInput, QuizAttemptUncheckedUpdateWithoutUserInput>
  }

  export type QuizAttemptUpdateManyWithWhereWithoutUserInput = {
    where: QuizAttemptScalarWhereInput
    data: XOR<QuizAttemptUpdateManyMutationInput, QuizAttemptUncheckedUpdateManyWithoutUserInput>
  }

  export type QuizAttemptScalarWhereInput = {
    AND?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
    OR?: QuizAttemptScalarWhereInput[]
    NOT?: QuizAttemptScalarWhereInput | QuizAttemptScalarWhereInput[]
    id?: StringFilter<"QuizAttempt"> | string
    quizId?: StringFilter<"QuizAttempt"> | string
    userId?: StringFilter<"QuizAttempt"> | string
    correctAnswers?: IntFilter<"QuizAttempt"> | number
    totalQuestions?: IntFilter<"QuizAttempt"> | number
    avgResponseTime?: FloatFilter<"QuizAttempt"> | number
    responseTimeStdDev?: FloatFilter<"QuizAttempt"> | number
    streak?: IntFilter<"QuizAttempt"> | number
    maxStreak?: IntFilter<"QuizAttempt"> | number
    finalScore?: FloatFilter<"QuizAttempt"> | number
    speedScore?: FloatFilter<"QuizAttempt"> | number
    accuracyScore?: FloatFilter<"QuizAttempt"> | number
    consistencyScore?: FloatFilter<"QuizAttempt"> | number
    rank?: IntNullableFilter<"QuizAttempt"> | number | null
    status?: StringFilter<"QuizAttempt"> | string
    startedAt?: DateTimeFilter<"QuizAttempt"> | Date | string
    completedAt?: DateTimeNullableFilter<"QuizAttempt"> | Date | string | null
  }

  export type FanIQBadgeUpsertWithWhereUniqueWithoutUserInput = {
    where: FanIQBadgeWhereUniqueInput
    update: XOR<FanIQBadgeUpdateWithoutUserInput, FanIQBadgeUncheckedUpdateWithoutUserInput>
    create: XOR<FanIQBadgeCreateWithoutUserInput, FanIQBadgeUncheckedCreateWithoutUserInput>
  }

  export type FanIQBadgeUpdateWithWhereUniqueWithoutUserInput = {
    where: FanIQBadgeWhereUniqueInput
    data: XOR<FanIQBadgeUpdateWithoutUserInput, FanIQBadgeUncheckedUpdateWithoutUserInput>
  }

  export type FanIQBadgeUpdateManyWithWhereWithoutUserInput = {
    where: FanIQBadgeScalarWhereInput
    data: XOR<FanIQBadgeUpdateManyMutationInput, FanIQBadgeUncheckedUpdateManyWithoutUserInput>
  }

  export type FanIQBadgeScalarWhereInput = {
    AND?: FanIQBadgeScalarWhereInput | FanIQBadgeScalarWhereInput[]
    OR?: FanIQBadgeScalarWhereInput[]
    NOT?: FanIQBadgeScalarWhereInput | FanIQBadgeScalarWhereInput[]
    id?: StringFilter<"FanIQBadge"> | string
    userId?: StringFilter<"FanIQBadge"> | string
    tier?: StringFilter<"FanIQBadge"> | string
    artistId?: StringFilter<"FanIQBadge"> | string
    artistName?: StringFilter<"FanIQBadge"> | string
    tokenId?: StringNullableFilter<"FanIQBadge"> | string | null
    txHash?: StringNullableFilter<"FanIQBadge"> | string | null
    earnedAt?: DateTimeFilter<"FanIQBadge"> | Date | string
  }

  export type TicketTierCreateWithoutEventInput = {
    id?: string
    name: string
    price: number
    currency?: string
    description: string
    available: number
    total: number
    benefits?: TicketTierCreatebenefitsInput | string[]
    tickets?: TicketCreateNestedManyWithoutTierInput
  }

  export type TicketTierUncheckedCreateWithoutEventInput = {
    id?: string
    name: string
    price: number
    currency?: string
    description: string
    available: number
    total: number
    benefits?: TicketTierCreatebenefitsInput | string[]
    tickets?: TicketUncheckedCreateNestedManyWithoutTierInput
  }

  export type TicketTierCreateOrConnectWithoutEventInput = {
    where: TicketTierWhereUniqueInput
    create: XOR<TicketTierCreateWithoutEventInput, TicketTierUncheckedCreateWithoutEventInput>
  }

  export type TicketTierCreateManyEventInputEnvelope = {
    data: TicketTierCreateManyEventInput | TicketTierCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutEventInput = {
    id?: string
    originalPrice: number
    currentPrice: number
    purchaseDate?: Date | string
    status?: string
    qrCode?: string | null
    tokenId?: string | null
    txHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tier: TicketTierCreateNestedOneWithoutTicketsInput
    owner: UserCreateNestedOneWithoutTicketsInput
  }

  export type TicketUncheckedCreateWithoutEventInput = {
    id?: string
    tierId: string
    ownerId: string
    originalPrice: number
    currentPrice: number
    purchaseDate?: Date | string
    status?: string
    qrCode?: string | null
    tokenId?: string | null
    txHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCreateOrConnectWithoutEventInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutEventInput, TicketUncheckedCreateWithoutEventInput>
  }

  export type TicketCreateManyEventInputEnvelope = {
    data: TicketCreateManyEventInput | TicketCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type EventReminderCreateWithoutEventInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRemindersInput
  }

  export type EventReminderUncheckedCreateWithoutEventInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type EventReminderCreateOrConnectWithoutEventInput = {
    where: EventReminderWhereUniqueInput
    create: XOR<EventReminderCreateWithoutEventInput, EventReminderUncheckedCreateWithoutEventInput>
  }

  export type EventReminderCreateManyEventInputEnvelope = {
    data: EventReminderCreateManyEventInput | EventReminderCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type TicketTierUpsertWithWhereUniqueWithoutEventInput = {
    where: TicketTierWhereUniqueInput
    update: XOR<TicketTierUpdateWithoutEventInput, TicketTierUncheckedUpdateWithoutEventInput>
    create: XOR<TicketTierCreateWithoutEventInput, TicketTierUncheckedCreateWithoutEventInput>
  }

  export type TicketTierUpdateWithWhereUniqueWithoutEventInput = {
    where: TicketTierWhereUniqueInput
    data: XOR<TicketTierUpdateWithoutEventInput, TicketTierUncheckedUpdateWithoutEventInput>
  }

  export type TicketTierUpdateManyWithWhereWithoutEventInput = {
    where: TicketTierScalarWhereInput
    data: XOR<TicketTierUpdateManyMutationInput, TicketTierUncheckedUpdateManyWithoutEventInput>
  }

  export type TicketTierScalarWhereInput = {
    AND?: TicketTierScalarWhereInput | TicketTierScalarWhereInput[]
    OR?: TicketTierScalarWhereInput[]
    NOT?: TicketTierScalarWhereInput | TicketTierScalarWhereInput[]
    id?: StringFilter<"TicketTier"> | string
    eventId?: StringFilter<"TicketTier"> | string
    name?: StringFilter<"TicketTier"> | string
    price?: FloatFilter<"TicketTier"> | number
    currency?: StringFilter<"TicketTier"> | string
    description?: StringFilter<"TicketTier"> | string
    available?: IntFilter<"TicketTier"> | number
    total?: IntFilter<"TicketTier"> | number
    benefits?: StringNullableListFilter<"TicketTier">
  }

  export type TicketUpsertWithWhereUniqueWithoutEventInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutEventInput, TicketUncheckedUpdateWithoutEventInput>
    create: XOR<TicketCreateWithoutEventInput, TicketUncheckedCreateWithoutEventInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutEventInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutEventInput, TicketUncheckedUpdateWithoutEventInput>
  }

  export type TicketUpdateManyWithWhereWithoutEventInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutEventInput>
  }

  export type EventReminderUpsertWithWhereUniqueWithoutEventInput = {
    where: EventReminderWhereUniqueInput
    update: XOR<EventReminderUpdateWithoutEventInput, EventReminderUncheckedUpdateWithoutEventInput>
    create: XOR<EventReminderCreateWithoutEventInput, EventReminderUncheckedCreateWithoutEventInput>
  }

  export type EventReminderUpdateWithWhereUniqueWithoutEventInput = {
    where: EventReminderWhereUniqueInput
    data: XOR<EventReminderUpdateWithoutEventInput, EventReminderUncheckedUpdateWithoutEventInput>
  }

  export type EventReminderUpdateManyWithWhereWithoutEventInput = {
    where: EventReminderScalarWhereInput
    data: XOR<EventReminderUpdateManyMutationInput, EventReminderUncheckedUpdateManyWithoutEventInput>
  }

  export type EventCreateWithoutRemindersInput = {
    id?: string
    title: string
    artist: string
    artistImage: string
    venue: string
    location: string
    date: Date | string
    time: string
    image: string
    description: string
    category: string
    status?: string
    totalTickets: number
    soldTickets?: number
    resaleEnabled?: boolean
    resaleCap?: number | null
    artistRoyalty?: number
    minFandomScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ticketTiers?: TicketTierCreateNestedManyWithoutEventInput
    tickets?: TicketCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutRemindersInput = {
    id?: string
    title: string
    artist: string
    artistImage: string
    venue: string
    location: string
    date: Date | string
    time: string
    image: string
    description: string
    category: string
    status?: string
    totalTickets: number
    soldTickets?: number
    resaleEnabled?: boolean
    resaleCap?: number | null
    artistRoyalty?: number
    minFandomScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ticketTiers?: TicketTierUncheckedCreateNestedManyWithoutEventInput
    tickets?: TicketUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutRemindersInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutRemindersInput, EventUncheckedCreateWithoutRemindersInput>
  }

  export type UserCreateWithoutRemindersInput = {
    id?: string
    auth0Id: string
    email: string
    name: string
    avatar?: string | null
    fandomScore?: number
    walletAddress?: string | null
    solanaWalletAddress?: string | null
    spotifyConnected?: boolean
    eventsAttended?: number
    vouchesGiven?: number
    vouchesReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketCreateNestedManyWithoutOwnerInput
    posts?: CommunityPostCreateNestedManyWithoutAuthorInput
    memberships?: CommunityMemberCreateNestedManyWithoutUserInput
    postVotes?: PostVoteCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentVotes?: CommentVoteCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    fanIQBadges?: FanIQBadgeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRemindersInput = {
    id?: string
    auth0Id: string
    email: string
    name: string
    avatar?: string | null
    fandomScore?: number
    walletAddress?: string | null
    solanaWalletAddress?: string | null
    spotifyConnected?: boolean
    eventsAttended?: number
    vouchesGiven?: number
    vouchesReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutOwnerInput
    posts?: CommunityPostUncheckedCreateNestedManyWithoutAuthorInput
    memberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    postVotes?: PostVoteUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentVotes?: CommentVoteUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    fanIQBadges?: FanIQBadgeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRemindersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRemindersInput, UserUncheckedCreateWithoutRemindersInput>
  }

  export type EventUpsertWithoutRemindersInput = {
    update: XOR<EventUpdateWithoutRemindersInput, EventUncheckedUpdateWithoutRemindersInput>
    create: XOR<EventCreateWithoutRemindersInput, EventUncheckedCreateWithoutRemindersInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutRemindersInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutRemindersInput, EventUncheckedUpdateWithoutRemindersInput>
  }

  export type EventUpdateWithoutRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    artistImage?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalTickets?: IntFieldUpdateOperationsInput | number
    soldTickets?: IntFieldUpdateOperationsInput | number
    resaleEnabled?: BoolFieldUpdateOperationsInput | boolean
    resaleCap?: NullableIntFieldUpdateOperationsInput | number | null
    artistRoyalty?: IntFieldUpdateOperationsInput | number
    minFandomScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketTiers?: TicketTierUpdateManyWithoutEventNestedInput
    tickets?: TicketUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    artistImage?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalTickets?: IntFieldUpdateOperationsInput | number
    soldTickets?: IntFieldUpdateOperationsInput | number
    resaleEnabled?: BoolFieldUpdateOperationsInput | boolean
    resaleCap?: NullableIntFieldUpdateOperationsInput | number | null
    artistRoyalty?: IntFieldUpdateOperationsInput | number
    minFandomScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketTiers?: TicketTierUncheckedUpdateManyWithoutEventNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutEventNestedInput
  }

  export type UserUpsertWithoutRemindersInput = {
    update: XOR<UserUpdateWithoutRemindersInput, UserUncheckedUpdateWithoutRemindersInput>
    create: XOR<UserCreateWithoutRemindersInput, UserUncheckedCreateWithoutRemindersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRemindersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRemindersInput, UserUncheckedUpdateWithoutRemindersInput>
  }

  export type UserUpdateWithoutRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    fandomScore?: IntFieldUpdateOperationsInput | number
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    solanaWalletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyConnected?: BoolFieldUpdateOperationsInput | boolean
    eventsAttended?: IntFieldUpdateOperationsInput | number
    vouchesGiven?: IntFieldUpdateOperationsInput | number
    vouchesReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutOwnerNestedInput
    posts?: CommunityPostUpdateManyWithoutAuthorNestedInput
    memberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    postVotes?: PostVoteUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentVotes?: CommentVoteUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    fanIQBadges?: FanIQBadgeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRemindersInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    fandomScore?: IntFieldUpdateOperationsInput | number
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    solanaWalletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyConnected?: BoolFieldUpdateOperationsInput | boolean
    eventsAttended?: IntFieldUpdateOperationsInput | number
    vouchesGiven?: IntFieldUpdateOperationsInput | number
    vouchesReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutOwnerNestedInput
    posts?: CommunityPostUncheckedUpdateManyWithoutAuthorNestedInput
    memberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    postVotes?: PostVoteUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentVotes?: CommentVoteUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    fanIQBadges?: FanIQBadgeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EventCreateWithoutTicketTiersInput = {
    id?: string
    title: string
    artist: string
    artistImage: string
    venue: string
    location: string
    date: Date | string
    time: string
    image: string
    description: string
    category: string
    status?: string
    totalTickets: number
    soldTickets?: number
    resaleEnabled?: boolean
    resaleCap?: number | null
    artistRoyalty?: number
    minFandomScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketCreateNestedManyWithoutEventInput
    reminders?: EventReminderCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutTicketTiersInput = {
    id?: string
    title: string
    artist: string
    artistImage: string
    venue: string
    location: string
    date: Date | string
    time: string
    image: string
    description: string
    category: string
    status?: string
    totalTickets: number
    soldTickets?: number
    resaleEnabled?: boolean
    resaleCap?: number | null
    artistRoyalty?: number
    minFandomScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutEventInput
    reminders?: EventReminderUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutTicketTiersInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutTicketTiersInput, EventUncheckedCreateWithoutTicketTiersInput>
  }

  export type TicketCreateWithoutTierInput = {
    id?: string
    originalPrice: number
    currentPrice: number
    purchaseDate?: Date | string
    status?: string
    qrCode?: string | null
    tokenId?: string | null
    txHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutTicketsInput
    owner: UserCreateNestedOneWithoutTicketsInput
  }

  export type TicketUncheckedCreateWithoutTierInput = {
    id?: string
    eventId: string
    ownerId: string
    originalPrice: number
    currentPrice: number
    purchaseDate?: Date | string
    status?: string
    qrCode?: string | null
    tokenId?: string | null
    txHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCreateOrConnectWithoutTierInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutTierInput, TicketUncheckedCreateWithoutTierInput>
  }

  export type TicketCreateManyTierInputEnvelope = {
    data: TicketCreateManyTierInput | TicketCreateManyTierInput[]
    skipDuplicates?: boolean
  }

  export type EventUpsertWithoutTicketTiersInput = {
    update: XOR<EventUpdateWithoutTicketTiersInput, EventUncheckedUpdateWithoutTicketTiersInput>
    create: XOR<EventCreateWithoutTicketTiersInput, EventUncheckedCreateWithoutTicketTiersInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutTicketTiersInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutTicketTiersInput, EventUncheckedUpdateWithoutTicketTiersInput>
  }

  export type EventUpdateWithoutTicketTiersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    artistImage?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalTickets?: IntFieldUpdateOperationsInput | number
    soldTickets?: IntFieldUpdateOperationsInput | number
    resaleEnabled?: BoolFieldUpdateOperationsInput | boolean
    resaleCap?: NullableIntFieldUpdateOperationsInput | number | null
    artistRoyalty?: IntFieldUpdateOperationsInput | number
    minFandomScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutEventNestedInput
    reminders?: EventReminderUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutTicketTiersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    artistImage?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalTickets?: IntFieldUpdateOperationsInput | number
    soldTickets?: IntFieldUpdateOperationsInput | number
    resaleEnabled?: BoolFieldUpdateOperationsInput | boolean
    resaleCap?: NullableIntFieldUpdateOperationsInput | number | null
    artistRoyalty?: IntFieldUpdateOperationsInput | number
    minFandomScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutEventNestedInput
    reminders?: EventReminderUncheckedUpdateManyWithoutEventNestedInput
  }

  export type TicketUpsertWithWhereUniqueWithoutTierInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutTierInput, TicketUncheckedUpdateWithoutTierInput>
    create: XOR<TicketCreateWithoutTierInput, TicketUncheckedCreateWithoutTierInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutTierInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutTierInput, TicketUncheckedUpdateWithoutTierInput>
  }

  export type TicketUpdateManyWithWhereWithoutTierInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutTierInput>
  }

  export type EventCreateWithoutTicketsInput = {
    id?: string
    title: string
    artist: string
    artistImage: string
    venue: string
    location: string
    date: Date | string
    time: string
    image: string
    description: string
    category: string
    status?: string
    totalTickets: number
    soldTickets?: number
    resaleEnabled?: boolean
    resaleCap?: number | null
    artistRoyalty?: number
    minFandomScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ticketTiers?: TicketTierCreateNestedManyWithoutEventInput
    reminders?: EventReminderCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutTicketsInput = {
    id?: string
    title: string
    artist: string
    artistImage: string
    venue: string
    location: string
    date: Date | string
    time: string
    image: string
    description: string
    category: string
    status?: string
    totalTickets: number
    soldTickets?: number
    resaleEnabled?: boolean
    resaleCap?: number | null
    artistRoyalty?: number
    minFandomScore?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ticketTiers?: TicketTierUncheckedCreateNestedManyWithoutEventInput
    reminders?: EventReminderUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutTicketsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutTicketsInput, EventUncheckedCreateWithoutTicketsInput>
  }

  export type TicketTierCreateWithoutTicketsInput = {
    id?: string
    name: string
    price: number
    currency?: string
    description: string
    available: number
    total: number
    benefits?: TicketTierCreatebenefitsInput | string[]
    event: EventCreateNestedOneWithoutTicketTiersInput
  }

  export type TicketTierUncheckedCreateWithoutTicketsInput = {
    id?: string
    eventId: string
    name: string
    price: number
    currency?: string
    description: string
    available: number
    total: number
    benefits?: TicketTierCreatebenefitsInput | string[]
  }

  export type TicketTierCreateOrConnectWithoutTicketsInput = {
    where: TicketTierWhereUniqueInput
    create: XOR<TicketTierCreateWithoutTicketsInput, TicketTierUncheckedCreateWithoutTicketsInput>
  }

  export type UserCreateWithoutTicketsInput = {
    id?: string
    auth0Id: string
    email: string
    name: string
    avatar?: string | null
    fandomScore?: number
    walletAddress?: string | null
    solanaWalletAddress?: string | null
    spotifyConnected?: boolean
    eventsAttended?: number
    vouchesGiven?: number
    vouchesReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: CommunityPostCreateNestedManyWithoutAuthorInput
    memberships?: CommunityMemberCreateNestedManyWithoutUserInput
    postVotes?: PostVoteCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentVotes?: CommentVoteCreateNestedManyWithoutUserInput
    reminders?: EventReminderCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    fanIQBadges?: FanIQBadgeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicketsInput = {
    id?: string
    auth0Id: string
    email: string
    name: string
    avatar?: string | null
    fandomScore?: number
    walletAddress?: string | null
    solanaWalletAddress?: string | null
    spotifyConnected?: boolean
    eventsAttended?: number
    vouchesGiven?: number
    vouchesReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: CommunityPostUncheckedCreateNestedManyWithoutAuthorInput
    memberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    postVotes?: PostVoteUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentVotes?: CommentVoteUncheckedCreateNestedManyWithoutUserInput
    reminders?: EventReminderUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    fanIQBadges?: FanIQBadgeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicketsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
  }

  export type EventUpsertWithoutTicketsInput = {
    update: XOR<EventUpdateWithoutTicketsInput, EventUncheckedUpdateWithoutTicketsInput>
    create: XOR<EventCreateWithoutTicketsInput, EventUncheckedCreateWithoutTicketsInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutTicketsInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutTicketsInput, EventUncheckedUpdateWithoutTicketsInput>
  }

  export type EventUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    artistImage?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalTickets?: IntFieldUpdateOperationsInput | number
    soldTickets?: IntFieldUpdateOperationsInput | number
    resaleEnabled?: BoolFieldUpdateOperationsInput | boolean
    resaleCap?: NullableIntFieldUpdateOperationsInput | number | null
    artistRoyalty?: IntFieldUpdateOperationsInput | number
    minFandomScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketTiers?: TicketTierUpdateManyWithoutEventNestedInput
    reminders?: EventReminderUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    artist?: StringFieldUpdateOperationsInput | string
    artistImage?: StringFieldUpdateOperationsInput | string
    venue?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalTickets?: IntFieldUpdateOperationsInput | number
    soldTickets?: IntFieldUpdateOperationsInput | number
    resaleEnabled?: BoolFieldUpdateOperationsInput | boolean
    resaleCap?: NullableIntFieldUpdateOperationsInput | number | null
    artistRoyalty?: IntFieldUpdateOperationsInput | number
    minFandomScore?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketTiers?: TicketTierUncheckedUpdateManyWithoutEventNestedInput
    reminders?: EventReminderUncheckedUpdateManyWithoutEventNestedInput
  }

  export type TicketTierUpsertWithoutTicketsInput = {
    update: XOR<TicketTierUpdateWithoutTicketsInput, TicketTierUncheckedUpdateWithoutTicketsInput>
    create: XOR<TicketTierCreateWithoutTicketsInput, TicketTierUncheckedCreateWithoutTicketsInput>
    where?: TicketTierWhereInput
  }

  export type TicketTierUpdateToOneWithWhereWithoutTicketsInput = {
    where?: TicketTierWhereInput
    data: XOR<TicketTierUpdateWithoutTicketsInput, TicketTierUncheckedUpdateWithoutTicketsInput>
  }

  export type TicketTierUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    available?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    benefits?: TicketTierUpdatebenefitsInput | string[]
    event?: EventUpdateOneRequiredWithoutTicketTiersNestedInput
  }

  export type TicketTierUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    available?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    benefits?: TicketTierUpdatebenefitsInput | string[]
  }

  export type UserUpsertWithoutTicketsInput = {
    update: XOR<UserUpdateWithoutTicketsInput, UserUncheckedUpdateWithoutTicketsInput>
    create: XOR<UserCreateWithoutTicketsInput, UserUncheckedCreateWithoutTicketsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketsInput, UserUncheckedUpdateWithoutTicketsInput>
  }

  export type UserUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    fandomScore?: IntFieldUpdateOperationsInput | number
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    solanaWalletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyConnected?: BoolFieldUpdateOperationsInput | boolean
    eventsAttended?: IntFieldUpdateOperationsInput | number
    vouchesGiven?: IntFieldUpdateOperationsInput | number
    vouchesReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: CommunityPostUpdateManyWithoutAuthorNestedInput
    memberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    postVotes?: PostVoteUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentVotes?: CommentVoteUpdateManyWithoutUserNestedInput
    reminders?: EventReminderUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    fanIQBadges?: FanIQBadgeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    fandomScore?: IntFieldUpdateOperationsInput | number
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    solanaWalletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyConnected?: BoolFieldUpdateOperationsInput | boolean
    eventsAttended?: IntFieldUpdateOperationsInput | number
    vouchesGiven?: IntFieldUpdateOperationsInput | number
    vouchesReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: CommunityPostUncheckedUpdateManyWithoutAuthorNestedInput
    memberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    postVotes?: PostVoteUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentVotes?: CommentVoteUncheckedUpdateManyWithoutUserNestedInput
    reminders?: EventReminderUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    fanIQBadges?: FanIQBadgeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommunityPostCreateWithoutCommunityInput = {
    id?: string
    title: string
    content: string
    type?: string
    images?: CommunityPostCreateimagesInput | string[]
    upvotes?: number
    downvotes?: number
    commentCount?: number
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutPostsInput
    votes?: PostVoteCreateNestedManyWithoutPostInput
    comments?: CommentCreateNestedManyWithoutPostInput
  }

  export type CommunityPostUncheckedCreateWithoutCommunityInput = {
    id?: string
    authorId: string
    title: string
    content: string
    type?: string
    images?: CommunityPostCreateimagesInput | string[]
    upvotes?: number
    downvotes?: number
    commentCount?: number
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: PostVoteUncheckedCreateNestedManyWithoutPostInput
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type CommunityPostCreateOrConnectWithoutCommunityInput = {
    where: CommunityPostWhereUniqueInput
    create: XOR<CommunityPostCreateWithoutCommunityInput, CommunityPostUncheckedCreateWithoutCommunityInput>
  }

  export type CommunityPostCreateManyCommunityInputEnvelope = {
    data: CommunityPostCreateManyCommunityInput | CommunityPostCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type CommunityMemberCreateWithoutCommunityInput = {
    id?: string
    role?: string
    reputationPoints?: number
    votingPower?: number
    isActive?: boolean
    joinedAt?: Date | string
    user: UserCreateNestedOneWithoutMembershipsInput
  }

  export type CommunityMemberUncheckedCreateWithoutCommunityInput = {
    id?: string
    userId: string
    role?: string
    reputationPoints?: number
    votingPower?: number
    isActive?: boolean
    joinedAt?: Date | string
  }

  export type CommunityMemberCreateOrConnectWithoutCommunityInput = {
    where: CommunityMemberWhereUniqueInput
    create: XOR<CommunityMemberCreateWithoutCommunityInput, CommunityMemberUncheckedCreateWithoutCommunityInput>
  }

  export type CommunityMemberCreateManyCommunityInputEnvelope = {
    data: CommunityMemberCreateManyCommunityInput | CommunityMemberCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type GovernanceProposalCreateWithoutCommunityInput = {
    id?: string
    proposerId: string
    title: string
    description: string
    type: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    quorumRequired: number
    totalVotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: ProposalOptionCreateNestedManyWithoutProposalInput
  }

  export type GovernanceProposalUncheckedCreateWithoutCommunityInput = {
    id?: string
    proposerId: string
    title: string
    description: string
    type: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    quorumRequired: number
    totalVotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: ProposalOptionUncheckedCreateNestedManyWithoutProposalInput
  }

  export type GovernanceProposalCreateOrConnectWithoutCommunityInput = {
    where: GovernanceProposalWhereUniqueInput
    create: XOR<GovernanceProposalCreateWithoutCommunityInput, GovernanceProposalUncheckedCreateWithoutCommunityInput>
  }

  export type GovernanceProposalCreateManyCommunityInputEnvelope = {
    data: GovernanceProposalCreateManyCommunityInput | GovernanceProposalCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type CommunityPostUpsertWithWhereUniqueWithoutCommunityInput = {
    where: CommunityPostWhereUniqueInput
    update: XOR<CommunityPostUpdateWithoutCommunityInput, CommunityPostUncheckedUpdateWithoutCommunityInput>
    create: XOR<CommunityPostCreateWithoutCommunityInput, CommunityPostUncheckedCreateWithoutCommunityInput>
  }

  export type CommunityPostUpdateWithWhereUniqueWithoutCommunityInput = {
    where: CommunityPostWhereUniqueInput
    data: XOR<CommunityPostUpdateWithoutCommunityInput, CommunityPostUncheckedUpdateWithoutCommunityInput>
  }

  export type CommunityPostUpdateManyWithWhereWithoutCommunityInput = {
    where: CommunityPostScalarWhereInput
    data: XOR<CommunityPostUpdateManyMutationInput, CommunityPostUncheckedUpdateManyWithoutCommunityInput>
  }

  export type CommunityMemberUpsertWithWhereUniqueWithoutCommunityInput = {
    where: CommunityMemberWhereUniqueInput
    update: XOR<CommunityMemberUpdateWithoutCommunityInput, CommunityMemberUncheckedUpdateWithoutCommunityInput>
    create: XOR<CommunityMemberCreateWithoutCommunityInput, CommunityMemberUncheckedCreateWithoutCommunityInput>
  }

  export type CommunityMemberUpdateWithWhereUniqueWithoutCommunityInput = {
    where: CommunityMemberWhereUniqueInput
    data: XOR<CommunityMemberUpdateWithoutCommunityInput, CommunityMemberUncheckedUpdateWithoutCommunityInput>
  }

  export type CommunityMemberUpdateManyWithWhereWithoutCommunityInput = {
    where: CommunityMemberScalarWhereInput
    data: XOR<CommunityMemberUpdateManyMutationInput, CommunityMemberUncheckedUpdateManyWithoutCommunityInput>
  }

  export type GovernanceProposalUpsertWithWhereUniqueWithoutCommunityInput = {
    where: GovernanceProposalWhereUniqueInput
    update: XOR<GovernanceProposalUpdateWithoutCommunityInput, GovernanceProposalUncheckedUpdateWithoutCommunityInput>
    create: XOR<GovernanceProposalCreateWithoutCommunityInput, GovernanceProposalUncheckedCreateWithoutCommunityInput>
  }

  export type GovernanceProposalUpdateWithWhereUniqueWithoutCommunityInput = {
    where: GovernanceProposalWhereUniqueInput
    data: XOR<GovernanceProposalUpdateWithoutCommunityInput, GovernanceProposalUncheckedUpdateWithoutCommunityInput>
  }

  export type GovernanceProposalUpdateManyWithWhereWithoutCommunityInput = {
    where: GovernanceProposalScalarWhereInput
    data: XOR<GovernanceProposalUpdateManyMutationInput, GovernanceProposalUncheckedUpdateManyWithoutCommunityInput>
  }

  export type GovernanceProposalScalarWhereInput = {
    AND?: GovernanceProposalScalarWhereInput | GovernanceProposalScalarWhereInput[]
    OR?: GovernanceProposalScalarWhereInput[]
    NOT?: GovernanceProposalScalarWhereInput | GovernanceProposalScalarWhereInput[]
    id?: StringFilter<"GovernanceProposal"> | string
    communityId?: StringFilter<"GovernanceProposal"> | string
    proposerId?: StringFilter<"GovernanceProposal"> | string
    title?: StringFilter<"GovernanceProposal"> | string
    description?: StringFilter<"GovernanceProposal"> | string
    type?: StringFilter<"GovernanceProposal"> | string
    status?: StringFilter<"GovernanceProposal"> | string
    startDate?: DateTimeFilter<"GovernanceProposal"> | Date | string
    endDate?: DateTimeFilter<"GovernanceProposal"> | Date | string
    quorumRequired?: IntFilter<"GovernanceProposal"> | number
    totalVotes?: IntFilter<"GovernanceProposal"> | number
    createdAt?: DateTimeFilter<"GovernanceProposal"> | Date | string
    updatedAt?: DateTimeFilter<"GovernanceProposal"> | Date | string
  }

  export type CommunityCreateWithoutPostsInput = {
    id?: string
    name: string
    artistId: string
    artistName: string
    artistImage: string
    description: string
    memberCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: CommunityMemberCreateNestedManyWithoutCommunityInput
    proposals?: GovernanceProposalCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    artistId: string
    artistName: string
    artistImage: string
    description: string
    memberCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: CommunityMemberUncheckedCreateNestedManyWithoutCommunityInput
    proposals?: GovernanceProposalUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutPostsInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutPostsInput, CommunityUncheckedCreateWithoutPostsInput>
  }

  export type UserCreateWithoutPostsInput = {
    id?: string
    auth0Id: string
    email: string
    name: string
    avatar?: string | null
    fandomScore?: number
    walletAddress?: string | null
    solanaWalletAddress?: string | null
    spotifyConnected?: boolean
    eventsAttended?: number
    vouchesGiven?: number
    vouchesReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketCreateNestedManyWithoutOwnerInput
    memberships?: CommunityMemberCreateNestedManyWithoutUserInput
    postVotes?: PostVoteCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentVotes?: CommentVoteCreateNestedManyWithoutUserInput
    reminders?: EventReminderCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    fanIQBadges?: FanIQBadgeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostsInput = {
    id?: string
    auth0Id: string
    email: string
    name: string
    avatar?: string | null
    fandomScore?: number
    walletAddress?: string | null
    solanaWalletAddress?: string | null
    spotifyConnected?: boolean
    eventsAttended?: number
    vouchesGiven?: number
    vouchesReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutOwnerInput
    memberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    postVotes?: PostVoteUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentVotes?: CommentVoteUncheckedCreateNestedManyWithoutUserInput
    reminders?: EventReminderUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    fanIQBadges?: FanIQBadgeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
  }

  export type PostVoteCreateWithoutPostInput = {
    id?: string
    type: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPostVotesInput
  }

  export type PostVoteUncheckedCreateWithoutPostInput = {
    id?: string
    userId: string
    type: string
    createdAt?: Date | string
  }

  export type PostVoteCreateOrConnectWithoutPostInput = {
    where: PostVoteWhereUniqueInput
    create: XOR<PostVoteCreateWithoutPostInput, PostVoteUncheckedCreateWithoutPostInput>
  }

  export type PostVoteCreateManyPostInputEnvelope = {
    data: PostVoteCreateManyPostInput | PostVoteCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutPostInput = {
    id?: string
    content: string
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutChildrenInput
    children?: CommentCreateNestedManyWithoutParentInput
    votes?: CommentVoteCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: string
    content: string
    authorId: string
    parentId?: string | null
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CommentUncheckedCreateNestedManyWithoutParentInput
    votes?: CommentVoteUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: CommentCreateManyPostInput | CommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type CommunityUpsertWithoutPostsInput = {
    update: XOR<CommunityUpdateWithoutPostsInput, CommunityUncheckedUpdateWithoutPostsInput>
    create: XOR<CommunityCreateWithoutPostsInput, CommunityUncheckedCreateWithoutPostsInput>
    where?: CommunityWhereInput
  }

  export type CommunityUpdateToOneWithWhereWithoutPostsInput = {
    where?: CommunityWhereInput
    data: XOR<CommunityUpdateWithoutPostsInput, CommunityUncheckedUpdateWithoutPostsInput>
  }

  export type CommunityUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    artistImage?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    memberCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: CommunityMemberUpdateManyWithoutCommunityNestedInput
    proposals?: GovernanceProposalUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    artistImage?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    memberCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: CommunityMemberUncheckedUpdateManyWithoutCommunityNestedInput
    proposals?: GovernanceProposalUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type UserUpsertWithoutPostsInput = {
    update: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
    create: XOR<UserCreateWithoutPostsInput, UserUncheckedCreateWithoutPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostsInput, UserUncheckedUpdateWithoutPostsInput>
  }

  export type UserUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    fandomScore?: IntFieldUpdateOperationsInput | number
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    solanaWalletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyConnected?: BoolFieldUpdateOperationsInput | boolean
    eventsAttended?: IntFieldUpdateOperationsInput | number
    vouchesGiven?: IntFieldUpdateOperationsInput | number
    vouchesReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutOwnerNestedInput
    memberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    postVotes?: PostVoteUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentVotes?: CommentVoteUpdateManyWithoutUserNestedInput
    reminders?: EventReminderUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    fanIQBadges?: FanIQBadgeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    fandomScore?: IntFieldUpdateOperationsInput | number
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    solanaWalletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyConnected?: BoolFieldUpdateOperationsInput | boolean
    eventsAttended?: IntFieldUpdateOperationsInput | number
    vouchesGiven?: IntFieldUpdateOperationsInput | number
    vouchesReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutOwnerNestedInput
    memberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    postVotes?: PostVoteUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentVotes?: CommentVoteUncheckedUpdateManyWithoutUserNestedInput
    reminders?: EventReminderUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    fanIQBadges?: FanIQBadgeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PostVoteUpsertWithWhereUniqueWithoutPostInput = {
    where: PostVoteWhereUniqueInput
    update: XOR<PostVoteUpdateWithoutPostInput, PostVoteUncheckedUpdateWithoutPostInput>
    create: XOR<PostVoteCreateWithoutPostInput, PostVoteUncheckedCreateWithoutPostInput>
  }

  export type PostVoteUpdateWithWhereUniqueWithoutPostInput = {
    where: PostVoteWhereUniqueInput
    data: XOR<PostVoteUpdateWithoutPostInput, PostVoteUncheckedUpdateWithoutPostInput>
  }

  export type PostVoteUpdateManyWithWhereWithoutPostInput = {
    where: PostVoteScalarWhereInput
    data: XOR<PostVoteUpdateManyMutationInput, PostVoteUncheckedUpdateManyWithoutPostInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostInput>
  }

  export type CommunityPostCreateWithoutVotesInput = {
    id?: string
    title: string
    content: string
    type?: string
    images?: CommunityPostCreateimagesInput | string[]
    upvotes?: number
    downvotes?: number
    commentCount?: number
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    community: CommunityCreateNestedOneWithoutPostsInput
    author: UserCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
  }

  export type CommunityPostUncheckedCreateWithoutVotesInput = {
    id?: string
    communityId: string
    authorId: string
    title: string
    content: string
    type?: string
    images?: CommunityPostCreateimagesInput | string[]
    upvotes?: number
    downvotes?: number
    commentCount?: number
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type CommunityPostCreateOrConnectWithoutVotesInput = {
    where: CommunityPostWhereUniqueInput
    create: XOR<CommunityPostCreateWithoutVotesInput, CommunityPostUncheckedCreateWithoutVotesInput>
  }

  export type UserCreateWithoutPostVotesInput = {
    id?: string
    auth0Id: string
    email: string
    name: string
    avatar?: string | null
    fandomScore?: number
    walletAddress?: string | null
    solanaWalletAddress?: string | null
    spotifyConnected?: boolean
    eventsAttended?: number
    vouchesGiven?: number
    vouchesReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketCreateNestedManyWithoutOwnerInput
    posts?: CommunityPostCreateNestedManyWithoutAuthorInput
    memberships?: CommunityMemberCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentVotes?: CommentVoteCreateNestedManyWithoutUserInput
    reminders?: EventReminderCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    fanIQBadges?: FanIQBadgeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostVotesInput = {
    id?: string
    auth0Id: string
    email: string
    name: string
    avatar?: string | null
    fandomScore?: number
    walletAddress?: string | null
    solanaWalletAddress?: string | null
    spotifyConnected?: boolean
    eventsAttended?: number
    vouchesGiven?: number
    vouchesReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutOwnerInput
    posts?: CommunityPostUncheckedCreateNestedManyWithoutAuthorInput
    memberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentVotes?: CommentVoteUncheckedCreateNestedManyWithoutUserInput
    reminders?: EventReminderUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    fanIQBadges?: FanIQBadgeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostVotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostVotesInput, UserUncheckedCreateWithoutPostVotesInput>
  }

  export type CommunityPostUpsertWithoutVotesInput = {
    update: XOR<CommunityPostUpdateWithoutVotesInput, CommunityPostUncheckedUpdateWithoutVotesInput>
    create: XOR<CommunityPostCreateWithoutVotesInput, CommunityPostUncheckedCreateWithoutVotesInput>
    where?: CommunityPostWhereInput
  }

  export type CommunityPostUpdateToOneWithWhereWithoutVotesInput = {
    where?: CommunityPostWhereInput
    data: XOR<CommunityPostUpdateWithoutVotesInput, CommunityPostUncheckedUpdateWithoutVotesInput>
  }

  export type CommunityPostUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    images?: CommunityPostUpdateimagesInput | string[]
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    community?: CommunityUpdateOneRequiredWithoutPostsNestedInput
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
  }

  export type CommunityPostUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    communityId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    images?: CommunityPostUpdateimagesInput | string[]
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserUpsertWithoutPostVotesInput = {
    update: XOR<UserUpdateWithoutPostVotesInput, UserUncheckedUpdateWithoutPostVotesInput>
    create: XOR<UserCreateWithoutPostVotesInput, UserUncheckedCreateWithoutPostVotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostVotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostVotesInput, UserUncheckedUpdateWithoutPostVotesInput>
  }

  export type UserUpdateWithoutPostVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    fandomScore?: IntFieldUpdateOperationsInput | number
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    solanaWalletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyConnected?: BoolFieldUpdateOperationsInput | boolean
    eventsAttended?: IntFieldUpdateOperationsInput | number
    vouchesGiven?: IntFieldUpdateOperationsInput | number
    vouchesReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutOwnerNestedInput
    posts?: CommunityPostUpdateManyWithoutAuthorNestedInput
    memberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentVotes?: CommentVoteUpdateManyWithoutUserNestedInput
    reminders?: EventReminderUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    fanIQBadges?: FanIQBadgeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    fandomScore?: IntFieldUpdateOperationsInput | number
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    solanaWalletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyConnected?: BoolFieldUpdateOperationsInput | boolean
    eventsAttended?: IntFieldUpdateOperationsInput | number
    vouchesGiven?: IntFieldUpdateOperationsInput | number
    vouchesReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutOwnerNestedInput
    posts?: CommunityPostUncheckedUpdateManyWithoutAuthorNestedInput
    memberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentVotes?: CommentVoteUncheckedUpdateManyWithoutUserNestedInput
    reminders?: EventReminderUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    fanIQBadges?: FanIQBadgeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMembershipsInput = {
    id?: string
    auth0Id: string
    email: string
    name: string
    avatar?: string | null
    fandomScore?: number
    walletAddress?: string | null
    solanaWalletAddress?: string | null
    spotifyConnected?: boolean
    eventsAttended?: number
    vouchesGiven?: number
    vouchesReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketCreateNestedManyWithoutOwnerInput
    posts?: CommunityPostCreateNestedManyWithoutAuthorInput
    postVotes?: PostVoteCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentVotes?: CommentVoteCreateNestedManyWithoutUserInput
    reminders?: EventReminderCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    fanIQBadges?: FanIQBadgeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMembershipsInput = {
    id?: string
    auth0Id: string
    email: string
    name: string
    avatar?: string | null
    fandomScore?: number
    walletAddress?: string | null
    solanaWalletAddress?: string | null
    spotifyConnected?: boolean
    eventsAttended?: number
    vouchesGiven?: number
    vouchesReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutOwnerInput
    posts?: CommunityPostUncheckedCreateNestedManyWithoutAuthorInput
    postVotes?: PostVoteUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentVotes?: CommentVoteUncheckedCreateNestedManyWithoutUserInput
    reminders?: EventReminderUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    fanIQBadges?: FanIQBadgeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
  }

  export type CommunityCreateWithoutMembersInput = {
    id?: string
    name: string
    artistId: string
    artistName: string
    artistImage: string
    description: string
    memberCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: CommunityPostCreateNestedManyWithoutCommunityInput
    proposals?: GovernanceProposalCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
    artistId: string
    artistName: string
    artistImage: string
    description: string
    memberCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: CommunityPostUncheckedCreateNestedManyWithoutCommunityInput
    proposals?: GovernanceProposalUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutMembersInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutMembersInput, CommunityUncheckedCreateWithoutMembersInput>
  }

  export type UserUpsertWithoutMembershipsInput = {
    update: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>
    create: XOR<UserCreateWithoutMembershipsInput, UserUncheckedCreateWithoutMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMembershipsInput, UserUncheckedUpdateWithoutMembershipsInput>
  }

  export type UserUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    fandomScore?: IntFieldUpdateOperationsInput | number
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    solanaWalletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyConnected?: BoolFieldUpdateOperationsInput | boolean
    eventsAttended?: IntFieldUpdateOperationsInput | number
    vouchesGiven?: IntFieldUpdateOperationsInput | number
    vouchesReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutOwnerNestedInput
    posts?: CommunityPostUpdateManyWithoutAuthorNestedInput
    postVotes?: PostVoteUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentVotes?: CommentVoteUpdateManyWithoutUserNestedInput
    reminders?: EventReminderUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    fanIQBadges?: FanIQBadgeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    fandomScore?: IntFieldUpdateOperationsInput | number
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    solanaWalletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyConnected?: BoolFieldUpdateOperationsInput | boolean
    eventsAttended?: IntFieldUpdateOperationsInput | number
    vouchesGiven?: IntFieldUpdateOperationsInput | number
    vouchesReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutOwnerNestedInput
    posts?: CommunityPostUncheckedUpdateManyWithoutAuthorNestedInput
    postVotes?: PostVoteUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentVotes?: CommentVoteUncheckedUpdateManyWithoutUserNestedInput
    reminders?: EventReminderUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    fanIQBadges?: FanIQBadgeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommunityUpsertWithoutMembersInput = {
    update: XOR<CommunityUpdateWithoutMembersInput, CommunityUncheckedUpdateWithoutMembersInput>
    create: XOR<CommunityCreateWithoutMembersInput, CommunityUncheckedCreateWithoutMembersInput>
    where?: CommunityWhereInput
  }

  export type CommunityUpdateToOneWithWhereWithoutMembersInput = {
    where?: CommunityWhereInput
    data: XOR<CommunityUpdateWithoutMembersInput, CommunityUncheckedUpdateWithoutMembersInput>
  }

  export type CommunityUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    artistImage?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    memberCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: CommunityPostUpdateManyWithoutCommunityNestedInput
    proposals?: GovernanceProposalUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    artistImage?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    memberCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: CommunityPostUncheckedUpdateManyWithoutCommunityNestedInput
    proposals?: GovernanceProposalUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityCreateWithoutProposalsInput = {
    id?: string
    name: string
    artistId: string
    artistName: string
    artistImage: string
    description: string
    memberCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: CommunityPostCreateNestedManyWithoutCommunityInput
    members?: CommunityMemberCreateNestedManyWithoutCommunityInput
  }

  export type CommunityUncheckedCreateWithoutProposalsInput = {
    id?: string
    name: string
    artistId: string
    artistName: string
    artistImage: string
    description: string
    memberCount?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: CommunityPostUncheckedCreateNestedManyWithoutCommunityInput
    members?: CommunityMemberUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type CommunityCreateOrConnectWithoutProposalsInput = {
    where: CommunityWhereUniqueInput
    create: XOR<CommunityCreateWithoutProposalsInput, CommunityUncheckedCreateWithoutProposalsInput>
  }

  export type ProposalOptionCreateWithoutProposalInput = {
    id?: string
    text: string
    votes?: number
  }

  export type ProposalOptionUncheckedCreateWithoutProposalInput = {
    id?: string
    text: string
    votes?: number
  }

  export type ProposalOptionCreateOrConnectWithoutProposalInput = {
    where: ProposalOptionWhereUniqueInput
    create: XOR<ProposalOptionCreateWithoutProposalInput, ProposalOptionUncheckedCreateWithoutProposalInput>
  }

  export type ProposalOptionCreateManyProposalInputEnvelope = {
    data: ProposalOptionCreateManyProposalInput | ProposalOptionCreateManyProposalInput[]
    skipDuplicates?: boolean
  }

  export type CommunityUpsertWithoutProposalsInput = {
    update: XOR<CommunityUpdateWithoutProposalsInput, CommunityUncheckedUpdateWithoutProposalsInput>
    create: XOR<CommunityCreateWithoutProposalsInput, CommunityUncheckedCreateWithoutProposalsInput>
    where?: CommunityWhereInput
  }

  export type CommunityUpdateToOneWithWhereWithoutProposalsInput = {
    where?: CommunityWhereInput
    data: XOR<CommunityUpdateWithoutProposalsInput, CommunityUncheckedUpdateWithoutProposalsInput>
  }

  export type CommunityUpdateWithoutProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    artistImage?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    memberCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: CommunityPostUpdateManyWithoutCommunityNestedInput
    members?: CommunityMemberUpdateManyWithoutCommunityNestedInput
  }

  export type CommunityUncheckedUpdateWithoutProposalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    artistImage?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    memberCount?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: CommunityPostUncheckedUpdateManyWithoutCommunityNestedInput
    members?: CommunityMemberUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type ProposalOptionUpsertWithWhereUniqueWithoutProposalInput = {
    where: ProposalOptionWhereUniqueInput
    update: XOR<ProposalOptionUpdateWithoutProposalInput, ProposalOptionUncheckedUpdateWithoutProposalInput>
    create: XOR<ProposalOptionCreateWithoutProposalInput, ProposalOptionUncheckedCreateWithoutProposalInput>
  }

  export type ProposalOptionUpdateWithWhereUniqueWithoutProposalInput = {
    where: ProposalOptionWhereUniqueInput
    data: XOR<ProposalOptionUpdateWithoutProposalInput, ProposalOptionUncheckedUpdateWithoutProposalInput>
  }

  export type ProposalOptionUpdateManyWithWhereWithoutProposalInput = {
    where: ProposalOptionScalarWhereInput
    data: XOR<ProposalOptionUpdateManyMutationInput, ProposalOptionUncheckedUpdateManyWithoutProposalInput>
  }

  export type ProposalOptionScalarWhereInput = {
    AND?: ProposalOptionScalarWhereInput | ProposalOptionScalarWhereInput[]
    OR?: ProposalOptionScalarWhereInput[]
    NOT?: ProposalOptionScalarWhereInput | ProposalOptionScalarWhereInput[]
    id?: StringFilter<"ProposalOption"> | string
    proposalId?: StringFilter<"ProposalOption"> | string
    text?: StringFilter<"ProposalOption"> | string
    votes?: IntFilter<"ProposalOption"> | number
  }

  export type GovernanceProposalCreateWithoutOptionsInput = {
    id?: string
    proposerId: string
    title: string
    description: string
    type: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    quorumRequired: number
    totalVotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    community: CommunityCreateNestedOneWithoutProposalsInput
  }

  export type GovernanceProposalUncheckedCreateWithoutOptionsInput = {
    id?: string
    communityId: string
    proposerId: string
    title: string
    description: string
    type: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    quorumRequired: number
    totalVotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GovernanceProposalCreateOrConnectWithoutOptionsInput = {
    where: GovernanceProposalWhereUniqueInput
    create: XOR<GovernanceProposalCreateWithoutOptionsInput, GovernanceProposalUncheckedCreateWithoutOptionsInput>
  }

  export type GovernanceProposalUpsertWithoutOptionsInput = {
    update: XOR<GovernanceProposalUpdateWithoutOptionsInput, GovernanceProposalUncheckedUpdateWithoutOptionsInput>
    create: XOR<GovernanceProposalCreateWithoutOptionsInput, GovernanceProposalUncheckedCreateWithoutOptionsInput>
    where?: GovernanceProposalWhereInput
  }

  export type GovernanceProposalUpdateToOneWithWhereWithoutOptionsInput = {
    where?: GovernanceProposalWhereInput
    data: XOR<GovernanceProposalUpdateWithoutOptionsInput, GovernanceProposalUncheckedUpdateWithoutOptionsInput>
  }

  export type GovernanceProposalUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quorumRequired?: IntFieldUpdateOperationsInput | number
    totalVotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    community?: CommunityUpdateOneRequiredWithoutProposalsNestedInput
  }

  export type GovernanceProposalUncheckedUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    communityId?: StringFieldUpdateOperationsInput | string
    proposerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quorumRequired?: IntFieldUpdateOperationsInput | number
    totalVotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityPostCreateWithoutCommentsInput = {
    id?: string
    title: string
    content: string
    type?: string
    images?: CommunityPostCreateimagesInput | string[]
    upvotes?: number
    downvotes?: number
    commentCount?: number
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    community: CommunityCreateNestedOneWithoutPostsInput
    author: UserCreateNestedOneWithoutPostsInput
    votes?: PostVoteCreateNestedManyWithoutPostInput
  }

  export type CommunityPostUncheckedCreateWithoutCommentsInput = {
    id?: string
    communityId: string
    authorId: string
    title: string
    content: string
    type?: string
    images?: CommunityPostCreateimagesInput | string[]
    upvotes?: number
    downvotes?: number
    commentCount?: number
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: PostVoteUncheckedCreateNestedManyWithoutPostInput
  }

  export type CommunityPostCreateOrConnectWithoutCommentsInput = {
    where: CommunityPostWhereUniqueInput
    create: XOR<CommunityPostCreateWithoutCommentsInput, CommunityPostUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    auth0Id: string
    email: string
    name: string
    avatar?: string | null
    fandomScore?: number
    walletAddress?: string | null
    solanaWalletAddress?: string | null
    spotifyConnected?: boolean
    eventsAttended?: number
    vouchesGiven?: number
    vouchesReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketCreateNestedManyWithoutOwnerInput
    posts?: CommunityPostCreateNestedManyWithoutAuthorInput
    memberships?: CommunityMemberCreateNestedManyWithoutUserInput
    postVotes?: PostVoteCreateNestedManyWithoutUserInput
    commentVotes?: CommentVoteCreateNestedManyWithoutUserInput
    reminders?: EventReminderCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    fanIQBadges?: FanIQBadgeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    auth0Id: string
    email: string
    name: string
    avatar?: string | null
    fandomScore?: number
    walletAddress?: string | null
    solanaWalletAddress?: string | null
    spotifyConnected?: boolean
    eventsAttended?: number
    vouchesGiven?: number
    vouchesReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutOwnerInput
    posts?: CommunityPostUncheckedCreateNestedManyWithoutAuthorInput
    memberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    postVotes?: PostVoteUncheckedCreateNestedManyWithoutUserInput
    commentVotes?: CommentVoteUncheckedCreateNestedManyWithoutUserInput
    reminders?: EventReminderUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    fanIQBadges?: FanIQBadgeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type CommentCreateWithoutChildrenInput = {
    id?: string
    content: string
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    post: CommunityPostCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutChildrenInput
    votes?: CommentVoteCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutChildrenInput = {
    id?: string
    content: string
    postId: string
    authorId: string
    parentId?: string | null
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: CommentVoteUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutChildrenInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutChildrenInput, CommentUncheckedCreateWithoutChildrenInput>
  }

  export type CommentCreateWithoutParentInput = {
    id?: string
    content: string
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    post: CommunityPostCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutCommentsInput
    children?: CommentCreateNestedManyWithoutParentInput
    votes?: CommentVoteCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutParentInput = {
    id?: string
    content: string
    postId: string
    authorId: string
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CommentUncheckedCreateNestedManyWithoutParentInput
    votes?: CommentVoteUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutParentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentCreateManyParentInputEnvelope = {
    data: CommentCreateManyParentInput | CommentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type CommentVoteCreateWithoutCommentInput = {
    id?: string
    type: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCommentVotesInput
  }

  export type CommentVoteUncheckedCreateWithoutCommentInput = {
    id?: string
    userId: string
    type: string
    createdAt?: Date | string
  }

  export type CommentVoteCreateOrConnectWithoutCommentInput = {
    where: CommentVoteWhereUniqueInput
    create: XOR<CommentVoteCreateWithoutCommentInput, CommentVoteUncheckedCreateWithoutCommentInput>
  }

  export type CommentVoteCreateManyCommentInputEnvelope = {
    data: CommentVoteCreateManyCommentInput | CommentVoteCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type CommunityPostUpsertWithoutCommentsInput = {
    update: XOR<CommunityPostUpdateWithoutCommentsInput, CommunityPostUncheckedUpdateWithoutCommentsInput>
    create: XOR<CommunityPostCreateWithoutCommentsInput, CommunityPostUncheckedCreateWithoutCommentsInput>
    where?: CommunityPostWhereInput
  }

  export type CommunityPostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: CommunityPostWhereInput
    data: XOR<CommunityPostUpdateWithoutCommentsInput, CommunityPostUncheckedUpdateWithoutCommentsInput>
  }

  export type CommunityPostUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    images?: CommunityPostUpdateimagesInput | string[]
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    community?: CommunityUpdateOneRequiredWithoutPostsNestedInput
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
    votes?: PostVoteUpdateManyWithoutPostNestedInput
  }

  export type CommunityPostUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    communityId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    images?: CommunityPostUpdateimagesInput | string[]
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: PostVoteUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    fandomScore?: IntFieldUpdateOperationsInput | number
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    solanaWalletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyConnected?: BoolFieldUpdateOperationsInput | boolean
    eventsAttended?: IntFieldUpdateOperationsInput | number
    vouchesGiven?: IntFieldUpdateOperationsInput | number
    vouchesReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutOwnerNestedInput
    posts?: CommunityPostUpdateManyWithoutAuthorNestedInput
    memberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    postVotes?: PostVoteUpdateManyWithoutUserNestedInput
    commentVotes?: CommentVoteUpdateManyWithoutUserNestedInput
    reminders?: EventReminderUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    fanIQBadges?: FanIQBadgeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    fandomScore?: IntFieldUpdateOperationsInput | number
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    solanaWalletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyConnected?: BoolFieldUpdateOperationsInput | boolean
    eventsAttended?: IntFieldUpdateOperationsInput | number
    vouchesGiven?: IntFieldUpdateOperationsInput | number
    vouchesReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutOwnerNestedInput
    posts?: CommunityPostUncheckedUpdateManyWithoutAuthorNestedInput
    memberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    postVotes?: PostVoteUncheckedUpdateManyWithoutUserNestedInput
    commentVotes?: CommentVoteUncheckedUpdateManyWithoutUserNestedInput
    reminders?: EventReminderUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    fanIQBadges?: FanIQBadgeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentUpsertWithoutChildrenInput = {
    update: XOR<CommentUpdateWithoutChildrenInput, CommentUncheckedUpdateWithoutChildrenInput>
    create: XOR<CommentCreateWithoutChildrenInput, CommentUncheckedCreateWithoutChildrenInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutChildrenInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutChildrenInput, CommentUncheckedUpdateWithoutChildrenInput>
  }

  export type CommentUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: CommunityPostUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutChildrenNestedInput
    votes?: CommentVoteUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: CommentVoteUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
    create: XOR<CommentCreateWithoutParentInput, CommentUncheckedCreateWithoutParentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutParentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutParentInput, CommentUncheckedUpdateWithoutParentInput>
  }

  export type CommentUpdateManyWithWhereWithoutParentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutParentInput>
  }

  export type CommentVoteUpsertWithWhereUniqueWithoutCommentInput = {
    where: CommentVoteWhereUniqueInput
    update: XOR<CommentVoteUpdateWithoutCommentInput, CommentVoteUncheckedUpdateWithoutCommentInput>
    create: XOR<CommentVoteCreateWithoutCommentInput, CommentVoteUncheckedCreateWithoutCommentInput>
  }

  export type CommentVoteUpdateWithWhereUniqueWithoutCommentInput = {
    where: CommentVoteWhereUniqueInput
    data: XOR<CommentVoteUpdateWithoutCommentInput, CommentVoteUncheckedUpdateWithoutCommentInput>
  }

  export type CommentVoteUpdateManyWithWhereWithoutCommentInput = {
    where: CommentVoteScalarWhereInput
    data: XOR<CommentVoteUpdateManyMutationInput, CommentVoteUncheckedUpdateManyWithoutCommentInput>
  }

  export type CommentCreateWithoutVotesInput = {
    id?: string
    content: string
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    post: CommunityPostCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutCommentsInput
    parent?: CommentCreateNestedOneWithoutChildrenInput
    children?: CommentCreateNestedManyWithoutParentInput
  }

  export type CommentUncheckedCreateWithoutVotesInput = {
    id?: string
    content: string
    postId: string
    authorId: string
    parentId?: string | null
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CommentUncheckedCreateNestedManyWithoutParentInput
  }

  export type CommentCreateOrConnectWithoutVotesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutVotesInput, CommentUncheckedCreateWithoutVotesInput>
  }

  export type UserCreateWithoutCommentVotesInput = {
    id?: string
    auth0Id: string
    email: string
    name: string
    avatar?: string | null
    fandomScore?: number
    walletAddress?: string | null
    solanaWalletAddress?: string | null
    spotifyConnected?: boolean
    eventsAttended?: number
    vouchesGiven?: number
    vouchesReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketCreateNestedManyWithoutOwnerInput
    posts?: CommunityPostCreateNestedManyWithoutAuthorInput
    memberships?: CommunityMemberCreateNestedManyWithoutUserInput
    postVotes?: PostVoteCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    reminders?: EventReminderCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
    fanIQBadges?: FanIQBadgeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentVotesInput = {
    id?: string
    auth0Id: string
    email: string
    name: string
    avatar?: string | null
    fandomScore?: number
    walletAddress?: string | null
    solanaWalletAddress?: string | null
    spotifyConnected?: boolean
    eventsAttended?: number
    vouchesGiven?: number
    vouchesReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutOwnerInput
    posts?: CommunityPostUncheckedCreateNestedManyWithoutAuthorInput
    memberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    postVotes?: PostVoteUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    reminders?: EventReminderUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
    fanIQBadges?: FanIQBadgeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentVotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentVotesInput, UserUncheckedCreateWithoutCommentVotesInput>
  }

  export type CommentUpsertWithoutVotesInput = {
    update: XOR<CommentUpdateWithoutVotesInput, CommentUncheckedUpdateWithoutVotesInput>
    create: XOR<CommentCreateWithoutVotesInput, CommentUncheckedCreateWithoutVotesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutVotesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutVotesInput, CommentUncheckedUpdateWithoutVotesInput>
  }

  export type CommentUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: CommunityPostUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutChildrenNestedInput
    children?: CommentUpdateManyWithoutParentNestedInput
  }

  export type CommentUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CommentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type UserUpsertWithoutCommentVotesInput = {
    update: XOR<UserUpdateWithoutCommentVotesInput, UserUncheckedUpdateWithoutCommentVotesInput>
    create: XOR<UserCreateWithoutCommentVotesInput, UserUncheckedCreateWithoutCommentVotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentVotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentVotesInput, UserUncheckedUpdateWithoutCommentVotesInput>
  }

  export type UserUpdateWithoutCommentVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    fandomScore?: IntFieldUpdateOperationsInput | number
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    solanaWalletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyConnected?: BoolFieldUpdateOperationsInput | boolean
    eventsAttended?: IntFieldUpdateOperationsInput | number
    vouchesGiven?: IntFieldUpdateOperationsInput | number
    vouchesReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutOwnerNestedInput
    posts?: CommunityPostUpdateManyWithoutAuthorNestedInput
    memberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    postVotes?: PostVoteUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    reminders?: EventReminderUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
    fanIQBadges?: FanIQBadgeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    fandomScore?: IntFieldUpdateOperationsInput | number
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    solanaWalletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyConnected?: BoolFieldUpdateOperationsInput | boolean
    eventsAttended?: IntFieldUpdateOperationsInput | number
    vouchesGiven?: IntFieldUpdateOperationsInput | number
    vouchesReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutOwnerNestedInput
    posts?: CommunityPostUncheckedUpdateManyWithoutAuthorNestedInput
    memberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    postVotes?: PostVoteUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    reminders?: EventReminderUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
    fanIQBadges?: FanIQBadgeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type QuizQuestionCreateWithoutQuizInput = {
    id?: string
    question: string
    type: string
    options?: QuizQuestionCreateoptionsInput | string[]
    correctAnswer: string
    imageUrl?: string | null
    timeLimit?: number
    difficulty?: string
    orderIndex: number
    createdAt?: Date | string
  }

  export type QuizQuestionUncheckedCreateWithoutQuizInput = {
    id?: string
    question: string
    type: string
    options?: QuizQuestionCreateoptionsInput | string[]
    correctAnswer: string
    imageUrl?: string | null
    timeLimit?: number
    difficulty?: string
    orderIndex: number
    createdAt?: Date | string
  }

  export type QuizQuestionCreateOrConnectWithoutQuizInput = {
    where: QuizQuestionWhereUniqueInput
    create: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput>
  }

  export type QuizQuestionCreateManyQuizInputEnvelope = {
    data: QuizQuestionCreateManyQuizInput | QuizQuestionCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type QuizAttemptCreateWithoutQuizInput = {
    id?: string
    correctAnswers?: number
    totalQuestions: number
    avgResponseTime?: number
    responseTimeStdDev?: number
    streak?: number
    maxStreak?: number
    finalScore?: number
    speedScore?: number
    accuracyScore?: number
    consistencyScore?: number
    rank?: number | null
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    user: UserCreateNestedOneWithoutQuizAttemptsInput
    responses?: QuizResponseCreateNestedManyWithoutAttemptInput
  }

  export type QuizAttemptUncheckedCreateWithoutQuizInput = {
    id?: string
    userId: string
    correctAnswers?: number
    totalQuestions: number
    avgResponseTime?: number
    responseTimeStdDev?: number
    streak?: number
    maxStreak?: number
    finalScore?: number
    speedScore?: number
    accuracyScore?: number
    consistencyScore?: number
    rank?: number | null
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    responses?: QuizResponseUncheckedCreateNestedManyWithoutAttemptInput
  }

  export type QuizAttemptCreateOrConnectWithoutQuizInput = {
    where: QuizAttemptWhereUniqueInput
    create: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput>
  }

  export type QuizAttemptCreateManyQuizInputEnvelope = {
    data: QuizAttemptCreateManyQuizInput | QuizAttemptCreateManyQuizInput[]
    skipDuplicates?: boolean
  }

  export type QuizQuestionUpsertWithWhereUniqueWithoutQuizInput = {
    where: QuizQuestionWhereUniqueInput
    update: XOR<QuizQuestionUpdateWithoutQuizInput, QuizQuestionUncheckedUpdateWithoutQuizInput>
    create: XOR<QuizQuestionCreateWithoutQuizInput, QuizQuestionUncheckedCreateWithoutQuizInput>
  }

  export type QuizQuestionUpdateWithWhereUniqueWithoutQuizInput = {
    where: QuizQuestionWhereUniqueInput
    data: XOR<QuizQuestionUpdateWithoutQuizInput, QuizQuestionUncheckedUpdateWithoutQuizInput>
  }

  export type QuizQuestionUpdateManyWithWhereWithoutQuizInput = {
    where: QuizQuestionScalarWhereInput
    data: XOR<QuizQuestionUpdateManyMutationInput, QuizQuestionUncheckedUpdateManyWithoutQuizInput>
  }

  export type QuizQuestionScalarWhereInput = {
    AND?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
    OR?: QuizQuestionScalarWhereInput[]
    NOT?: QuizQuestionScalarWhereInput | QuizQuestionScalarWhereInput[]
    id?: StringFilter<"QuizQuestion"> | string
    quizId?: StringFilter<"QuizQuestion"> | string
    question?: StringFilter<"QuizQuestion"> | string
    type?: StringFilter<"QuizQuestion"> | string
    options?: StringNullableListFilter<"QuizQuestion">
    correctAnswer?: StringFilter<"QuizQuestion"> | string
    imageUrl?: StringNullableFilter<"QuizQuestion"> | string | null
    timeLimit?: IntFilter<"QuizQuestion"> | number
    difficulty?: StringFilter<"QuizQuestion"> | string
    orderIndex?: IntFilter<"QuizQuestion"> | number
    createdAt?: DateTimeFilter<"QuizQuestion"> | Date | string
  }

  export type QuizAttemptUpsertWithWhereUniqueWithoutQuizInput = {
    where: QuizAttemptWhereUniqueInput
    update: XOR<QuizAttemptUpdateWithoutQuizInput, QuizAttemptUncheckedUpdateWithoutQuizInput>
    create: XOR<QuizAttemptCreateWithoutQuizInput, QuizAttemptUncheckedCreateWithoutQuizInput>
  }

  export type QuizAttemptUpdateWithWhereUniqueWithoutQuizInput = {
    where: QuizAttemptWhereUniqueInput
    data: XOR<QuizAttemptUpdateWithoutQuizInput, QuizAttemptUncheckedUpdateWithoutQuizInput>
  }

  export type QuizAttemptUpdateManyWithWhereWithoutQuizInput = {
    where: QuizAttemptScalarWhereInput
    data: XOR<QuizAttemptUpdateManyMutationInput, QuizAttemptUncheckedUpdateManyWithoutQuizInput>
  }

  export type QuizCreateWithoutQuestionsInput = {
    id?: string
    eventId?: string | null
    artistId: string
    artistName: string
    type: string
    status?: string
    duration?: number
    questionCount?: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attempts?: QuizAttemptCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutQuestionsInput = {
    id?: string
    eventId?: string | null
    artistId: string
    artistName: string
    type: string
    status?: string
    duration?: number
    questionCount?: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attempts?: QuizAttemptUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutQuestionsInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
  }

  export type QuizUpsertWithoutQuestionsInput = {
    update: XOR<QuizUpdateWithoutQuestionsInput, QuizUncheckedUpdateWithoutQuestionsInput>
    create: XOR<QuizCreateWithoutQuestionsInput, QuizUncheckedCreateWithoutQuestionsInput>
    where?: QuizWhereInput
  }

  export type QuizUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: QuizWhereInput
    data: XOR<QuizUpdateWithoutQuestionsInput, QuizUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuizUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    artistId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    questionCount?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: QuizAttemptUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    artistId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    questionCount?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attempts?: QuizAttemptUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type QuizCreateWithoutAttemptsInput = {
    id?: string
    eventId?: string | null
    artistId: string
    artistName: string
    type: string
    status?: string
    duration?: number
    questionCount?: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuizQuestionCreateNestedManyWithoutQuizInput
  }

  export type QuizUncheckedCreateWithoutAttemptsInput = {
    id?: string
    eventId?: string | null
    artistId: string
    artistName: string
    type: string
    status?: string
    duration?: number
    questionCount?: number
    startTime?: Date | string | null
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuizQuestionUncheckedCreateNestedManyWithoutQuizInput
  }

  export type QuizCreateOrConnectWithoutAttemptsInput = {
    where: QuizWhereUniqueInput
    create: XOR<QuizCreateWithoutAttemptsInput, QuizUncheckedCreateWithoutAttemptsInput>
  }

  export type UserCreateWithoutQuizAttemptsInput = {
    id?: string
    auth0Id: string
    email: string
    name: string
    avatar?: string | null
    fandomScore?: number
    walletAddress?: string | null
    solanaWalletAddress?: string | null
    spotifyConnected?: boolean
    eventsAttended?: number
    vouchesGiven?: number
    vouchesReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketCreateNestedManyWithoutOwnerInput
    posts?: CommunityPostCreateNestedManyWithoutAuthorInput
    memberships?: CommunityMemberCreateNestedManyWithoutUserInput
    postVotes?: PostVoteCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentVotes?: CommentVoteCreateNestedManyWithoutUserInput
    reminders?: EventReminderCreateNestedManyWithoutUserInput
    fanIQBadges?: FanIQBadgeCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutQuizAttemptsInput = {
    id?: string
    auth0Id: string
    email: string
    name: string
    avatar?: string | null
    fandomScore?: number
    walletAddress?: string | null
    solanaWalletAddress?: string | null
    spotifyConnected?: boolean
    eventsAttended?: number
    vouchesGiven?: number
    vouchesReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutOwnerInput
    posts?: CommunityPostUncheckedCreateNestedManyWithoutAuthorInput
    memberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    postVotes?: PostVoteUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentVotes?: CommentVoteUncheckedCreateNestedManyWithoutUserInput
    reminders?: EventReminderUncheckedCreateNestedManyWithoutUserInput
    fanIQBadges?: FanIQBadgeUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutQuizAttemptsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutQuizAttemptsInput, UserUncheckedCreateWithoutQuizAttemptsInput>
  }

  export type QuizResponseCreateWithoutAttemptInput = {
    id?: string
    questionId: string
    answer: string
    isCorrect: boolean
    responseTime: number
    answeredAt?: Date | string
  }

  export type QuizResponseUncheckedCreateWithoutAttemptInput = {
    id?: string
    questionId: string
    answer: string
    isCorrect: boolean
    responseTime: number
    answeredAt?: Date | string
  }

  export type QuizResponseCreateOrConnectWithoutAttemptInput = {
    where: QuizResponseWhereUniqueInput
    create: XOR<QuizResponseCreateWithoutAttemptInput, QuizResponseUncheckedCreateWithoutAttemptInput>
  }

  export type QuizResponseCreateManyAttemptInputEnvelope = {
    data: QuizResponseCreateManyAttemptInput | QuizResponseCreateManyAttemptInput[]
    skipDuplicates?: boolean
  }

  export type QuizUpsertWithoutAttemptsInput = {
    update: XOR<QuizUpdateWithoutAttemptsInput, QuizUncheckedUpdateWithoutAttemptsInput>
    create: XOR<QuizCreateWithoutAttemptsInput, QuizUncheckedCreateWithoutAttemptsInput>
    where?: QuizWhereInput
  }

  export type QuizUpdateToOneWithWhereWithoutAttemptsInput = {
    where?: QuizWhereInput
    data: XOR<QuizUpdateWithoutAttemptsInput, QuizUncheckedUpdateWithoutAttemptsInput>
  }

  export type QuizUpdateWithoutAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    artistId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    questionCount?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuizQuestionUpdateManyWithoutQuizNestedInput
  }

  export type QuizUncheckedUpdateWithoutAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: NullableStringFieldUpdateOperationsInput | string | null
    artistId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    questionCount?: IntFieldUpdateOperationsInput | number
    startTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuizQuestionUncheckedUpdateManyWithoutQuizNestedInput
  }

  export type UserUpsertWithoutQuizAttemptsInput = {
    update: XOR<UserUpdateWithoutQuizAttemptsInput, UserUncheckedUpdateWithoutQuizAttemptsInput>
    create: XOR<UserCreateWithoutQuizAttemptsInput, UserUncheckedCreateWithoutQuizAttemptsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutQuizAttemptsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutQuizAttemptsInput, UserUncheckedUpdateWithoutQuizAttemptsInput>
  }

  export type UserUpdateWithoutQuizAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    fandomScore?: IntFieldUpdateOperationsInput | number
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    solanaWalletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyConnected?: BoolFieldUpdateOperationsInput | boolean
    eventsAttended?: IntFieldUpdateOperationsInput | number
    vouchesGiven?: IntFieldUpdateOperationsInput | number
    vouchesReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutOwnerNestedInput
    posts?: CommunityPostUpdateManyWithoutAuthorNestedInput
    memberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    postVotes?: PostVoteUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentVotes?: CommentVoteUpdateManyWithoutUserNestedInput
    reminders?: EventReminderUpdateManyWithoutUserNestedInput
    fanIQBadges?: FanIQBadgeUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutQuizAttemptsInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    fandomScore?: IntFieldUpdateOperationsInput | number
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    solanaWalletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyConnected?: BoolFieldUpdateOperationsInput | boolean
    eventsAttended?: IntFieldUpdateOperationsInput | number
    vouchesGiven?: IntFieldUpdateOperationsInput | number
    vouchesReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutOwnerNestedInput
    posts?: CommunityPostUncheckedUpdateManyWithoutAuthorNestedInput
    memberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    postVotes?: PostVoteUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentVotes?: CommentVoteUncheckedUpdateManyWithoutUserNestedInput
    reminders?: EventReminderUncheckedUpdateManyWithoutUserNestedInput
    fanIQBadges?: FanIQBadgeUncheckedUpdateManyWithoutUserNestedInput
  }

  export type QuizResponseUpsertWithWhereUniqueWithoutAttemptInput = {
    where: QuizResponseWhereUniqueInput
    update: XOR<QuizResponseUpdateWithoutAttemptInput, QuizResponseUncheckedUpdateWithoutAttemptInput>
    create: XOR<QuizResponseCreateWithoutAttemptInput, QuizResponseUncheckedCreateWithoutAttemptInput>
  }

  export type QuizResponseUpdateWithWhereUniqueWithoutAttemptInput = {
    where: QuizResponseWhereUniqueInput
    data: XOR<QuizResponseUpdateWithoutAttemptInput, QuizResponseUncheckedUpdateWithoutAttemptInput>
  }

  export type QuizResponseUpdateManyWithWhereWithoutAttemptInput = {
    where: QuizResponseScalarWhereInput
    data: XOR<QuizResponseUpdateManyMutationInput, QuizResponseUncheckedUpdateManyWithoutAttemptInput>
  }

  export type QuizResponseScalarWhereInput = {
    AND?: QuizResponseScalarWhereInput | QuizResponseScalarWhereInput[]
    OR?: QuizResponseScalarWhereInput[]
    NOT?: QuizResponseScalarWhereInput | QuizResponseScalarWhereInput[]
    id?: StringFilter<"QuizResponse"> | string
    attemptId?: StringFilter<"QuizResponse"> | string
    questionId?: StringFilter<"QuizResponse"> | string
    answer?: StringFilter<"QuizResponse"> | string
    isCorrect?: BoolFilter<"QuizResponse"> | boolean
    responseTime?: IntFilter<"QuizResponse"> | number
    answeredAt?: DateTimeFilter<"QuizResponse"> | Date | string
  }

  export type QuizAttemptCreateWithoutResponsesInput = {
    id?: string
    correctAnswers?: number
    totalQuestions: number
    avgResponseTime?: number
    responseTimeStdDev?: number
    streak?: number
    maxStreak?: number
    finalScore?: number
    speedScore?: number
    accuracyScore?: number
    consistencyScore?: number
    rank?: number | null
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
    quiz: QuizCreateNestedOneWithoutAttemptsInput
    user: UserCreateNestedOneWithoutQuizAttemptsInput
  }

  export type QuizAttemptUncheckedCreateWithoutResponsesInput = {
    id?: string
    quizId: string
    userId: string
    correctAnswers?: number
    totalQuestions: number
    avgResponseTime?: number
    responseTimeStdDev?: number
    streak?: number
    maxStreak?: number
    finalScore?: number
    speedScore?: number
    accuracyScore?: number
    consistencyScore?: number
    rank?: number | null
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type QuizAttemptCreateOrConnectWithoutResponsesInput = {
    where: QuizAttemptWhereUniqueInput
    create: XOR<QuizAttemptCreateWithoutResponsesInput, QuizAttemptUncheckedCreateWithoutResponsesInput>
  }

  export type QuizAttemptUpsertWithoutResponsesInput = {
    update: XOR<QuizAttemptUpdateWithoutResponsesInput, QuizAttemptUncheckedUpdateWithoutResponsesInput>
    create: XOR<QuizAttemptCreateWithoutResponsesInput, QuizAttemptUncheckedCreateWithoutResponsesInput>
    where?: QuizAttemptWhereInput
  }

  export type QuizAttemptUpdateToOneWithWhereWithoutResponsesInput = {
    where?: QuizAttemptWhereInput
    data: XOR<QuizAttemptUpdateWithoutResponsesInput, QuizAttemptUncheckedUpdateWithoutResponsesInput>
  }

  export type QuizAttemptUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    correctAnswers?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    responseTimeStdDev?: FloatFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    maxStreak?: IntFieldUpdateOperationsInput | number
    finalScore?: FloatFieldUpdateOperationsInput | number
    speedScore?: FloatFieldUpdateOperationsInput | number
    accuracyScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quiz?: QuizUpdateOneRequiredWithoutAttemptsNestedInput
    user?: UserUpdateOneRequiredWithoutQuizAttemptsNestedInput
  }

  export type QuizAttemptUncheckedUpdateWithoutResponsesInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    correctAnswers?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    responseTimeStdDev?: FloatFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    maxStreak?: IntFieldUpdateOperationsInput | number
    finalScore?: FloatFieldUpdateOperationsInput | number
    speedScore?: FloatFieldUpdateOperationsInput | number
    accuracyScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateWithoutFanIQBadgesInput = {
    id?: string
    auth0Id: string
    email: string
    name: string
    avatar?: string | null
    fandomScore?: number
    walletAddress?: string | null
    solanaWalletAddress?: string | null
    spotifyConnected?: boolean
    eventsAttended?: number
    vouchesGiven?: number
    vouchesReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketCreateNestedManyWithoutOwnerInput
    posts?: CommunityPostCreateNestedManyWithoutAuthorInput
    memberships?: CommunityMemberCreateNestedManyWithoutUserInput
    postVotes?: PostVoteCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentVotes?: CommentVoteCreateNestedManyWithoutUserInput
    reminders?: EventReminderCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFanIQBadgesInput = {
    id?: string
    auth0Id: string
    email: string
    name: string
    avatar?: string | null
    fandomScore?: number
    walletAddress?: string | null
    solanaWalletAddress?: string | null
    spotifyConnected?: boolean
    eventsAttended?: number
    vouchesGiven?: number
    vouchesReceived?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutOwnerInput
    posts?: CommunityPostUncheckedCreateNestedManyWithoutAuthorInput
    memberships?: CommunityMemberUncheckedCreateNestedManyWithoutUserInput
    postVotes?: PostVoteUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentVotes?: CommentVoteUncheckedCreateNestedManyWithoutUserInput
    reminders?: EventReminderUncheckedCreateNestedManyWithoutUserInput
    quizAttempts?: QuizAttemptUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFanIQBadgesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFanIQBadgesInput, UserUncheckedCreateWithoutFanIQBadgesInput>
  }

  export type UserUpsertWithoutFanIQBadgesInput = {
    update: XOR<UserUpdateWithoutFanIQBadgesInput, UserUncheckedUpdateWithoutFanIQBadgesInput>
    create: XOR<UserCreateWithoutFanIQBadgesInput, UserUncheckedCreateWithoutFanIQBadgesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFanIQBadgesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFanIQBadgesInput, UserUncheckedUpdateWithoutFanIQBadgesInput>
  }

  export type UserUpdateWithoutFanIQBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    fandomScore?: IntFieldUpdateOperationsInput | number
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    solanaWalletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyConnected?: BoolFieldUpdateOperationsInput | boolean
    eventsAttended?: IntFieldUpdateOperationsInput | number
    vouchesGiven?: IntFieldUpdateOperationsInput | number
    vouchesReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUpdateManyWithoutOwnerNestedInput
    posts?: CommunityPostUpdateManyWithoutAuthorNestedInput
    memberships?: CommunityMemberUpdateManyWithoutUserNestedInput
    postVotes?: PostVoteUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentVotes?: CommentVoteUpdateManyWithoutUserNestedInput
    reminders?: EventReminderUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFanIQBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    auth0Id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    fandomScore?: IntFieldUpdateOperationsInput | number
    walletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    solanaWalletAddress?: NullableStringFieldUpdateOperationsInput | string | null
    spotifyConnected?: BoolFieldUpdateOperationsInput | boolean
    eventsAttended?: IntFieldUpdateOperationsInput | number
    vouchesGiven?: IntFieldUpdateOperationsInput | number
    vouchesReceived?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutOwnerNestedInput
    posts?: CommunityPostUncheckedUpdateManyWithoutAuthorNestedInput
    memberships?: CommunityMemberUncheckedUpdateManyWithoutUserNestedInput
    postVotes?: PostVoteUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentVotes?: CommentVoteUncheckedUpdateManyWithoutUserNestedInput
    reminders?: EventReminderUncheckedUpdateManyWithoutUserNestedInput
    quizAttempts?: QuizAttemptUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TicketCreateManyOwnerInput = {
    id?: string
    eventId: string
    tierId: string
    originalPrice: number
    currentPrice: number
    purchaseDate?: Date | string
    status?: string
    qrCode?: string | null
    tokenId?: string | null
    txHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityPostCreateManyAuthorInput = {
    id?: string
    communityId: string
    title: string
    content: string
    type?: string
    images?: CommunityPostCreateimagesInput | string[]
    upvotes?: number
    downvotes?: number
    commentCount?: number
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityMemberCreateManyUserInput = {
    id?: string
    communityId: string
    role?: string
    reputationPoints?: number
    votingPower?: number
    isActive?: boolean
    joinedAt?: Date | string
  }

  export type PostVoteCreateManyUserInput = {
    id?: string
    postId: string
    type: string
    createdAt?: Date | string
  }

  export type CommentCreateManyAuthorInput = {
    id?: string
    content: string
    postId: string
    parentId?: string | null
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentVoteCreateManyUserInput = {
    id?: string
    commentId: string
    type: string
    createdAt?: Date | string
  }

  export type EventReminderCreateManyUserInput = {
    id?: string
    eventId: string
    createdAt?: Date | string
  }

  export type QuizAttemptCreateManyUserInput = {
    id?: string
    quizId: string
    correctAnswers?: number
    totalQuestions: number
    avgResponseTime?: number
    responseTimeStdDev?: number
    streak?: number
    maxStreak?: number
    finalScore?: number
    speedScore?: number
    accuracyScore?: number
    consistencyScore?: number
    rank?: number | null
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type FanIQBadgeCreateManyUserInput = {
    id?: string
    tier: string
    artistId: string
    artistName: string
    tokenId?: string | null
    txHash?: string | null
    earnedAt?: Date | string
  }

  export type TicketUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutTicketsNestedInput
    tier?: TicketTierUpdateOneRequiredWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    tierId?: StringFieldUpdateOperationsInput | string
    originalPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    tierId?: StringFieldUpdateOperationsInput | string
    originalPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityPostUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    images?: CommunityPostUpdateimagesInput | string[]
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    community?: CommunityUpdateOneRequiredWithoutPostsNestedInput
    votes?: PostVoteUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
  }

  export type CommunityPostUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    communityId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    images?: CommunityPostUpdateimagesInput | string[]
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: PostVoteUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type CommunityPostUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    communityId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    images?: CommunityPostUpdateimagesInput | string[]
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    reputationPoints?: IntFieldUpdateOperationsInput | number
    votingPower?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    community?: CommunityUpdateOneRequiredWithoutMembersNestedInput
  }

  export type CommunityMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    communityId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    reputationPoints?: IntFieldUpdateOperationsInput | number
    votingPower?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    communityId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    reputationPoints?: IntFieldUpdateOperationsInput | number
    votingPower?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostVoteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: CommunityPostUpdateOneRequiredWithoutVotesNestedInput
  }

  export type PostVoteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostVoteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: CommunityPostUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutChildrenNestedInput
    children?: CommentUpdateManyWithoutParentNestedInput
    votes?: CommentVoteUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CommentUncheckedUpdateManyWithoutParentNestedInput
    votes?: CommentVoteUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentVoteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneRequiredWithoutVotesNestedInput
  }

  export type CommentVoteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentVoteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventReminderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutRemindersNestedInput
  }

  export type EventReminderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventReminderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizAttemptUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    correctAnswers?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    responseTimeStdDev?: FloatFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    maxStreak?: IntFieldUpdateOperationsInput | number
    finalScore?: FloatFieldUpdateOperationsInput | number
    speedScore?: FloatFieldUpdateOperationsInput | number
    accuracyScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    quiz?: QuizUpdateOneRequiredWithoutAttemptsNestedInput
    responses?: QuizResponseUpdateManyWithoutAttemptNestedInput
  }

  export type QuizAttemptUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    correctAnswers?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    responseTimeStdDev?: FloatFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    maxStreak?: IntFieldUpdateOperationsInput | number
    finalScore?: FloatFieldUpdateOperationsInput | number
    speedScore?: FloatFieldUpdateOperationsInput | number
    accuracyScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responses?: QuizResponseUncheckedUpdateManyWithoutAttemptNestedInput
  }

  export type QuizAttemptUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    quizId?: StringFieldUpdateOperationsInput | string
    correctAnswers?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    responseTimeStdDev?: FloatFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    maxStreak?: IntFieldUpdateOperationsInput | number
    finalScore?: FloatFieldUpdateOperationsInput | number
    speedScore?: FloatFieldUpdateOperationsInput | number
    accuracyScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FanIQBadgeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FanIQBadgeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FanIQBadgeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tier?: StringFieldUpdateOperationsInput | string
    artistId?: StringFieldUpdateOperationsInput | string
    artistName?: StringFieldUpdateOperationsInput | string
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketTierCreateManyEventInput = {
    id?: string
    name: string
    price: number
    currency?: string
    description: string
    available: number
    total: number
    benefits?: TicketTierCreatebenefitsInput | string[]
  }

  export type TicketCreateManyEventInput = {
    id?: string
    tierId: string
    ownerId: string
    originalPrice: number
    currentPrice: number
    purchaseDate?: Date | string
    status?: string
    qrCode?: string | null
    tokenId?: string | null
    txHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventReminderCreateManyEventInput = {
    id?: string
    userId: string
    createdAt?: Date | string
  }

  export type TicketTierUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    available?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    benefits?: TicketTierUpdatebenefitsInput | string[]
    tickets?: TicketUpdateManyWithoutTierNestedInput
  }

  export type TicketTierUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    available?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    benefits?: TicketTierUpdatebenefitsInput | string[]
    tickets?: TicketUncheckedUpdateManyWithoutTierNestedInput
  }

  export type TicketTierUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    available?: IntFieldUpdateOperationsInput | number
    total?: IntFieldUpdateOperationsInput | number
    benefits?: TicketTierUpdatebenefitsInput | string[]
  }

  export type TicketUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tier?: TicketTierUpdateOneRequiredWithoutTicketsNestedInput
    owner?: UserUpdateOneRequiredWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    tierId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    originalPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    tierId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    originalPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventReminderUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRemindersNestedInput
  }

  export type EventReminderUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventReminderUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCreateManyTierInput = {
    id?: string
    eventId: string
    ownerId: string
    originalPrice: number
    currentPrice: number
    purchaseDate?: Date | string
    status?: string
    qrCode?: string | null
    tokenId?: string | null
    txHash?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketUpdateWithoutTierInput = {
    id?: StringFieldUpdateOperationsInput | string
    originalPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutTicketsNestedInput
    owner?: UserUpdateOneRequiredWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutTierInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    originalPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUncheckedUpdateManyWithoutTierInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    originalPrice?: FloatFieldUpdateOperationsInput | number
    currentPrice?: FloatFieldUpdateOperationsInput | number
    purchaseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    tokenId?: NullableStringFieldUpdateOperationsInput | string | null
    txHash?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityPostCreateManyCommunityInput = {
    id?: string
    authorId: string
    title: string
    content: string
    type?: string
    images?: CommunityPostCreateimagesInput | string[]
    upvotes?: number
    downvotes?: number
    commentCount?: number
    isPinned?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityMemberCreateManyCommunityInput = {
    id?: string
    userId: string
    role?: string
    reputationPoints?: number
    votingPower?: number
    isActive?: boolean
    joinedAt?: Date | string
  }

  export type GovernanceProposalCreateManyCommunityInput = {
    id?: string
    proposerId: string
    title: string
    description: string
    type: string
    status?: string
    startDate: Date | string
    endDate: Date | string
    quorumRequired: number
    totalVotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommunityPostUpdateWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    images?: CommunityPostUpdateimagesInput | string[]
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutPostsNestedInput
    votes?: PostVoteUpdateManyWithoutPostNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
  }

  export type CommunityPostUncheckedUpdateWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    images?: CommunityPostUpdateimagesInput | string[]
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: PostVoteUncheckedUpdateManyWithoutPostNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type CommunityPostUncheckedUpdateManyWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    images?: CommunityPostUpdateimagesInput | string[]
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    commentCount?: IntFieldUpdateOperationsInput | number
    isPinned?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityMemberUpdateWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    reputationPoints?: IntFieldUpdateOperationsInput | number
    votingPower?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type CommunityMemberUncheckedUpdateWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    reputationPoints?: IntFieldUpdateOperationsInput | number
    votingPower?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommunityMemberUncheckedUpdateManyWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    reputationPoints?: IntFieldUpdateOperationsInput | number
    votingPower?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GovernanceProposalUpdateWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quorumRequired?: IntFieldUpdateOperationsInput | number
    totalVotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: ProposalOptionUpdateManyWithoutProposalNestedInput
  }

  export type GovernanceProposalUncheckedUpdateWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quorumRequired?: IntFieldUpdateOperationsInput | number
    totalVotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: ProposalOptionUncheckedUpdateManyWithoutProposalNestedInput
  }

  export type GovernanceProposalUncheckedUpdateManyWithoutCommunityInput = {
    id?: StringFieldUpdateOperationsInput | string
    proposerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    quorumRequired?: IntFieldUpdateOperationsInput | number
    totalVotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostVoteCreateManyPostInput = {
    id?: string
    userId: string
    type: string
    createdAt?: Date | string
  }

  export type CommentCreateManyPostInput = {
    id?: string
    content: string
    authorId: string
    parentId?: string | null
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostVoteUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPostVotesNestedInput
  }

  export type PostVoteUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostVoteUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    parent?: CommentUpdateOneWithoutChildrenNestedInput
    children?: CommentUpdateManyWithoutParentNestedInput
    votes?: CommentVoteUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CommentUncheckedUpdateManyWithoutParentNestedInput
    votes?: CommentVoteUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProposalOptionCreateManyProposalInput = {
    id?: string
    text: string
    votes?: number
  }

  export type ProposalOptionUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
  }

  export type ProposalOptionUncheckedUpdateWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
  }

  export type ProposalOptionUncheckedUpdateManyWithoutProposalInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    votes?: IntFieldUpdateOperationsInput | number
  }

  export type CommentCreateManyParentInput = {
    id?: string
    content: string
    postId: string
    authorId: string
    upvotes?: number
    downvotes?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentVoteCreateManyCommentInput = {
    id?: string
    userId: string
    type: string
    createdAt?: Date | string
  }

  export type CommentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: CommunityPostUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    children?: CommentUpdateManyWithoutParentNestedInput
    votes?: CommentVoteUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CommentUncheckedUpdateManyWithoutParentNestedInput
    votes?: CommentVoteUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentVoteUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommentVotesNestedInput
  }

  export type CommentVoteUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentVoteUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionCreateManyQuizInput = {
    id?: string
    question: string
    type: string
    options?: QuizQuestionCreateoptionsInput | string[]
    correctAnswer: string
    imageUrl?: string | null
    timeLimit?: number
    difficulty?: string
    orderIndex: number
    createdAt?: Date | string
  }

  export type QuizAttemptCreateManyQuizInput = {
    id?: string
    userId: string
    correctAnswers?: number
    totalQuestions: number
    avgResponseTime?: number
    responseTimeStdDev?: number
    streak?: number
    maxStreak?: number
    finalScore?: number
    speedScore?: number
    accuracyScore?: number
    consistencyScore?: number
    rank?: number | null
    status?: string
    startedAt?: Date | string
    completedAt?: Date | string | null
  }

  export type QuizQuestionUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: QuizQuestionUpdateoptionsInput | string[]
    correctAnswer?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionUncheckedUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: QuizQuestionUpdateoptionsInput | string[]
    correctAnswer?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizQuestionUncheckedUpdateManyWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    options?: QuizQuestionUpdateoptionsInput | string[]
    correctAnswer?: StringFieldUpdateOperationsInput | string
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    timeLimit?: IntFieldUpdateOperationsInput | number
    difficulty?: StringFieldUpdateOperationsInput | string
    orderIndex?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizAttemptUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    correctAnswers?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    responseTimeStdDev?: FloatFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    maxStreak?: IntFieldUpdateOperationsInput | number
    finalScore?: FloatFieldUpdateOperationsInput | number
    speedScore?: FloatFieldUpdateOperationsInput | number
    accuracyScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutQuizAttemptsNestedInput
    responses?: QuizResponseUpdateManyWithoutAttemptNestedInput
  }

  export type QuizAttemptUncheckedUpdateWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    correctAnswers?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    responseTimeStdDev?: FloatFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    maxStreak?: IntFieldUpdateOperationsInput | number
    finalScore?: FloatFieldUpdateOperationsInput | number
    speedScore?: FloatFieldUpdateOperationsInput | number
    accuracyScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responses?: QuizResponseUncheckedUpdateManyWithoutAttemptNestedInput
  }

  export type QuizAttemptUncheckedUpdateManyWithoutQuizInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    correctAnswers?: IntFieldUpdateOperationsInput | number
    totalQuestions?: IntFieldUpdateOperationsInput | number
    avgResponseTime?: FloatFieldUpdateOperationsInput | number
    responseTimeStdDev?: FloatFieldUpdateOperationsInput | number
    streak?: IntFieldUpdateOperationsInput | number
    maxStreak?: IntFieldUpdateOperationsInput | number
    finalScore?: FloatFieldUpdateOperationsInput | number
    speedScore?: FloatFieldUpdateOperationsInput | number
    accuracyScore?: FloatFieldUpdateOperationsInput | number
    consistencyScore?: FloatFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type QuizResponseCreateManyAttemptInput = {
    id?: string
    questionId: string
    answer: string
    isCorrect: boolean
    responseTime: number
    answeredAt?: Date | string
  }

  export type QuizResponseUpdateWithoutAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: IntFieldUpdateOperationsInput | number
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizResponseUncheckedUpdateWithoutAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: IntFieldUpdateOperationsInput | number
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuizResponseUncheckedUpdateManyWithoutAttemptInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    isCorrect?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: IntFieldUpdateOperationsInput | number
    answeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}